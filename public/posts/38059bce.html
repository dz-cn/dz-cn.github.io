
<!DOCTYPE html>
<html lang="zh">
<head><!-- hexo injector head_begin start --><script src="https://cdn.jsdelivr.net/npm/echarts@5.5.1/dist/echarts.min.js"></script><!-- hexo injector head_begin end -->
    <meta charset="utf-8" />
    <title>操作系统知识点 | DZ博客</title>
    <meta name="author" content="dz.cn" />
    <meta name="description" content="稳-静-思" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.png" />

    <!--引入对应内容的js文件以及import.ejs文件-->
    <link rel="preconnect" href="https://s4.zstatic.net"/>
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css"/>
<link rel="preconnect" href="https://fonts.googleapis.cn"/>
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin/>
<link
        rel="stylesheet"
        href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

    <script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


    <script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
    <link
            rel="stylesheet"
            href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
    />
    <script src="/js/lib/highlight.js"></script>


    <script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
    <script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
    <link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css"/>
    <script src="/js/lib/math.js"></script>


    <script src="/js/lib/preview.js"></script>




    
    
    


<link rel="stylesheet" href="/css/main.css"/>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<meta name="generator" content="Hexo 8.0.0"></head>
<body>
    <div id="layout">
        <!--加载动画-->
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>加载中...</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>DZ博客</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;主页</span>
        </a>
        
        <a href="/echarts">
            <i class="fa-solid fa-square-poll-horizontal fa-fw"></i>
            <span>&ensp;热力图</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;文章</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;类型</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;标签</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;DZ博客</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">主页</div>
                    </div>
                </a>
                
                <a href="/echarts">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-square-poll-horizontal fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">热力图</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">文章</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">类型</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">标签</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>


        <!--主体-->
        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <!--当前要渲染的内容-->
            <div class="article">
    <!--文章标题-->
    <div>
        <h1>操作系统知识点</h1>
    </div>

    <!--每篇文章开头的信息-->
    <div class="info">
        <!--日期-->
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/10/28
        </span>
        <!--判断是否有分类-->
        
        <span class="category">
            
            <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="color: #006064">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                操作系统
            </a>
        </span>
        
        <!--判断是否有标签-->
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            <span class="tag">
                
                <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="color: #006064">
                    操作系统
                </a>
            </span>
            
        </span>
        

        <!--本文的阅读量-->
        <span style="margin-right: 15px">
            <span class="icon">
                <i class="fa-solid fa-eye"></i>
            </span>
            <span id="busuanzi_container_page_pv">
                <span id="busuanzi_value_page_pv"></span>
            </span>
        </span>

        <br>
        <!--本文的字数统计-->
        <span style="margin-right: 15px;">
            <span class="icon">
                <i class="fa-solid fa-pen"></i>
            </span>
            <span>9682 字 | 0 代码块</span>
        </span>
    </div>

    <!--加密配置，如果启用加密，这执行加密逻辑-->
    
    <div class="content" v-pre>
        <!-- toc -->

<ul>
<li><a href="#%E4%B8%80-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80">一、操作系统基础</a><ul>
<li><a href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">1、什么是操作系统</a></li>
<li><a href="#2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E6%A0%B8">2、操作系统的内核</a></li>
<li><a href="#3-%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%80%81">3、用户态和系统态</a></li>
<li><a href="#4-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">4、系统调用</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B">二、进程和线程</a><ul>
<li><a href="#1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB">1、进程和线程的区别</a></li>
<li><a href="#2-%E8%BF%9B%E7%A8%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81">2、进程有哪几种状态</a></li>
<li><a href="#3-%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F">3、进程间的通信方式</a></li>
<li><a href="#4-%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F">4、线程间的同步方式</a></li>
<li><a href="#5-%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6">5、进程的调度</a></li>
<li><a href="#6-%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81">6、什么是死锁</a></li>
<li><a href="#7-%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6">7、产生死锁的四个必要条件</a></li>
<li><a href="#8-%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E7%9A%84%E6%96%B9%E6%B3%95">8、解决死锁的方法</a><ul>
<li><a href="#1-%E6%AD%BB%E9%94%81%E7%9A%84%E9%A2%84%E9%98%B2">1、死锁的预防</a></li>
<li><a href="#2-%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81">2、避免死锁</a></li>
<li><a href="#3-%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B">3、死锁的检测</a></li>
<li><a href="#4-%E6%AD%BB%E9%94%81%E7%9A%84%E8%A7%A3%E9%99%A4">4、死锁的解除</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80">三、操作系统内存管理基础</a><ul>
<li><a href="#1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%BB%8B%E7%BB%8D">1、内存管理介绍</a></li>
<li><a href="#2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E4%B8%8E%E6%96%B9%E5%BC%8F">2、内存管理机制与方式</a></li>
<li><a href="#3-%E5%9D%97%E8%A1%A8%E5%92%8C%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8">3、块表和多级页表</a></li>
<li><a href="#4-%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6%E5%92%8C%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9%E5%92%8C%E5%8C%BA%E5%88%AB">4、分页机制和分段机制的共同点和区别</a></li>
<li><a href="#5-%E9%80%BB%E8%BE%91%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80">5、逻辑(虚拟)地址和物理地址</a></li>
<li><a href="#6-cpu-%E5%AF%BB%E5%9D%80">6、CPU 寻址</a></li>
<li><a href="#7-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4">7、为什么需要虚拟地址空间</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">四、虚拟内存</a><ul>
<li><a href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">1、什么是虚拟内存</a></li>
<li><a href="#2-%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86">2、局部性原理</a></li>
<li><a href="#3-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8">3、虚拟存储器</a></li>
<li><a href="#4-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0">4、虚拟内存的技术实现</a></li>
<li><a href="#5-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">5、页面置换算法</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h2><span id="一-操作系统基础">一、操作系统基础</span></h2><h3><span id="1-什么是操作系统">1、什么是操作系统</span></h3><p>​    操作系统（Operating System 简称 OS）本质上是一个运行在计算机上的软件程序，用于管理计算机硬件和软件资源。例如，运行在电脑上的所有应用程序都是通过操作系统来调用系统内存以及磁盘等硬件。</p>
<h3><span id="2-操作系统的内核">2、操作系统的内核</span></h3><p>​    操作系统的内核时操作系统的核心部分，负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。内核时连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。</p>
<h3><span id="3-用户态和系统态">3、用户态和系统态</span></h3><ul>
<li>用户态：用户态运行的进程可以直接读取用户程序的数据</li>
<li>系统态：可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制，包括内存、CPU 指令等</li>
</ul>
<h3><span id="4-系统调用">4、系统调用</span></h3><p>​    运行的程序基本都是运行在用户态，如果需要调用操作系统提供的系统态级别的子功能，就需要切换到系统态来调用。也就是说，运行的用户程序中，凡是与系统态级别的资源有关的操作（如 文件管理，进程控制，内存管理等），都必须通过系统调用方式向操作系统提出服务，并由操作系统代为完成。</p>
<p>​    系统调用大致分为一下几类：</p>
<ul>
<li>设备管理。完成设备的请求或释放，设备启动等功能。</li>
<li>文件管理。完成文件的读、写、创建、删除等功能。</li>
<li>进程管理。完成进程的创建、撤销、阻塞、唤醒等功能。</li>
<li>进程通信。完成进程之间的消息传递或信号传递等。</li>
<li>内存管理。完成内存的分配、回收、获取作业占用内存大小以及地址等。</li>
</ul>
<h2><span id="二-进程和线程">二、进程和线程</span></h2><h3><span id="1-进程和线程的区别">1、进程和线程的区别</span></h3><ul>
<li><strong>进程</strong>：操作系统进行<strong>资源分配的基本单位</strong>（如内存、CPU 时间片、文件句柄等），可理解为 “一个正在运行的程序实例”（例如打开的 Chrome 浏览器、一个 Java 程序），是一个独立的 “资源容器”。</li>
<li><strong>线程</strong>：操作系统进行<strong>任务调度的基本单位</strong>，是进程内的 “最小执行单元”（例如 Chrome 的一个标签页渲染线程、Java 程序的<code>main</code>线程），必须依赖进程存在，无法独立运行。</li>
</ul>
<p>​    从 JVM 的角度看，一个进程可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>，但是每个线程都有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>、<strong>本地方法栈</strong>。线程是进程划分成的更小的运行单元，一个进程在其执行的过程中可以产生多个线程。线程和进程最大的不同在于，进程之间是相互独立的，而线程之间不一定，因为同一个进程中的线程极有可能相互影响。线程执行开销小，但是不利于资源的管理和保护，而进程正相反。</p>
<h3><span id="2-进程有哪几种状态">2、进程有哪几种状态</span></h3><ul>
<li><strong>创建状态</strong> ：进程正被创建。<ul>
<li>引起进程创建原因：用户登录、作业调度、提供服务、应用请求 都会引起进程的创建。</li>
</ul>
</li>
<li><strong>就绪状态</strong> ：进程已处于准备运行状态，即 进程获得了除处理器以外的一切所需的资源，一旦得到处理器资源，即可运行。</li>
<li><strong>运行状态</strong> ：进程正在处理器上运行。</li>
<li><strong>阻塞状态</strong> ：进程正在等待某一事件而暂停运行，即使处理器处于空闲状态，该进程也不能运行，是进程主动提出<ul>
<li>原因：向操作系统请求共享资源失败、等待某种操作的完成、新数据尚未、等待IO操作的结束。</li>
</ul>
</li>
<li><strong>终止状态</strong> ：进程终止运行。<ul>
<li>原因：正常结束、异常结束、外界干预。</li>
</ul>
</li>
</ul>
<p>补充：</p>
<ul>
<li><strong>进程的挂起</strong> ：当系统中出现引起进程挂起的事件时，OS 会利用挂起原语将指定的进程挂起，如果进程时就绪状态，则改为静止就绪状态，如果是阻塞状态，则改为静止阻塞，如果运行状态，则将其转向调度程序重新调度。</li>
<li><strong>进程的激活</strong> ：当系统中出现激活进程的事件后，OS 会利用原语将指定的进程激活。</li>
</ul>
<h3><span id="3-进程间的通信方式">3、进程间的通信方式</span></h3><ul>
<li><strong>管道通信</strong><ul>
<li>匿名管道：用于父进程和子进程之间的通信。</li>
<li>有名管道：用于任意两个进程之间的通信。</li>
</ul>
</li>
<li><strong>信号</strong>：信号是一种比较复杂的通信方式，用于通知接收进程有某种事件发生。</li>
<li><strong>消息队列</strong>：消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道不同的是消息队列存放在内核中，只有在内核重启或者显示地删除一个消息队列时，该消息才会被真正的删除。消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按照消息的类型读取。<strong>消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</strong></li>
<li><strong>信号量</strong> ：信号量是一个计数器，常被作为一种<strong>锁机制</strong>，用于多进程对共享数据的访问，信号量主要作为进程间以及同一进程内不同线程间的同步手段。</li>
<li><strong>共享内存</strong> ：共享内存可以使运行在同一台机器上的进程间的<strong>通信最快</strong>。使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存种数据的更新，这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。</li>
<li><strong>套接字</strong> ：此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持TCP&#x2F;IP的网络通信的基本操作单元，可以看作是不同主机之间的进程进行双向通信的端点，简单来说就是通信双方的一种约定，用套接字的相关函数来完成通信过程。</li>
</ul>
<h3><span id="4-线程间的同步方式">4、线程间的同步方式</span></h3><p>​    线程同步是两个或多个共享资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步方式。</p>
<ul>
<li><p><strong>互斥量</strong> ：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。例如：Java 中的synchronized 关键字和各种Lock都是这种机制。</p>
</li>
<li><p><strong>信号量</strong> ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</p>
</li>
<li><p><strong>事件</strong> ：通过通知操作（挂起和唤醒）的方式来保持多线程同步，还可以方便的实现多线程优先级得比较操作。</p>
</li>
</ul>
<h3><span id="5-进程的调度">5、进程的调度</span></h3><p>​    进程调度的任务主要有三，① 保存CPU现场信息 ② 按照某种算法选取进程 ③ 把 CPU 分配给该进程</p>
<p>​    进程调度算法一般有四种：</p>
<ul>
<li><p><strong>先到先服务</strong> ： 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某种事件而被阻塞放弃占用CPU资源时再重新调度。</p>
</li>
<li><p><strong>短作业优先</strong> ：从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某种事件而被阻塞放弃占用CPU资源时再重新调度。</p>
<ul>
<li>缺点：必须预先知道作业的运行时间，但是这个时间很难估计准确，如果偏短，系统可能会提前终止进程。</li>
<li>缺点：对长作业非常不利，周转时间会明显增长。</li>
<li>缺点：完全没有考虑作业的紧迫程度。</li>
</ul>
</li>
<li><p><strong>时间片轮转</strong> ：时间片轮转调度是一种古老，最简单，最公平且使用最广的调度算法，每个进程被分配一个时间段，称作它的时间片，也就是该进程允许运行的时间。</p>
</li>
<li><p><strong>多级反馈队列</strong> ：<strong>短进程优先</strong> 仅照顾了短进程，而忽略了长进程。而多级返回调度算法既能使高优先级的作业得到响应，又能响应短作业进程迅速完成，因此是被公认的最好的调度算法，UNIX 采用的就是这种调度算法。</p>
<ul>
<li>机制：① 设置多个就绪队列</li>
<li>机制：② 每个队列都采用先来先服务调度算法</li>
<li>机制：③ 按队列优先级调度</li>
</ul>
</li>
<li><p><strong>优先级调度</strong> ：为每个进程分配优先级，首先执行具有高优先级的进程，以此类推，具有相同优先级的进程以先进先出的顺序执行。可以根据内存要求，时间要求或者任何其他资源的要求来确定优先级。</p>
</li>
</ul>
<h3><span id="6-什么是死锁">6、什么是死锁</span></h3><p>​    死锁描述的是这样一种情况，多个进程&#x2F;线程同时被阻塞，他们中的一个或全部都在等待某个资源被释放，但他们都会因为不能不能获得自己的资源去继续运行而无法释放自己当下占有的资源，并且一直处于这样的僵持状态，而形成死锁。</p>
<h3><span id="7-产生死锁的四个必要条件">7、产生死锁的四个必要条件</span></h3><ul>
<li><strong>互斥条件</strong> ：资源必须处于非共享模式，即：一次只有一个进程可以使用。如果另一个进程申请该资源，那么必须等待直到该资源被释放为止。</li>
<li><strong>请求和保持条件</strong> ：一个进程至少占有了一个资源，并等待另一个资源，而该资源被其它线程所占有。</li>
<li><strong>不可抢占条件</strong> ： 资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。</li>
<li><strong>循环等待条件</strong> ：一组进程<code>{P0,P1,...,Pn}</code> <code>P0</code> 等待的资源被 <code>P1</code>占有，<code>P1</code> 等待的资源被<code>P2</code> 占有，最后 <code>Pn</code> 等待的资源被<code>P1</code> 占有，形成循环等待的情况。</li>
</ul>
<blockquote>
<p>这四个条件是产生死锁的 <strong>必要条件</strong> ，也就是说只要系统发生死锁，这些条件必然成立，而只要让上述条件之一不满足，就不会产生死锁。</p>
</blockquote>
<h3><span id="8-解决死锁的方法">8、解决死锁的方法</span></h3><h4><span id="1-死锁的预防">1、死锁的预防</span></h4><p>​		<strong>预防死锁</strong> ：是采用某种策略，<strong>限制并发进程对资源的请求</strong>，从而使得死锁的必要条件在系统执行的任何时间都不满足。</p>
<p>​		只要破坏四个必要条件中的一个就能够预防死锁的发生。</p>
<p>​    	破坏第一个条件 <strong>互斥条件</strong> ：使得资源可以同时被访问，这种是最简单的方法，磁盘可以用这种方法管理，但是系统中的很多资源 <strong>往往是不能被同时访问的</strong> ，所以这种做法在大多数场合是行不通的。</p>
<p>​    	破坏第三个条件 <strong>不可抢占条件</strong> ：也就是说，可以采用 <strong>剥夺式调度算法</strong> ，但是，这种调度算法实现起来比较复杂，并且一个资源在被使用一段时间后被抢占，可能导致进程前一段时间的工作失效，还可能因为反复申请和释放资源导致进程的执行被无限期的推迟，既增加了系统开销，也降低了吞吐量。</p>
<p>​    	所以，一般比较实用的预防死锁的方法是，通过破坏第二个条件和第四个条件。</p>
<ol>
<li><strong>静态分配策略</strong></li>
</ol>
<p>​    静态分配策略就是指一个进程必须在执行前就申请到它所需要的全部资源，否则直到它所要的资源得到满足后才开始运行。进程要么占有所有资源开始运行，要么不占有资源，不会出现一些资源等待一些资源的情况。</p>
<p>​    静态分配策略逻辑简单，实现也很容易，但这种策略 <strong>严重地降低了资源利用率</strong>，因为在每个进程所占有的资源中，有一些资源是在比较靠后的执行时间里才用的，甚至有些资源是在额外的情况下才使用的，这样就可能造成一个进程占有了一些 <strong>几乎不用的资源而是使用其他需要该资源的进程产生等待</strong> 的情况。</p>
<ol>
<li><strong>2、层次分配策略</strong></li>
</ol>
<p>​    层次分配策略破坏了产生死锁的第四个条件，在层次分配策略下，所有的资源被分成了多个层次，一个进程得到某一次的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源，这种策略，是不能可能出现循环等待链的，因为那样的话，就出现了已经申请了较高层的资源，反而去申请了较低层的资源，不符合层次分配策略。</p>
<h4><span id="2-避免死锁">2、避免死锁</span></h4><p>​		<strong>避免死锁</strong> ：是系统在分配资源时，根据资源的使用情况<strong>提前做出预测</strong>，从而<strong>避免死锁的发生</strong></p>
<p>​		死锁的避免的角度是允许系统中<strong>同时存在四个必要条件</strong>，只要掌握并发进程中与每个进程有关的资源动态申请情况，做出 <strong>明智合理的选择</strong>，仍可以避免死锁，因为四大条件仅仅是产生死锁的必要条件。</p>
<p>​    可以将系统分为 <strong>安全状态</strong> 和 <strong>不安全状态</strong> ，每当为申请者分配资源前，先检测系统状态，如果把系统资源分配给申请者会产生死锁，则拒绝分配，否则接受申请，并为它分配资源。</p>
<blockquote>
<p>安全状态，如果操作系统能够保证所有进程在有限时间内得到需要的全部资源，否则是不安全状态</p>
</blockquote>
<p>​    	避免死锁的算法是，<strong>银行家算法</strong> ，也就是：当一个线程申请使用资源时，<strong>银行家算法</strong> 通过 <strong>试探</strong> 分配给该进程资源，然后通过 <strong>安全性算法</strong> 分析分配后系统是否处于安全状态，若处于不安全状态，则试探分配作废，让该进程继续等待，若能够进入安全状态，则就<strong>真的分配资源给该进程</strong></p>
<h4><span id="3-死锁的检测">3、死锁的检测</span></h4><p>​		<strong>检测死锁</strong> ：是指系统设有<strong>专门的机构</strong>，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。</p>
<p>​		这种方法对资源的分配不加以限制，也不采取死锁避免的措施，但系统会<strong>定时地运行一个 “死锁检测” 的程序</strong>，判断系统内是否出现死锁，如果检测到系统发生了死锁，再采取措施去解除它。</p>
<p>​		可以利用 <strong>进程-资源分配图</strong> 是否又环路来检测死锁，但是，有环路不一定死锁。</p>
<h4><span id="4-死锁的解除">4、死锁的解除</span></h4><p>​		<strong>解除死锁</strong> ：是与检测相配套的一种措施，用于<strong>将进程从死锁状态下解脱出来</strong></p>
<p>​		当死锁检测程序检测到存在死锁发生时，应设法让其解除，让系统从死锁中恢复过来。</p>
<ul>
<li><strong>立即结束所有进程的执行，重新启动操作系统</strong>，方法简单，但是之前的工作全部作废，损失很大。</li>
<li><strong>撤销涉及死锁的所有进程，解除死锁后继续运行</strong>，彻底打破死锁的循环等待条件，付出的代价也较大，例如一个进程计算了很长时间，由于被撤销，部分结果也被消除，重新执行就要再次计算。</li>
<li><strong>逐个撤销涉及死锁的进程，回收资源直到死锁解除</strong></li>
<li><strong>抢占资源</strong>，从涉及死锁的一个或几个进程中抢占资源，再把夺到的资源分配出去，知道死锁解除。</li>
</ul>
<h2><span id="三-操作系统内存管理基础">三、操作系统内存管理基础</span></h2><h3><span id="1-内存管理介绍">1、内存管理介绍</span></h3><p>​		操作系统的内存管理主要负责内存的分配和回收，另外地址转换也就是将逻辑地址转换为相应的物理地址等功能也是操作系统内存管理的事情。</p>
<h3><span id="2-内存管理机制与方式">2、内存管理机制与方式</span></h3><p>​		简单的分为 <strong>连续分配管理方式</strong> 和 <strong>非连续分配管理方式</strong> 这两种。连续分配管理方式是指为一个用户程序分配一段连续的内存空间，常见的如 <strong>块式管理</strong>。同样的，非连续分配管理方式，允许一个程序使用的内存分布在离散或者说不相邻的内存空间中，常见的有 <strong>页式管理</strong> 、 <strong>段式管理</strong>、<strong>段页式管理</strong>。</p>
<ol>
<li><p><strong>块式管理</strong>：远古时代的计算机操作系统的内存管理方式。将内存分为几个固定大小的块，每个块只包含一个进程。如果程序需要内存的话，操作系统就分配给它一个块，如果程序运行只需要很小的空间的话，分配的这个块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。</p>
</li>
<li><p><strong>页式管理</strong>：把主存分为大小相等且固定的一页一页的形式，页比较小，相比于块式管理，划分粒度更小，提高了内存的利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。</p>
<p>地址转化：</p>
<p><code>逻辑地址 = 页号（Page Number） + 页内偏移（Offset）</code></p>
<p><code>物理地址 = 页框号（Frame Number） + 页内偏移（Offset）</code></p>
</li>
<li><p><strong>段式管理</strong>：页式管理虽然提高了内存利用率，但是页式管理中的页并无任何实际的意义。段式管理把主存分为一段一段的，段是有实际的意义的，每个段顶一了一组逻辑信息，例如，有主程序段、子程序段、数据段、栈段等。段式管理通过段表对应的逻辑地址和物理地址。</p>
<p>地址转换：</p>
<p><code>逻辑地址 = 段号（Segment Number） + 段内偏移（Offset）</code></p>
<p><code>物理地址 = 段基址（Base Address） + 段内偏移（Offset）</code></p>
</li>
<li><p><strong>段页式管理</strong>：段页式管理机制结合了段式管理和页式管理的优点。简单来说，段页式管理机制就是把主存先分成若干个段，每个段又分成若干个页，也就是说 <strong>段页式管理机制</strong> 中段与段之间以及段的内部之间都是离散的。</p>
</li>
</ol>
<blockquote>
<p>总的来说：页是物理单位，段是逻辑单位。分页可以有效的提高内存的利用率，分段可以更好的满足用户的需求。</p>
</blockquote>
<h3><span id="3-块表和多级页表">3、块表和多级页表</span></h3><ol>
<li><p>快表和多级页表，这两个内容解决了页表管理中很重要的两个问题。</p>
<ol>
<li>虚拟地址到物理地址的转换要快。</li>
<li>解决当虚拟地址空间大的时候，页表也会很大的问题。</li>
</ol>
</li>
<li><p><strong>快表</strong></p>
<p>​    为了提高虚拟机地址到物理地址的转换速度，操作系统在 <strong>页表方案</strong> 基础之上引入了 <strong>快表</strong> 来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器，其中的内容是页表的一部分或者全部内容。作为页表的 cache ，他的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时，CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。</p>
<p>​    使用快表之后的地址转换流程是这样的：</p>
<ol>
<li>根据虚拟地址中的页号查快表。</li>
<li>如果该页在快表中，直接从快表中读取相应的物理地址。</li>
<li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中。</li>
<li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</li>
</ol>
</li>
<li><p><strong>多级页表</strong></p>
<p>​    引入多级页表的目的主要是为了避免把全部页表一直放在内存中占用过多的空间，特别是那些根本不需要的页表就不要保留在内存中。</p>
<p>​    多级页表属于时间换空间的经典场景。</p>
</li>
</ol>
<h3><span id="4-分页机制和分段机制的共同点和区别">4、分页机制和分段机制的共同点和区别</span></h3><ul>
<li><p><strong>共同点</strong>：</p>
</li>
<li><p>分页机制和分段机制都是为了提高内存利用率，减少内存碎片化。</p>
</li>
<li><p>页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。</p>
</li>
<li><p><strong>区别</strong>：</p>
<ul>
<li>页的大小是固定的，由操作系统决定，而段的大小不固定，取决于我们当前运行的程序。</li>
<li>分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。</li>
</ul>
</li>
</ul>
<h3><span id="5-逻辑虚拟地址和物理地址">5、逻辑(虚拟)地址和物理地址</span></h3><ul>
<li><strong>逻辑(虚拟)地址</strong><ul>
<li>由 CPU 在执行程序时生成的地址，是<strong>进程 “看到” 的内存地址</strong>，不直接对应物理内存硬件的实际位置。</li>
<li>进程独立性：每个进程有自己独立的逻辑地址空间，进程 A 的 0x1000 地址和进程 B 的 0x1000 地址毫无关联，避免进程间内存干扰。</li>
<li>非直接访问：逻辑地址无法直接用于访问物理内存，必须先转换为物理地址。</li>
</ul>
</li>
<li><strong>物理地址</strong><ul>
<li>计算机物理内存（如内存条）硬件本身的真实地址，是<strong>内存芯片引脚能直接识别的地址</strong>，对应内存单元的实际物理位置。</li>
<li>硬件唯一性：物理地址由内存硬件决定，整个系统中每个物理地址唯一，直接对应硬件单元。</li>
<li>直接访问性：只有物理地址能被内存控制器识别，用于读取 &#x2F; 写入内存数据。</li>
</ul>
</li>
</ul>
<h3><span id="6-cpu-寻址">6、CPU 寻址</span></h3><ul>
<li><strong>CPU 寻址</strong><ul>
<li>现代处理器使用的是一种称为 <strong>虚拟寻址</strong> 的寻址方式，也就是 CPU 将虚拟地址翻译为物理地址，而完成这个转换工作的是 CPU 中包含的一个被称为 <strong>内存管理单元（MMU）</strong> 的硬件。</li>
<li>具体过程：<strong>地址拆分</strong>、<strong>页表查询</strong>、<strong>地址拼接</strong>、<strong>内存访问</strong>。</li>
</ul>
</li>
</ul>
<h3><span id="7-为什么需要虚拟地址空间">7、为什么需要虚拟地址空间</span></h3><p>​		先从没有虚拟地址空间的时候说起，没有虚拟地址空间的时候，<strong>程序直接访问和操作的都是物理内存</strong>。但是这样存在很大的问题。</p>
<p>​		1、用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易破坏系统，造成操作系统的崩溃。</p>
<p>​		2、想要同时运行多个程序特别困难，比如想同时运行一个微信和一个QQ音乐，微信运行时，为 1xxx 的地址赋值</p>
<p>​				后，QQ音乐也同样给内存 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖之前的值，导致微信程序的崩溃。</p>
<p>​		通过虚拟地址访问内存有以下优势：</p>
<ul>
<li>程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。</li>
<li>程序可以使用一系列虚拟地址来访问大于可用物理地址内存的内存缓冲区，也就是当物理内存不够使用时，内存管理器会将物理内存页（通常大小 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。</li>
<li>不同进程使用的虚拟地址彼此之间隔离。一个进程中的代码无法更改正在由另一个进程或操作系统使用的物理内存。</li>
</ul>
<h2><span id="四-虚拟内存">四、虚拟内存</span></h2><h3><span id="1-什么是虚拟内存">1、什么是虚拟内存</span></h3><p>​		在我们平时使用的电脑特别是 Windows 系统十分常见。很多时候，我们使用了很多占内存的软件，这些软件占用的内存可能已将远远超出了我们电脑本身具有的物理内存。这正是因为 <strong>虚拟内存</strong> 的存在，通过虚拟内存可以让程序拥有超过系统物理内存大小的可以用内存空间。另外，<strong>虚拟内存为每个进程提供了一个一致的，私有的地址空间，他让每个进程产生了一种自己在独享主存的错觉</strong>。这样更加有效的管理内存并减少出错。虚拟内存的重要意义在于：<strong>它定义了一个连续的虚拟孔吉纳，并且把内存扩展到硬盘空间。</strong></p>
<h3><span id="2-局部性原理">2、局部性原理</span></h3><p>​		局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。也就是说，在某个较短的时间段内，程序执行局限于某一小部分，程序访问的存储空间也局限于某个区域。</p>
<ul>
<li><strong>时间局部性</strong>：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久之后该数据可能再次被访问。产生时间局部性的经典原因，是由于在程序中存在着大量的循环操作。</li>
<li><strong>空间局部性</strong>：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量，数组，表等形式簇集储存的。</li>
</ul>
<h3><span id="3-虚拟存储器">3、虚拟存储器</span></h3><p>​    所谓的虚拟存储器，是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩展的一种存储器。</p>
<p>​    一般具有三大特征：</p>
<ul>
<li><strong>多次性</strong>：是指一个作业中的程序和数据无需在作业运行时一次性的调入内存，而是被被允许分成多次调入内存允许。</li>
<li><strong>对换性</strong>：是指一个作业中的程序和数据无需在作业运行时一直常驻内存，而是允许他们在作业运行时换入和唤出</li>
<li><strong>虚拟性</strong>：是指能够从逻辑上扩大容量，使用户看到的内存容量远大于实际内存容量。</li>
</ul>
<h3><span id="4-虚拟内存的技术实现">4、虚拟内存的技术实现</span></h3><p>​    <strong>虚拟内存技术的实现，需要建立在离散分配内存管理方式的基础上</strong> 。虚拟内存的实现有一下三种方式：</p>
<ul>
<li><p><strong>请求分页存储管理</strong>：建立在分页系统之上，增加了请求分页功能和页面置换功能所形成的页式虚拟存储系统。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储器系统中，在作业开始运行之前，仅装入当前要执行的部分页面即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入主存，同时操作系统也可以将暂时不使用的页面置换到外存中。</p>
</li>
<li><p><strong>请求分段存储器管理</strong>：建立在分段系统之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可；在执行过程中，可以使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已经满了，而又需装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。</p>
</li>
<li><p><strong>请求段页式存储管理</strong>：</p>
<blockquote>
<p>请求分页和分页存储系统的不同</p>
<p>请求分页存储管理建立在分页管理之上，根本区别就是是否将程序全部地址空间都装入主存。</p>
</blockquote>
</li>
</ul>
<h3><span id="5-页面置换算法">5、页面置换算法</span></h3><p>​    地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断。</p>
<p>​    当发生缺页中断时，如果当前内存中没有空闲的页面，操作系统就必须在内存中选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法，我们可以把页面置换算法看成是淘汰页面的规则。</p>
<ul>
<li><strong>OPT 页面置换算法（最佳页面置换算法）</strong>：最佳页面置换算法所选择的被淘汰的页面将是以后永不使用的，或者是在很长在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。但是由于人们目前无法预知进程内存下的若干页面中那个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。</li>
<li><strong>FIFO 页面置换算法（先进先出页面置换算法）</strong>：总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。</li>
<li><strong>LRU 页面置换算法（最近最久未使用页面置换算法）</strong>：LRU 算法赋予每一个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当淘汰一个页面时，选择现有页面中 T 最大的，即最近最久未使用的页面予以淘汰。</li>
<li><strong>LFU 页面置换算法 （最少使用页面置换算法）</strong>：该置换算法选择在之前时期使用最少的页面作为淘汰页。</li>
</ul>

    </div>
    

    <!--如果启用文章的评论，显示评论逻辑-->
    
    
    
    
    
    
</div>


            <!--页脚内容-->
            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy; 2025 - 2025 DZ博客
            <i class="fa-solid fa-font-awesome fa-fw"></i>
            <a href= "http://example.com">&commat;dz.cn</a>
            <br>
            总访问量 <span id="busuanzi_value_site_pv"></span> 次 | 总访客数 <span id="busuanzi_value_site_uv"></span> 人次
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>
        </div>

        <!--图片预览-->
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    <!--评论的显示-->
    
    




    
</body>
</html>
