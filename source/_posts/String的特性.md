---
title: String的特性
tags:
  - String
description: |
  String 的基本特性以及用法和常考题
pinned: 0
lang: zh
categories:
  - Java 基础篇
type: post
wordCount: 134
charCount: 2565
imgCount: 0
vidCount: 0
wsCount: 0
cbCount: 0
readTime: 约56秒
abbrlink: 70e3fcb2
date: 2025-10-27 22:23:41
---
<!-- toc -->
### 1、String 为什么是不可变的？

##### 1）原因：

① **安全性** ：String 类常用于存储敏感信息，如密码，路径等，如果它是可变的，攻击者可能通过修改字符串内容来绕过安全检查。同时Java的类加载器在加载类时会使用String来存储类名和包名，如果String是可变的，攻击者可能加载恶意的类破坏系统。Java String 类的不可变性，确保了这些关键字符串在创建并传递后，其值绝对无法被任何代码（包括自身）所改变，从根本上杜绝了被篡改的风险。是系统安全性的基石。

② **字符串常量池依赖不可变性** ：String 类是程序中最常用的，同时存在大量重复字符串，为了解决大量重复的问题，引入了字符串常量池，当创建字符串时，JVM 会优先从池中找，没有再创建，而这个优化完全依赖String的不可变性，因为常量池中的一个对象可能被多次引用，如果其中的任何一个引用能修改对象的值，那末就会导致所有共享该对象的引用全部出错。

③ 在**多线程**模式下，可以自由传递、共享 String，不需要任何同步机制，简化了开发。

④ 由于 String 的不可变性，因此 String 对象的hash值只用计算一次，后续直接从缓存中读取，提高了集合的性能。

##### 2）实现方法：

​      `String` 类的核心参数为 `value` 数组，在`JDK 9` 之后，使用 `byte[]`  代替 `char[]` 。`value` 值由` final` 关键字修饰，保证数据引用的不变性，用 `private`修饰，保证外部无法直接修改，同时 `String` 类由 `final` 修饰，保证不会被继承，防止子类的修改。在 `JDK 9` 版本时，还引用了`Java` 的内部注解`@Stable`，修饰 `value` ，用于提示 `JVM` ，这是一个稳定的字段，一旦赋值，基本不会改变，是运行时的稳定承诺。当访问一个普通字段时，因可能被其他线程修改，理论上需每次从内存加载（但实际受 CPU 缓存优化影响，可能读取旧值）；但是由`@Stable` 注解修饰后，在高频访问时，可能在读取后，就将值存储到一个寄存器中，后续直接从寄存器中取值即可。同时，在编译时可能直接把这个值当作常量，将其内敛到使用它的地方，也被称为 常量折叠 提升运行速度。注意：仍可以用反射调用修改，但是开发者往往不被允许。

### 2、String、StirngBuffer、StirngBuilder 的区别？

##### 1）不可变性：

​      String 是不可变的，任何操作都会产生新的对象，原字符串不做改变。StringBuilder 和 StringBuffer 都是可变的，都是直接在原对象上修改，避免创建新的对象。具体是StringBuilder 和 StringBuffer 都继承AbstractStringBuilder抽象类，其字符都是存储在 value 中，没有使用 final 修饰，当修改时，若 value 容量不够，则会将 value 数组进行扩容，之后，将新串复制到扩容后的数组中。因此只是替换了value数组，原StringBuilder 和 StringBuffer 对象的引用没有改变。

##### 2）线程安全性：

​      String 由不可变性，天然就是线程安全的。StringBuilder 是线程不安全的，多线程模式下可能会导致数据不一致问题。StringBuffer 是线程安全的，所有的方法都是用 Synchorized 修饰。

##### 3）性能（大致）：

​      String（反复创建对象） < StringBuffer（多线程下的加锁解锁） < StringBuilder （单线程下性能高）

### 3、字符串常量池？

##### 1）存储位置：

​      在 JDK 7 之前，字符串常量池位于方法区的永久代中，在JDK 7 之后，字符串常量池也被移动至堆内。

##### 2）存储内容：

​      在 JDK 7 之前，存储的是字符串本身，在移动到堆后，存储的是字符串在堆内存上的引用。对于没有引用的对象，可被垃圾回收器回收，防止内存泄漏。

##### 3）使用方法：

​      String s1 = “Hello” ，则会自动入池，并通过池中的引用指向堆中的“Hello”，而String s2 = new String(“Hello”) ,则是直接在堆内存中创建了一个新的对象，不会进入字符串常量池中。但是可以使用 s2.intern() 方法，将字符串手动添加到常量池中，并返回引用。

##### 4）数据结构：

​      字符串常量池是通过基于Hash表的StringTable实现，JDK 7 之前，固定大小，之后，可指定大小， JDK 9 时，将char[] 改为 byte[]。

### 4、JDK 9 为什么将Stirng的char[]改为byte[]？

##### 1）内存的优化：

​      用char数组时，一个char 占用 2 个字节，实际中，英文，数字，特殊字符占使用的大多数，且是需要 1 个字节。对于byte数组，字符，英文，数字等，都只占用 1 个字节，中文占用 2 个字。例如，对于 “Hello” ，char 数组存需要 5 * 2 = 10B，对于byte数组只需要 5B，节省了近50%的空间。

##### 2）自适应编码

​      根据不同的字符串使用不同的编码。当仅包含 1 个字节的字符时，String 中的coder标志位为 0 ，表示使用单字节编码字符集，当字符串中存在 2 个字节的字符时，String 中的coder标志位为 1，表示采用双字节编码字符集，同时，当单字节字符串拼接上双字节字符串时，会将coder升级为1，表示采用双字节编码字符集。

### 5、Substring() 的优化？

​      substring：在JDK 6 以及之前，时复用原数组，即使只是用一小部分呢，但是要保留整个字符串，导致原字符串无法被GC，在JDK 7 之后，则是会创建一个新的字符串返回，原字符串可以被GC。
