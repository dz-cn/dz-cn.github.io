---
title: ArrayList集合
tags:
  - ArrayList
description: |
  文章缩略，支持 `Markdown` **文档格式**
pinned: 0
lang: zh
categories:
  - Java 基础篇
type: post
wordCount: 49
charCount: 1853
imgCount: 0
vidCount: 0
wsCount: 0
cbCount: 0
readTime: 约24秒
abbrlink: 6ff8c531
date: 2025-10-27 22:25:43
---
### 1、ArrayList 的底层数据结构是什么？

​      ArrayList 的底层数据结构是 Object 类型的 elementData 数组，该数组具有动态可扩容机制，即动态可扩容数组。该数组由 transient 修饰，标记为不可序列化，用来解决在数组序列化时，会将空元素也序列化的问题。同时实现了 writeObject 和 readObject 方法，来手动实现有效元素的序列化和反序列化。

### 2、ArrayList 如何添加元素？扩容机制是什么？

#####       1）添加元素：

​            通过 add() 方法用来添加元素，而 add() 方法，实际上是调用内部私有的add() 方法，向elementData 数组中添加元素。

#####       2）扩容机制：

- 首先，检查数组当前的有效元素的数量是否等于elementData的总长度。
    - 如果不相等，说明数组未满，则直接添加，并将size的大小加一。
    - 如果相等，说明当前的空间已经用完，则进入gow()，并将扩容后的数组赋值给elementData数组，然后继续将元素放入，size的大小加一。
        - 对于grow()方法，入参为最小扩容量，即扩容后的大小一定大于等于这个入参的值，具体的实现为，先获取到数组的整个长度，然后将数组的长度增加为原来的1.5倍后，与入参，即最小扩容量相比。
            - 如果大于等于入参，那末直接用1.5倍的值作为新数组长度。
            - 反之直接用最小扩容量最为新数组的长度。
            - 最后调用Arrays的copy()方法，将数组进行扩容，而这个方法本质是调用底层的System.arraycopy的本地方法来进行数组的扩容。

### 3、ArrayList 是否线程安全？如何解决？

#####       1）线程安全：

​           是非线程安全的，其根本原因是内部没有同步机制，所有的操作都是共享数组和计数器，关键操作并没有原子性。多线程模式下容易出现ConcurrentModificationException 等异常。

#####       2）解决方案：

​           ① 对于轻度并发场景，使用并发工具包Collections的SynchronizedList() 方法，构造线程安全的集合，原理就是通过包装器为所有的方法都加上Synchronized锁，但是，并发性能低，迭代时必须显示的加上锁，因为并发工具包只是为独立的方法加上了 Synchroized(mutex)，而迭代时的多个操作，涉及hasNext、next操作，这些组合操作本身并不是原子的，因此在迭代时，需要显示的加上锁。

​           ② CopyOnWriteArrayList 适用于读多写少的情况，原理就是，在写操作时，复制整个数组，同时数组的长度加1，在新数组的最后位置加上一个元素，再用新数组替换旧数组。而在添加的过程中，在jdk 9 之前用的都是 ReentrantLook 锁，而在jdk 9 之后，用的就是Synchroized。

​           ③ Vector，是线程安全的，原理就是每个方法都用 Synchroized 锁，但是性能较低，迭代器问题未解决。由于锁的力度比较粗，所有公共方法都被Synchroized 修饰，单线程每次调用都有锁的开销，而在多线程模式下，即使是读操作之间也会互斥，无法并发。并且默认扩容为原来的2倍，容易造成内存泄漏。同时迭代器也没有实现线程安全。

​           ④ 手动同步。

### 4、为什么ArrayList扩容为原来的1.5倍？

​      扩容较大会有OOM以及内存浪费，扩容较小会有多次扩容，浪费性能。而1.5是在扩容频率适中，空间利用率最高的大小。

### 5、如何在迭代过程中删除元素？

​      调用迭代器自身提供的remove()方法，进行删除元素，原理是在调用过程中，会更新modCount的值，不会触发快速失败。

### 6、modCount 字段的作用是什么？

​      modCount 是结构修改哨兵，任何有关修改数组的结构的操作都会导致modCount加1，包括添加元素，删除元素，但是替换元素不会导致modCount加1。当在迭代过程中，会先记录modCount的值，每次迭代调用next()方法都会对比是否相同，不相同直接抛出ConcurrantModificationException。多线程下，防止一个线程迭代，一个线程修改的情况，单线程中以最低的成本实现快速失败，防止数据不一致。

### 7、快速失败 + 安全失败

​    *快速失败*：通过检测集合的并发修改，及时抛出异常来避免潜在的逻辑错误。即：通过修改计数器 modCont 记录修改次数，当出现不一致的情况时，立即抛出 `ConcurrentModificationException` 异常。但它**不解决线程安全问题**，仅用于快速暴露问题。

*安全失败*：例如 `CopyOnWriteArrayList` 在创建迭代器时，会生成当前集合的快照，遍历通过这个快照进行遍历。因此，当迭代过程中进行修改时，修改的结果不会影响快照的内容，导致迭代过程中无法感知集合的实时变化。适合读多写少、对实时性要求不高的场景。