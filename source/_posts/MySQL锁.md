---
title: MySQL锁
tags:
  - MySQL锁
description: |
  文章缩略，支持 `Markdown` **文档格式**
pinned: 0
lang: zh
categories:
  - MySQL 篇
type: post
wordCount: 107
charCount: 2507
imgCount: 0
vidCount: 0
wsCount: 0
cbCount: 0
readTime: 约46秒
date: 2025-10-28 16:40:31
---
### 1、锁的分类

- 全局锁：锁住整个数据库，也就是锁住数据库中所有的表。
- 表级锁：锁住整张表。
- 行级锁：锁住单独的一行数据。



### 2、全局锁

#### 2.1 全局锁的分类和作用

​		MySQL全局锁是针对整个数据库的锁。最常用的全局锁是读锁和写锁。

- 读锁（共享锁）：它阻止其他用户更新数据，但允许他们读取数据。
- 写锁（排他锁）：它阻止其他用户读取和更新数据。

#### 2.2 全局锁的用法

- `FLUSH TABLES WITH READ/WRITE LOCK(FTWRL)`：用来锁住整个数据库
- `UNLOCK TABLES` ：进行解锁

#### 2.3 全局锁的使用场景

- **备份全库**：使用全局锁可以确保在备份过程中，数据库的所有表都保持一致的状态。
- **整体数据迁移**：将整个数据库从一个服务器迁移到另一个服务器，需要阻止任何写操作，以确保所有的数据都被正确地迁移到新的服务器。
- **全库只读**：在某些情况下，可能希望将整个数据库设置为只读模式。



### 3、表级锁

#### 3.1 表级锁的分类

- 表锁

- 元数据锁

- 意向锁

  > ​		这里可能会疑惑为什么有表锁、意向锁、元数据锁会**处于同一层级**，不应该是表锁包含元数据锁和意向锁吗，这里其实陷入了一个误区，其实，表锁、意向锁、元数据锁 都属于 表**级**锁，而表**级**锁当然包括了表锁，同时，元数据锁和意向锁也都属于表**级**锁，同样，行锁和行**级**锁也是同样的道理，后面就不赘述了。

#### 3.2 表锁

##### 3.2.1 表锁的概念和分类

​		表锁是**最基础的表级锁**，直接对整个表进行锁定，分为**读锁和写锁**，二者遵循 “读共享、写独占” 原则。

- **读锁（Shared Lock，简称 S 锁）**：事务加读锁后，自身和其他事务只能读表，不能修改表数据。多个事务可同时对同一表加读锁，互不阻塞。
- **写锁（Exclusive Lock，简称 X 锁）**：事务加写锁后，只有自身能读写表数据，其他事务无法加读锁或写锁，也不能查询或者修改数据，会被阻塞直到当前事务的写锁释放。

##### 3.2.2 表锁的用法

- 加锁：`lock tables 表名... read/write`
- 解锁：`unlock tables 或者 客户端连接断开`

##### 3.2.3 与MyISAM 存储引擎的关联

​		由于MyISAM 引擎不支持行锁，所有操作都依赖表锁，且默认会在`select`时隐式加读锁、`insert/update/delete`时隐式加写锁并自动释放。

#### 3.3 元数据锁

##### 3.3.1 元数据锁的概念和分类

​		**元数据锁（Metadata Lock，简称 MDL）`MDL` 不锁定数据本身，而是**保护表的元数据（如表结构、字段类型、索引信息等），避免 “表结构修改” 与 “数据读写” 同时进行导致的不一致。

- **共享 MDL 锁（Shared MDL）**：事务执行查询（如`SELECT`）时自动加共享 `MDL` 锁，多个事务可同时加，互不影响。
- **排他 MDL 锁（Exclusive MDL）**：事务执行表结构修改（如`ALTER TABLE`、`DROP COLUMN`）时自动加排他 MDL锁，加锁期间会阻塞所有其他事务的共享 `MDL` 锁请求。

#### 3.4 意向锁

##### 3.4.1 意向锁的概念和分类

​		意向锁是 “中间层锁”，作用是**快速判断表内是否存在行级锁**，避免表锁与行锁的冲突检查需要遍历所有行，提升效率。它仅标识 “意向”，不直接阻止数据读写。

- **意向共享锁（Intention Shared Lock，简称 IS 锁）**：事务计划对表中某些行加读锁（行级 `S` 锁）前，会先对表加 `IS` 锁。
- **意向排他锁（Intention Exclusive Lock，简称 IX 锁）**：事务计划对表中某些行加写锁（行级 `X` 锁）前，会先对表加 `IX` 锁。

##### 3.4.2 意向锁的执行过程

​		**原来**：当执行根据 `id` 更新数据库表中的某一行数据时，会在这一行加上行锁，但是当另一个客户端需要加表锁的时候，会逐行检查是否有行锁的存在。效率极低。

​		**现在**(有了意向锁后)：当加行锁的时候，**同时会给这张表加上意向锁**，当另一个客户端需要加表锁的时候，就会先去检查这个意向锁**是否与自己要获取的锁兼容**，如果兼容，获取锁成功，如果不兼容，获取锁失败。



### 4、行级锁

#### 4.1 行级锁的分类

- 行锁
- 间隙锁
- 临键锁

#### 4.2 行锁

##### 4.2.1 行锁的概念和分类

​		行锁是最基础的行级锁，**直接锁定表中某一行记录**，仅对锁定的行生效，不影响其他行。

- 共享锁（`S` 锁）：事务对某行加 `S` 锁后，自身可读该行，其他事务可加 `S` 锁（共享读），但不能加 `X` 锁（阻塞写）。
- 排他锁（`X` 锁）：事务对某行加 `X` 锁后，自身可读写该行，其他事务既不能加 `S` 锁也不能加 `X` 锁（读写都阻塞）。

##### 4.2.2 行锁的特点

​		仅锁定具体行，粒度最细，并发影响最小，但加锁 / 释放锁开销略高于表锁。行锁必须**基于索引生效**，若查询未使用索引（进行的是全表扫描），InnoDB 会退化为表锁（意向锁 + 表锁）。

#### 4.3 间隙锁

##### 4.3.1 间隙锁的概念

​		间隙锁是**锁定索引记录之间的 “间隙”**，不锁定具体行，仅防止其他事务在间隙中插入新记录，解决 “幻读” 问题（RR 隔离级别下生效）。

##### 4.3.2 什么是间隙

​		指索引值之间的空白区间。例如，表中某索引列存在值`10、20、30`，则间隙包括：`(-∞, 10)`、`(10, 20)`、`(20, 30)`、`(30, +∞)`。

##### 4.3.3 间隙锁的作用

​		阻止在间隙中插入新行。例如，事务 A 对`(10, 20)`加间隙锁后，其他事务无法插入`15`（属于该间隙），但可以修改已存在的`10、20`（如果没被行锁锁定）。

##### 4.3.4 间隙锁的触发场景

​		在 RR 隔离级别下，使用非唯一索引或范围查询（如`WHERE id > 10 AND id < 20`）时，InnoDB 会对匹配不到行的范围加间隙锁。

> 注意：间隙锁之间不冲突（多个事务可同时对同一间隙加间隙锁）。

#### 4.4 临键锁

##### 4.4.1 临键锁的概念

​		临键锁是**行锁与间隙锁的组合**，是 InnoDB 在 RR 隔离级别下默认的行级锁类型，既锁定具体行，也锁定该行前面的间隙。

##### 4.4.2 临键锁的作用

​		临键锁主要用来防止两种冲突

- 其他事务修改锁定的行（行锁的作用）。
- 其他事务在锁定的间隙中插入新行（间隙锁的作用）。

##### 4.4.3 临键锁的触发场景

​		在 RR 隔离级别下，使用**非唯一索引进行等值查询或范围查询**时，若命中行，InnoDB 会对该行加行锁，同时对该行左侧的间隙加间隙锁，**组合为临键锁**。