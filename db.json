{"meta":{"version":1,"warehouse":"6.0.0"},"models":{"Asset":[{"_id":"themes/particlex/source/css/main.css","path":"css/main.css","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/particlex/source/images/loading-d.gif","path":"images/loading-d.gif","modified":1,"renderable":1},{"_id":"themes/particlex/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/crypto.js","path":"js/lib/crypto.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/home.js","path":"js/lib/home.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/math.js","path":"js/lib/math.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/preview.js","path":"js/lib/preview.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/search.js","path":"js/lib/search.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/images/background/01.png","path":"images/background/01.png","modified":1,"renderable":1},{"_id":"themes/particlex/source/images/background/03.png","path":"images/background/03.png","modified":1,"renderable":1},{"_id":"themes/particlex/source/images/background/02.jpeg","path":"images/background/02.jpeg","modified":1,"renderable":1},{"_id":"themes/particlex/source/images/background/04.png","path":"images/background/04.png","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/highlight.js","path":"js/lib/highlight.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/数据库的锁.md","hash":"65601261babb587c9bd79070787fb643f9d3a1d2","modified":1761376238321},{"_id":"source/_posts/测试文章01.md","hash":"060d91095a530cd936be226cdd7d104fcec8298e","modified":1761376238307},{"_id":"source/_posts/测试文章02.md","hash":"17bb99754a1ec0b28b9bafc572600766e674a687","modified":1761376578590},{"_id":"themes/particlex/.npmignore","hash":"5410a1bef9807f666cd92a0d2020f700e67e4096","modified":1761367061811},{"_id":"themes/particlex/LICENSE","hash":"c42335f46096b2ec5509087ab122e5dfd43e2cf4","modified":1761367061811},{"_id":"themes/particlex/README.md","hash":"19b124670bc5c9aa8cff0fc191be1e9a40c841a0","modified":1761367061811},{"_id":"themes/particlex/package.json","hash":"db00b08d699e394ba9c88edcf280792075e35654","modified":1761367061818},{"_id":"themes/particlex/pnpm-lock.yaml","hash":"4c7a4f39b776af75374d0dc6f6619dcbf0e58b97","modified":1761367061818},{"_id":"themes/particlex/layout/archives.ejs","hash":"c6f6ec3e3b0dd33d2966df2cdec537cf002c8b06","modified":1761381096269},{"_id":"themes/particlex/layout/card.ejs","hash":"65e0c46a79c02212982c8a9aef1b16bfc3430429","modified":1761367061812},{"_id":"themes/particlex/layout/categories.ejs","hash":"808f8135d40d15ad30184357e165e03b5c8dd637","modified":1761381096266},{"_id":"themes/particlex/layout/current.ejs","hash":"4e75c06c9d0b1336c69c210567581e7efded5621","modified":1761367061812},{"_id":"themes/particlex/layout/comment.ejs","hash":"267809e50962af7ab6bc5892855f765d754a62e4","modified":1761367061812},{"_id":"themes/particlex/layout/footer.ejs","hash":"ee3b610c5f388642c93b86827f0c779529d4f809","modified":1761362760692},{"_id":"themes/particlex/layout/import.ejs","hash":"7ac80e3afdcd75b109d471399f74261eda70142a","modified":1761363942816},{"_id":"themes/particlex/layout/index.ejs","hash":"7fd8d9eb3c4b1a186a94d6bce3becdecca28534d","modified":1761378399613},{"_id":"themes/particlex/layout/layout.ejs","hash":"bc6f2c3c0a47b755590f3345ef6159d58b29683f","modified":1761367061817},{"_id":"themes/particlex/layout/menu.ejs","hash":"1c78bd05cdfb3ae7a47ed572229a1970335fe8b8","modified":1761367061817},{"_id":"themes/particlex/layout/posts.ejs","hash":"970d0356501f8aede1454e18f4db16627f762767","modified":1761380697392},{"_id":"themes/particlex/layout/post.ejs","hash":"935ec7d8f379d7a35f489d103fd18e5a0664bd72","modified":1761380181615},{"_id":"themes/particlex/source/css/main.css","hash":"9a8576f63642d9067228cb3b3f0a0410a03d4ab6","modified":1761373642738},{"_id":"themes/particlex/layout/tags.ejs","hash":"34ffa925198a4f7bca1f5d422ea7e309e97fe337","modified":1761380181611},{"_id":"themes/particlex/source/js/main.js","hash":"420d9ab7f2e0cb44bdc5335389344ec1e7253db5","modified":1761367062019},{"_id":"themes/particlex/source/js/lib/crypto.js","hash":"3db8692ac636d9f72dc94127216d21f9793e6602","modified":1761367062019},{"_id":"themes/particlex/source/images/loading-d.gif","hash":"9c840c5c3e7b97a184deb390df2f6926d6161708","modified":1761367062018},{"_id":"themes/particlex/source/js/lib/home.js","hash":"5ec113e1d72efaab5eb31addc05eb9dcf26ce1af","modified":1761367062019},{"_id":"themes/particlex/source/js/lib/math.js","hash":"f7716e83ef236818239fcae91defe730d5bfbc6d","modified":1761367062019},{"_id":"themes/particlex/source/js/lib/search.js","hash":"d507facc680300c046f2b967279959541313e1f9","modified":1761367062019},{"_id":"themes/particlex/source/js/lib/preview.js","hash":"d3050c6ed6d52e451cc1810843c5d595eadb8e5a","modified":1761367062019},{"_id":"themes/particlex/source/js/lib/highlight.js","hash":"58fdb5f2d5e409bfc10aac6ccc464c87327806a5","modified":1761367062019},{"_id":"themes/particlex/_config.yml","hash":"3d909614a5fd5f5275dafc433358ae265500c645","modified":1761380902093},{"_id":"themes/particlex/source/images/loading.gif","hash":"1e9f899b335bb6325a36c2580430ce10553439d3","modified":1759829303001},{"_id":"themes/particlex/source/images/avatar.jpg","hash":"cd5b921252d1a4f15e17858f4f816ba768a6acf7","modified":1761367061819},{"_id":"themes/particlex/source/images/background/02.jpeg","hash":"fb0379e3d28922d59ca55822765033ed49bbf87c","modified":1761367061944},{"_id":"themes/particlex/source/images/background/04.png","hash":"f228f5ebb89143a7debac551f21289719260ae77","modified":1761367062018},{"_id":"themes/particlex/source/images/background/03.png","hash":"8ed8cd24312f35f231a6626f10ab1fc52cde2079","modified":1761367061983},{"_id":"themes/particlex/source/images/background/01.png","hash":"9045362ac3960c29f11c40bda42cf6406ec2cdcc","modified":1761367061941},{"_id":"public/posts/a177b36e.html","hash":"0595a5ad610114eeadeed2c4fca7d4bc52e829cc","modified":1761381279398},{"_id":"public/posts/cc7c02e8.html","hash":"92c3667ad00306c011176a178a152c2ebe2dc41b","modified":1761381279398},{"_id":"public/posts/55755352.html","hash":"cb3dd19011a87382fc16cf0864ea9b923e8e46c2","modified":1761381279398},{"_id":"public/archives/index.html","hash":"961b130ff0902b456b771e077bdae1e8073cc10f","modified":1761381279398},{"_id":"public/archives/2025/index.html","hash":"961b130ff0902b456b771e077bdae1e8073cc10f","modified":1761381279398},{"_id":"public/archives/2025/10/index.html","hash":"961b130ff0902b456b771e077bdae1e8073cc10f","modified":1761381279398},{"_id":"public/index.html","hash":"71c8178236a68e8ebd34a085b3eda2e9451ead4b","modified":1761381279398},{"_id":"public/tags/测试/index.html","hash":"b439ff38865b4e6307859d97c99ddaa8cf62f596","modified":1761381279398},{"_id":"public/tags/MySQL/index.html","hash":"ddf1334d37a3f9a12d661fc469969de30a20da41","modified":1761381279398},{"_id":"public/images/loading-d.gif","hash":"9c840c5c3e7b97a184deb390df2f6926d6161708","modified":1761381279398},{"_id":"public/js/main.js","hash":"a9cb52bac89783c3957c77cbb4ffc8fbb93a92a1","modified":1761381279398},{"_id":"public/css/main.css","hash":"b6882f80a798472de7090c3b7f65f876a43c56c6","modified":1761381279398},{"_id":"public/js/lib/crypto.js","hash":"bc4a0c41cf5b61faa204a2a820fc042b563142cf","modified":1761381279398},{"_id":"public/js/lib/math.js","hash":"24c182cd3f5dd1c0f0192ca4cc143de71e076d2a","modified":1761381279398},{"_id":"public/js/lib/home.js","hash":"c2bf22772fd052cff88a9b5f547a30a6eb97e545","modified":1761381279398},{"_id":"public/js/lib/preview.js","hash":"595cfc3aff107b8dd0fdda214995c6f1bb5be39a","modified":1761381279398},{"_id":"public/js/lib/search.js","hash":"b631b87fa126a9a4a81b60b1a0516f765879963e","modified":1761381279398},{"_id":"public/js/lib/highlight.js","hash":"a9ee0fd40904e2e50ab5ecab4c718a49c095836f","modified":1761381279398},{"_id":"public/images/loading.gif","hash":"1e9f899b335bb6325a36c2580430ce10553439d3","modified":1761381279398},{"_id":"public/images/avatar.jpg","hash":"cd5b921252d1a4f15e17858f4f816ba768a6acf7","modified":1761381279398},{"_id":"public/images/background/02.jpeg","hash":"fb0379e3d28922d59ca55822765033ed49bbf87c","modified":1761381279398},{"_id":"public/images/background/04.png","hash":"f228f5ebb89143a7debac551f21289719260ae77","modified":1761381279398},{"_id":"public/images/background/03.png","hash":"8ed8cd24312f35f231a6626f10ab1fc52cde2079","modified":1761381279398},{"_id":"public/images/background/01.png","hash":"9045362ac3960c29f11c40bda42cf6406ec2cdcc","modified":1761381279398}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"测试文章01","description":"文章缩略，支持 `Markdown` **文档格式**\n","pinned":0,"lang":"zh","abbrlink":"55755352","wordCount":49,"charCount":497,"imgCount":0,"vidCount":0,"wsCount":1,"cbCount":1,"readTime":"约32秒","date":"2025-10-18T13:05:32.000Z","_content":"\n# 算法\n\n## 一、平方剩余和\n\n> 主要用于快速的判断两个数的乘积是否为完全平方数。\n> 如果平方剩余和相等，则两个数的乘积是完全平方数。\n\n```java\nimport java.util.HashSet;\nclass Solution {\n    // 平方剩余和 的预处理\n    static int[] core = new int[1010];\n    static int limit = 1000;\n    static {\n        // 求 1~1000 的所有数的平方剩余和\n        for(int i = 1;i <= limit;i++) {\n            if(core[i] == 0) {\n                // 说明没有被计算过\n                for(int j = 1;i*j*j <= limit;j++) {\n                    core[i*j*j] = i;\n                }\n            }\n        }\n    }\n\n    // 验证，平方剩余和 时，两个数的乘积为完全平方数\n    public static void main(String[] args) {\n        for(int i = 1;i <= 1000;i++) {\n            for(int j = i + 1;j <= 1000;j++) {\n                if(core[i] == core[j]) {\n                    System.out.println((i * j) + \" == \" + (String.format(\"%.0f\",Math.sqrt(i * j))) + \"^2\");\n                }\n            }\n        }\n    }\n}\n```","source":"_posts/测试文章01.md","raw":"---\ntitle: 测试文章01\ntags: \n  - 测试\ndescription: |\n  文章缩略，支持 `Markdown` **文档格式**\npinned: 0\nlang: zh\nabbrlink: '55755352'\nwordCount: 49\ncharCount: 497\nimgCount: 0\nvidCount: 0\nwsCount: 1\ncbCount: 1\nreadTime: 约32秒\ndate: 2025-10-18 21:05:32\n---\n\n# 算法\n\n## 一、平方剩余和\n\n> 主要用于快速的判断两个数的乘积是否为完全平方数。\n> 如果平方剩余和相等，则两个数的乘积是完全平方数。\n\n```java\nimport java.util.HashSet;\nclass Solution {\n    // 平方剩余和 的预处理\n    static int[] core = new int[1010];\n    static int limit = 1000;\n    static {\n        // 求 1~1000 的所有数的平方剩余和\n        for(int i = 1;i <= limit;i++) {\n            if(core[i] == 0) {\n                // 说明没有被计算过\n                for(int j = 1;i*j*j <= limit;j++) {\n                    core[i*j*j] = i;\n                }\n            }\n        }\n    }\n\n    // 验证，平方剩余和 时，两个数的乘积为完全平方数\n    public static void main(String[] args) {\n        for(int i = 1;i <= 1000;i++) {\n            for(int j = i + 1;j <= 1000;j++) {\n                if(core[i] == core[j]) {\n                    System.out.println((i * j) + \" == \" + (String.format(\"%.0f\",Math.sqrt(i * j))) + \"^2\");\n                }\n            }\n        }\n    }\n}\n```","slug":"测试文章01","published":1,"updated":"2025-10-25T07:10:38.307Z","comments":1,"layout":"post","photos":[],"_id":"cuide8VRWDVwkZfPD5BVkxwER","content":"<h1 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h1><h2 id=\"一、平方剩余和\"><a href=\"#一、平方剩余和\" class=\"headerlink\" title=\"一、平方剩余和\"></a>一、平方剩余和</h2><blockquote>\n<p>主要用于快速的判断两个数的乘积是否为完全平方数。<br>如果平方剩余和相等，则两个数的乘积是完全平方数。</p>\n</blockquote>\n<pre><code class=\"language-java\">import java.util.HashSet;\nclass Solution {\n    // 平方剩余和 的预处理\n    static int[] core = new int[1010];\n    static int limit = 1000;\n    static {\n        // 求 1~1000 的所有数的平方剩余和\n        for(int i = 1;i &lt;= limit;i++) {\n            if(core[i] == 0) {\n                // 说明没有被计算过\n                for(int j = 1;i*j*j &lt;= limit;j++) {\n                    core[i*j*j] = i;\n                }\n            }\n        }\n    }\n\n    // 验证，平方剩余和 时，两个数的乘积为完全平方数\n    public static void main(String[] args) {\n        for(int i = 1;i &lt;= 1000;i++) {\n            for(int j = i + 1;j &lt;= 1000;j++) {\n                if(core[i] == core[j]) {\n                    System.out.println((i * j) + &quot; == &quot; + (String.format(&quot;%.0f&quot;,Math.sqrt(i * j))) + &quot;^2&quot;);\n                }\n            }\n        }\n    }\n}\n</code></pre>\n","excerpt":"","more":"<h1 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h1><h2 id=\"一、平方剩余和\"><a href=\"#一、平方剩余和\" class=\"headerlink\" title=\"一、平方剩余和\"></a>一、平方剩余和</h2><blockquote>\n<p>主要用于快速的判断两个数的乘积是否为完全平方数。<br>如果平方剩余和相等，则两个数的乘积是完全平方数。</p>\n</blockquote>\n<pre><code class=\"language-java\">import java.util.HashSet;\nclass Solution {\n    // 平方剩余和 的预处理\n    static int[] core = new int[1010];\n    static int limit = 1000;\n    static {\n        // 求 1~1000 的所有数的平方剩余和\n        for(int i = 1;i &lt;= limit;i++) {\n            if(core[i] == 0) {\n                // 说明没有被计算过\n                for(int j = 1;i*j*j &lt;= limit;j++) {\n                    core[i*j*j] = i;\n                }\n            }\n        }\n    }\n\n    // 验证，平方剩余和 时，两个数的乘积为完全平方数\n    public static void main(String[] args) {\n        for(int i = 1;i &lt;= 1000;i++) {\n            for(int j = i + 1;j &lt;= 1000;j++) {\n                if(core[i] == core[j]) {\n                    System.out.println((i * j) + &quot; == &quot; + (String.format(&quot;%.0f&quot;,Math.sqrt(i * j))) + &quot;^2&quot;);\n                }\n            }\n        }\n    }\n}\n</code></pre>\n"},{"title":"MySQL 的锁","description":"全局锁、表级锁、行级锁、意向锁、元数据锁、间隙锁、临键锁\n","pinned":0,"lang":"zh","wordCount":107,"charCount":2507,"imgCount":0,"vidCount":0,"wsCount":0,"cbCount":0,"readTime":"约46秒","abbrlink":"a177b36e","date":"2025-10-25T03:52:23.000Z","_content":"### 1、锁的分类\n\n- 全局锁：锁住整个数据库，也就是锁住数据库中所有的表。\n- 表级锁：锁住整张表。\n- 行级锁：锁住单独的一行数据。\n\n\n\n### 2、全局锁\n\n#### 2.1 全局锁的分类和作用\n\n​\t\tMySQL全局锁是针对整个数据库的锁。最常用的全局锁是读锁和写锁。\n\n- 读锁（共享锁）：它阻止其他用户更新数据，但允许他们读取数据。\n- 写锁（排他锁）：它阻止其他用户读取和更新数据。\n\n#### 2.2 全局锁的用法\n\n- `FLUSH TABLES WITH READ/WRITE LOCK(FTWRL)`：用来锁住整个数据库\n- `UNLOCK TABLES` ：进行解锁\n\n#### 2.3 全局锁的使用场景\n\n- **备份全库**：使用全局锁可以确保在备份过程中，数据库的所有表都保持一致的状态。\n- **整体数据迁移**：将整个数据库从一个服务器迁移到另一个服务器，需要阻止任何写操作，以确保所有的数据都被正确地迁移到新的服务器。\n- **全库只读**：在某些情况下，可能希望将整个数据库设置为只读模式。\n\n\n\n### 3、表级锁\n\n#### 3.1 表级锁的分类\n\n- 表锁\n\n- 元数据锁\n\n- 意向锁\n\n  > ​\t\t这里可能会疑惑为什么有表锁、意向锁、元数据锁会**处于同一层级**，不应该是表锁包含元数据锁和意向锁吗，这里其实陷入了一个误区，其实，表锁、意向锁、元数据锁 都属于 表**级**锁，而表**级**锁当然包括了表锁，同时，元数据锁和意向锁也都属于表**级**锁，同样，行锁和行**级**锁也是同样的道理，后面就不赘述了。\n\n#### 3.2 表锁\n\n##### 3.2.1 表锁的概念和分类\n\n​\t\t表锁是**最基础的表级锁**，直接对整个表进行锁定，分为**读锁和写锁**，二者遵循 “读共享、写独占” 原则。\n\n- **读锁（Shared Lock，简称 S 锁）**：事务加读锁后，自身和其他事务只能读表，不能修改表数据。多个事务可同时对同一表加读锁，互不阻塞。\n- **写锁（Exclusive Lock，简称 X 锁）**：事务加写锁后，只有自身能读写表数据，其他事务无法加读锁或写锁，也不能查询或者修改数据，会被阻塞直到当前事务的写锁释放。\n\n##### 3.2.2 表锁的用法\n\n- 加锁：`lock tables 表名... read/write`\n- 解锁：`unlock tables 或者 客户端连接断开`\n\n##### 3.2.3 与MyISAM 存储引擎的关联\n\n​\t\t由于MyISAM 引擎不支持行锁，所有操作都依赖表锁，且默认会在`select`时隐式加读锁、`insert/update/delete`时隐式加写锁并自动释放。\n\n#### 3.3 元数据锁\n\n##### 3.3.1 元数据锁的概念和分类\n\n​\t\t**元数据锁（Metadata Lock，简称 MDL）`MDL` 不锁定数据本身，而是**保护表的元数据（如表结构、字段类型、索引信息等），避免 “表结构修改” 与 “数据读写” 同时进行导致的不一致。\n\n- **共享 MDL 锁（Shared MDL）**：事务执行查询（如`SELECT`）时自动加共享 `MDL` 锁，多个事务可同时加，互不影响。\n- **排他 MDL 锁（Exclusive MDL）**：事务执行表结构修改（如`ALTER TABLE`、`DROP COLUMN`）时自动加排他 MDL锁，加锁期间会阻塞所有其他事务的共享 `MDL` 锁请求。\n\n#### 3.4 意向锁\n\n##### 3.4.1 意向锁的概念和分类\n\n​\t\t意向锁是 “中间层锁”，作用是**快速判断表内是否存在行级锁**，避免表锁与行锁的冲突检查需要遍历所有行，提升效率。它仅标识 “意向”，不直接阻止数据读写。\n\n- **意向共享锁（Intention Shared Lock，简称 IS 锁）**：事务计划对表中某些行加读锁（行级 `S` 锁）前，会先对表加 `IS` 锁。\n- **意向排他锁（Intention Exclusive Lock，简称 IX 锁）**：事务计划对表中某些行加写锁（行级 `X` 锁）前，会先对表加 `IX` 锁。\n\n##### 3.4.2 意向锁的执行过程\n\n​\t\t**原来**：当执行根据 `id` 更新数据库表中的某一行数据时，会在这一行加上行锁，但是当另一个客户端需要加表锁的时候，会逐行检查是否有行锁的存在。效率极低。\n\n​\t\t**现在**(有了意向锁后)：当加行锁的时候，**同时会给这张表加上意向锁**，当另一个客户端需要加表锁的时候，就会先去检查这个意向锁**是否与自己要获取的锁兼容**，如果兼容，获取锁成功，如果不兼容，获取锁失败。\n\n\n\n### 4、行级锁\n\n#### 4.1 行级锁的分类\n\n- 行锁\n- 间隙锁\n- 临键锁\n\n#### 4.2 行锁\n\n##### 4.2.1 行锁的概念和分类\n\n​\t\t行锁是最基础的行级锁，**直接锁定表中某一行记录**，仅对锁定的行生效，不影响其他行。\n\n- 共享锁（`S` 锁）：事务对某行加 `S` 锁后，自身可读该行，其他事务可加 `S` 锁（共享读），但不能加 `X` 锁（阻塞写）。\n- 排他锁（`X` 锁）：事务对某行加 `X` 锁后，自身可读写该行，其他事务既不能加 `S` 锁也不能加 `X` 锁（读写都阻塞）。\n\n##### 4.2.2 行锁的特点\n\n​\t\t仅锁定具体行，粒度最细，并发影响最小，但加锁 / 释放锁开销略高于表锁。行锁必须**基于索引生效**，若查询未使用索引（进行的是全表扫描），InnoDB 会退化为表锁（意向锁 + 表锁）。\n\n#### 4.3 间隙锁\n\n##### 4.3.1 间隙锁的概念\n\n​\t\t间隙锁是**锁定索引记录之间的 “间隙”**，不锁定具体行，仅防止其他事务在间隙中插入新记录，解决 “幻读” 问题（RR 隔离级别下生效）。\n\n##### 4.3.2 什么是间隙\n\n​\t\t指索引值之间的空白区间。例如，表中某索引列存在值`10、20、30`，则间隙包括：`(-∞, 10)`、`(10, 20)`、`(20, 30)`、`(30, +∞)`。\n\n##### 4.3.3 间隙锁的作用\n\n​\t\t阻止在间隙中插入新行。例如，事务 A 对`(10, 20)`加间隙锁后，其他事务无法插入`15`（属于该间隙），但可以修改已存在的`10、20`（如果没被行锁锁定）。\n\n##### 4.3.4 间隙锁的触发场景\n\n​\t\t在 RR 隔离级别下，使用非唯一索引或范围查询（如`WHERE id > 10 AND id < 20`）时，InnoDB 会对匹配不到行的范围加间隙锁。\n\n> 注意：间隙锁之间不冲突（多个事务可同时对同一间隙加间隙锁）。\n\n#### 4.4 临键锁\n\n##### 4.4.1 临键锁的概念\n\n​\t\t临键锁是**行锁与间隙锁的组合**，是 InnoDB 在 RR 隔离级别下默认的行级锁类型，既锁定具体行，也锁定该行前面的间隙。\n\n##### 4.4.2 临键锁的作用\n\n​\t\t临键锁主要用来防止两种冲突\n\n- 其他事务修改锁定的行（行锁的作用）。\n- 其他事务在锁定的间隙中插入新行（间隙锁的作用）。\n\n##### 4.4.3 临键锁的触发场景\n\n​\t\t在 RR 隔离级别下，使用**非唯一索引进行等值查询或范围查询**时，若命中行，InnoDB 会对该行加行锁，同时对该行左侧的间隙加间隙锁，**组合为临键锁**。","source":"_posts/数据库的锁.md","raw":"---\ntitle: MySQL 的锁\ndescription: |\n  全局锁、表级锁、行级锁、意向锁、元数据锁、间隙锁、临键锁\npinned: 0\nlang: zh\ntags: \n  - MySQL\nwordCount: 107\ncharCount: 2507\nimgCount: 0\nvidCount: 0\nwsCount: 0\ncbCount: 0\nreadTime: 约46秒\nabbrlink: a177b36e\ndate: 2025-10-25 11:52:23\n---\n### 1、锁的分类\n\n- 全局锁：锁住整个数据库，也就是锁住数据库中所有的表。\n- 表级锁：锁住整张表。\n- 行级锁：锁住单独的一行数据。\n\n\n\n### 2、全局锁\n\n#### 2.1 全局锁的分类和作用\n\n​\t\tMySQL全局锁是针对整个数据库的锁。最常用的全局锁是读锁和写锁。\n\n- 读锁（共享锁）：它阻止其他用户更新数据，但允许他们读取数据。\n- 写锁（排他锁）：它阻止其他用户读取和更新数据。\n\n#### 2.2 全局锁的用法\n\n- `FLUSH TABLES WITH READ/WRITE LOCK(FTWRL)`：用来锁住整个数据库\n- `UNLOCK TABLES` ：进行解锁\n\n#### 2.3 全局锁的使用场景\n\n- **备份全库**：使用全局锁可以确保在备份过程中，数据库的所有表都保持一致的状态。\n- **整体数据迁移**：将整个数据库从一个服务器迁移到另一个服务器，需要阻止任何写操作，以确保所有的数据都被正确地迁移到新的服务器。\n- **全库只读**：在某些情况下，可能希望将整个数据库设置为只读模式。\n\n\n\n### 3、表级锁\n\n#### 3.1 表级锁的分类\n\n- 表锁\n\n- 元数据锁\n\n- 意向锁\n\n  > ​\t\t这里可能会疑惑为什么有表锁、意向锁、元数据锁会**处于同一层级**，不应该是表锁包含元数据锁和意向锁吗，这里其实陷入了一个误区，其实，表锁、意向锁、元数据锁 都属于 表**级**锁，而表**级**锁当然包括了表锁，同时，元数据锁和意向锁也都属于表**级**锁，同样，行锁和行**级**锁也是同样的道理，后面就不赘述了。\n\n#### 3.2 表锁\n\n##### 3.2.1 表锁的概念和分类\n\n​\t\t表锁是**最基础的表级锁**，直接对整个表进行锁定，分为**读锁和写锁**，二者遵循 “读共享、写独占” 原则。\n\n- **读锁（Shared Lock，简称 S 锁）**：事务加读锁后，自身和其他事务只能读表，不能修改表数据。多个事务可同时对同一表加读锁，互不阻塞。\n- **写锁（Exclusive Lock，简称 X 锁）**：事务加写锁后，只有自身能读写表数据，其他事务无法加读锁或写锁，也不能查询或者修改数据，会被阻塞直到当前事务的写锁释放。\n\n##### 3.2.2 表锁的用法\n\n- 加锁：`lock tables 表名... read/write`\n- 解锁：`unlock tables 或者 客户端连接断开`\n\n##### 3.2.3 与MyISAM 存储引擎的关联\n\n​\t\t由于MyISAM 引擎不支持行锁，所有操作都依赖表锁，且默认会在`select`时隐式加读锁、`insert/update/delete`时隐式加写锁并自动释放。\n\n#### 3.3 元数据锁\n\n##### 3.3.1 元数据锁的概念和分类\n\n​\t\t**元数据锁（Metadata Lock，简称 MDL）`MDL` 不锁定数据本身，而是**保护表的元数据（如表结构、字段类型、索引信息等），避免 “表结构修改” 与 “数据读写” 同时进行导致的不一致。\n\n- **共享 MDL 锁（Shared MDL）**：事务执行查询（如`SELECT`）时自动加共享 `MDL` 锁，多个事务可同时加，互不影响。\n- **排他 MDL 锁（Exclusive MDL）**：事务执行表结构修改（如`ALTER TABLE`、`DROP COLUMN`）时自动加排他 MDL锁，加锁期间会阻塞所有其他事务的共享 `MDL` 锁请求。\n\n#### 3.4 意向锁\n\n##### 3.4.1 意向锁的概念和分类\n\n​\t\t意向锁是 “中间层锁”，作用是**快速判断表内是否存在行级锁**，避免表锁与行锁的冲突检查需要遍历所有行，提升效率。它仅标识 “意向”，不直接阻止数据读写。\n\n- **意向共享锁（Intention Shared Lock，简称 IS 锁）**：事务计划对表中某些行加读锁（行级 `S` 锁）前，会先对表加 `IS` 锁。\n- **意向排他锁（Intention Exclusive Lock，简称 IX 锁）**：事务计划对表中某些行加写锁（行级 `X` 锁）前，会先对表加 `IX` 锁。\n\n##### 3.4.2 意向锁的执行过程\n\n​\t\t**原来**：当执行根据 `id` 更新数据库表中的某一行数据时，会在这一行加上行锁，但是当另一个客户端需要加表锁的时候，会逐行检查是否有行锁的存在。效率极低。\n\n​\t\t**现在**(有了意向锁后)：当加行锁的时候，**同时会给这张表加上意向锁**，当另一个客户端需要加表锁的时候，就会先去检查这个意向锁**是否与自己要获取的锁兼容**，如果兼容，获取锁成功，如果不兼容，获取锁失败。\n\n\n\n### 4、行级锁\n\n#### 4.1 行级锁的分类\n\n- 行锁\n- 间隙锁\n- 临键锁\n\n#### 4.2 行锁\n\n##### 4.2.1 行锁的概念和分类\n\n​\t\t行锁是最基础的行级锁，**直接锁定表中某一行记录**，仅对锁定的行生效，不影响其他行。\n\n- 共享锁（`S` 锁）：事务对某行加 `S` 锁后，自身可读该行，其他事务可加 `S` 锁（共享读），但不能加 `X` 锁（阻塞写）。\n- 排他锁（`X` 锁）：事务对某行加 `X` 锁后，自身可读写该行，其他事务既不能加 `S` 锁也不能加 `X` 锁（读写都阻塞）。\n\n##### 4.2.2 行锁的特点\n\n​\t\t仅锁定具体行，粒度最细，并发影响最小，但加锁 / 释放锁开销略高于表锁。行锁必须**基于索引生效**，若查询未使用索引（进行的是全表扫描），InnoDB 会退化为表锁（意向锁 + 表锁）。\n\n#### 4.3 间隙锁\n\n##### 4.3.1 间隙锁的概念\n\n​\t\t间隙锁是**锁定索引记录之间的 “间隙”**，不锁定具体行，仅防止其他事务在间隙中插入新记录，解决 “幻读” 问题（RR 隔离级别下生效）。\n\n##### 4.3.2 什么是间隙\n\n​\t\t指索引值之间的空白区间。例如，表中某索引列存在值`10、20、30`，则间隙包括：`(-∞, 10)`、`(10, 20)`、`(20, 30)`、`(30, +∞)`。\n\n##### 4.3.3 间隙锁的作用\n\n​\t\t阻止在间隙中插入新行。例如，事务 A 对`(10, 20)`加间隙锁后，其他事务无法插入`15`（属于该间隙），但可以修改已存在的`10、20`（如果没被行锁锁定）。\n\n##### 4.3.4 间隙锁的触发场景\n\n​\t\t在 RR 隔离级别下，使用非唯一索引或范围查询（如`WHERE id > 10 AND id < 20`）时，InnoDB 会对匹配不到行的范围加间隙锁。\n\n> 注意：间隙锁之间不冲突（多个事务可同时对同一间隙加间隙锁）。\n\n#### 4.4 临键锁\n\n##### 4.4.1 临键锁的概念\n\n​\t\t临键锁是**行锁与间隙锁的组合**，是 InnoDB 在 RR 隔离级别下默认的行级锁类型，既锁定具体行，也锁定该行前面的间隙。\n\n##### 4.4.2 临键锁的作用\n\n​\t\t临键锁主要用来防止两种冲突\n\n- 其他事务修改锁定的行（行锁的作用）。\n- 其他事务在锁定的间隙中插入新行（间隙锁的作用）。\n\n##### 4.4.3 临键锁的触发场景\n\n​\t\t在 RR 隔离级别下，使用**非唯一索引进行等值查询或范围查询**时，若命中行，InnoDB 会对该行加行锁，同时对该行左侧的间隙加间隙锁，**组合为临键锁**。","slug":"数据库的锁","published":1,"updated":"2025-10-25T07:10:38.321Z","comments":1,"layout":"post","photos":[],"_id":"cuid-HNBgA_Cgt9UDV2HlI-uC","content":"<h3 id=\"1、锁的分类\"><a href=\"#1、锁的分类\" class=\"headerlink\" title=\"1、锁的分类\"></a>1、锁的分类</h3><ul>\n<li>全局锁：锁住整个数据库，也就是锁住数据库中所有的表。</li>\n<li>表级锁：锁住整张表。</li>\n<li>行级锁：锁住单独的一行数据。</li>\n</ul>\n<h3 id=\"2、全局锁\"><a href=\"#2、全局锁\" class=\"headerlink\" title=\"2、全局锁\"></a>2、全局锁</h3><h4 id=\"2-1-全局锁的分类和作用\"><a href=\"#2-1-全局锁的分类和作用\" class=\"headerlink\" title=\"2.1 全局锁的分类和作用\"></a>2.1 全局锁的分类和作用</h4><p>​\t\tMySQL全局锁是针对整个数据库的锁。最常用的全局锁是读锁和写锁。</p>\n<ul>\n<li>读锁（共享锁）：它阻止其他用户更新数据，但允许他们读取数据。</li>\n<li>写锁（排他锁）：它阻止其他用户读取和更新数据。</li>\n</ul>\n<h4 id=\"2-2-全局锁的用法\"><a href=\"#2-2-全局锁的用法\" class=\"headerlink\" title=\"2.2 全局锁的用法\"></a>2.2 全局锁的用法</h4><ul>\n<li><code>FLUSH TABLES WITH READ/WRITE LOCK(FTWRL)</code>：用来锁住整个数据库</li>\n<li><code>UNLOCK TABLES</code> ：进行解锁</li>\n</ul>\n<h4 id=\"2-3-全局锁的使用场景\"><a href=\"#2-3-全局锁的使用场景\" class=\"headerlink\" title=\"2.3 全局锁的使用场景\"></a>2.3 全局锁的使用场景</h4><ul>\n<li><strong>备份全库</strong>：使用全局锁可以确保在备份过程中，数据库的所有表都保持一致的状态。</li>\n<li><strong>整体数据迁移</strong>：将整个数据库从一个服务器迁移到另一个服务器，需要阻止任何写操作，以确保所有的数据都被正确地迁移到新的服务器。</li>\n<li><strong>全库只读</strong>：在某些情况下，可能希望将整个数据库设置为只读模式。</li>\n</ul>\n<h3 id=\"3、表级锁\"><a href=\"#3、表级锁\" class=\"headerlink\" title=\"3、表级锁\"></a>3、表级锁</h3><h4 id=\"3-1-表级锁的分类\"><a href=\"#3-1-表级锁的分类\" class=\"headerlink\" title=\"3.1 表级锁的分类\"></a>3.1 表级锁的分类</h4><ul>\n<li><p>表锁</p>\n</li>\n<li><p>元数据锁</p>\n</li>\n<li><p>意向锁</p>\n<blockquote>\n<p>​        这里可能会疑惑为什么有表锁、意向锁、元数据锁会<strong>处于同一层级</strong>，不应该是表锁包含元数据锁和意向锁吗，这里其实陷入了一个误区，其实，表锁、意向锁、元数据锁 都属于 表<strong>级</strong>锁，而表<strong>级</strong>锁当然包括了表锁，同时，元数据锁和意向锁也都属于表<strong>级</strong>锁，同样，行锁和行<strong>级</strong>锁也是同样的道理，后面就不赘述了。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"3-2-表锁\"><a href=\"#3-2-表锁\" class=\"headerlink\" title=\"3.2 表锁\"></a>3.2 表锁</h4><h5 id=\"3-2-1-表锁的概念和分类\"><a href=\"#3-2-1-表锁的概念和分类\" class=\"headerlink\" title=\"3.2.1 表锁的概念和分类\"></a>3.2.1 表锁的概念和分类</h5><p>​\t\t表锁是<strong>最基础的表级锁</strong>，直接对整个表进行锁定，分为<strong>读锁和写锁</strong>，二者遵循 “读共享、写独占” 原则。</p>\n<ul>\n<li><strong>读锁（Shared Lock，简称 S 锁）</strong>：事务加读锁后，自身和其他事务只能读表，不能修改表数据。多个事务可同时对同一表加读锁，互不阻塞。</li>\n<li><strong>写锁（Exclusive Lock，简称 X 锁）</strong>：事务加写锁后，只有自身能读写表数据，其他事务无法加读锁或写锁，也不能查询或者修改数据，会被阻塞直到当前事务的写锁释放。</li>\n</ul>\n<h5 id=\"3-2-2-表锁的用法\"><a href=\"#3-2-2-表锁的用法\" class=\"headerlink\" title=\"3.2.2 表锁的用法\"></a>3.2.2 表锁的用法</h5><ul>\n<li>加锁：<code>lock tables 表名... read/write</code></li>\n<li>解锁：<code>unlock tables 或者 客户端连接断开</code></li>\n</ul>\n<h5 id=\"3-2-3-与MyISAM-存储引擎的关联\"><a href=\"#3-2-3-与MyISAM-存储引擎的关联\" class=\"headerlink\" title=\"3.2.3 与MyISAM 存储引擎的关联\"></a>3.2.3 与MyISAM 存储引擎的关联</h5><p>​\t\t由于MyISAM 引擎不支持行锁，所有操作都依赖表锁，且默认会在<code>select</code>时隐式加读锁、<code>insert/update/delete</code>时隐式加写锁并自动释放。</p>\n<h4 id=\"3-3-元数据锁\"><a href=\"#3-3-元数据锁\" class=\"headerlink\" title=\"3.3 元数据锁\"></a>3.3 元数据锁</h4><h5 id=\"3-3-1-元数据锁的概念和分类\"><a href=\"#3-3-1-元数据锁的概念和分类\" class=\"headerlink\" title=\"3.3.1 元数据锁的概念和分类\"></a>3.3.1 元数据锁的概念和分类</h5><p>​\t\t<strong>元数据锁（Metadata Lock，简称 MDL）<code>MDL</code> 不锁定数据本身，而是</strong>保护表的元数据（如表结构、字段类型、索引信息等），避免 “表结构修改” 与 “数据读写” 同时进行导致的不一致。</p>\n<ul>\n<li><strong>共享 MDL 锁（Shared MDL）</strong>：事务执行查询（如<code>SELECT</code>）时自动加共享 <code>MDL</code> 锁，多个事务可同时加，互不影响。</li>\n<li><strong>排他 MDL 锁（Exclusive MDL）</strong>：事务执行表结构修改（如<code>ALTER TABLE</code>、<code>DROP COLUMN</code>）时自动加排他 MDL锁，加锁期间会阻塞所有其他事务的共享 <code>MDL</code> 锁请求。</li>\n</ul>\n<h4 id=\"3-4-意向锁\"><a href=\"#3-4-意向锁\" class=\"headerlink\" title=\"3.4 意向锁\"></a>3.4 意向锁</h4><h5 id=\"3-4-1-意向锁的概念和分类\"><a href=\"#3-4-1-意向锁的概念和分类\" class=\"headerlink\" title=\"3.4.1 意向锁的概念和分类\"></a>3.4.1 意向锁的概念和分类</h5><p>​\t\t意向锁是 “中间层锁”，作用是<strong>快速判断表内是否存在行级锁</strong>，避免表锁与行锁的冲突检查需要遍历所有行，提升效率。它仅标识 “意向”，不直接阻止数据读写。</p>\n<ul>\n<li><strong>意向共享锁（Intention Shared Lock，简称 IS 锁）</strong>：事务计划对表中某些行加读锁（行级 <code>S</code> 锁）前，会先对表加 <code>IS</code> 锁。</li>\n<li><strong>意向排他锁（Intention Exclusive Lock，简称 IX 锁）</strong>：事务计划对表中某些行加写锁（行级 <code>X</code> 锁）前，会先对表加 <code>IX</code> 锁。</li>\n</ul>\n<h5 id=\"3-4-2-意向锁的执行过程\"><a href=\"#3-4-2-意向锁的执行过程\" class=\"headerlink\" title=\"3.4.2 意向锁的执行过程\"></a>3.4.2 意向锁的执行过程</h5><p>​\t\t<strong>原来</strong>：当执行根据 <code>id</code> 更新数据库表中的某一行数据时，会在这一行加上行锁，但是当另一个客户端需要加表锁的时候，会逐行检查是否有行锁的存在。效率极低。</p>\n<p>​\t\t<strong>现在</strong>(有了意向锁后)：当加行锁的时候，<strong>同时会给这张表加上意向锁</strong>，当另一个客户端需要加表锁的时候，就会先去检查这个意向锁<strong>是否与自己要获取的锁兼容</strong>，如果兼容，获取锁成功，如果不兼容，获取锁失败。</p>\n<h3 id=\"4、行级锁\"><a href=\"#4、行级锁\" class=\"headerlink\" title=\"4、行级锁\"></a>4、行级锁</h3><h4 id=\"4-1-行级锁的分类\"><a href=\"#4-1-行级锁的分类\" class=\"headerlink\" title=\"4.1 行级锁的分类\"></a>4.1 行级锁的分类</h4><ul>\n<li>行锁</li>\n<li>间隙锁</li>\n<li>临键锁</li>\n</ul>\n<h4 id=\"4-2-行锁\"><a href=\"#4-2-行锁\" class=\"headerlink\" title=\"4.2 行锁\"></a>4.2 行锁</h4><h5 id=\"4-2-1-行锁的概念和分类\"><a href=\"#4-2-1-行锁的概念和分类\" class=\"headerlink\" title=\"4.2.1 行锁的概念和分类\"></a>4.2.1 行锁的概念和分类</h5><p>​\t\t行锁是最基础的行级锁，<strong>直接锁定表中某一行记录</strong>，仅对锁定的行生效，不影响其他行。</p>\n<ul>\n<li>共享锁（<code>S</code> 锁）：事务对某行加 <code>S</code> 锁后，自身可读该行，其他事务可加 <code>S</code> 锁（共享读），但不能加 <code>X</code> 锁（阻塞写）。</li>\n<li>排他锁（<code>X</code> 锁）：事务对某行加 <code>X</code> 锁后，自身可读写该行，其他事务既不能加 <code>S</code> 锁也不能加 <code>X</code> 锁（读写都阻塞）。</li>\n</ul>\n<h5 id=\"4-2-2-行锁的特点\"><a href=\"#4-2-2-行锁的特点\" class=\"headerlink\" title=\"4.2.2 行锁的特点\"></a>4.2.2 行锁的特点</h5><p>​\t\t仅锁定具体行，粒度最细，并发影响最小，但加锁 &#x2F; 释放锁开销略高于表锁。行锁必须<strong>基于索引生效</strong>，若查询未使用索引（进行的是全表扫描），InnoDB 会退化为表锁（意向锁 + 表锁）。</p>\n<h4 id=\"4-3-间隙锁\"><a href=\"#4-3-间隙锁\" class=\"headerlink\" title=\"4.3 间隙锁\"></a>4.3 间隙锁</h4><h5 id=\"4-3-1-间隙锁的概念\"><a href=\"#4-3-1-间隙锁的概念\" class=\"headerlink\" title=\"4.3.1 间隙锁的概念\"></a>4.3.1 间隙锁的概念</h5><p>​\t\t间隙锁是<strong>锁定索引记录之间的 “间隙”</strong>，不锁定具体行，仅防止其他事务在间隙中插入新记录，解决 “幻读” 问题（RR 隔离级别下生效）。</p>\n<h5 id=\"4-3-2-什么是间隙\"><a href=\"#4-3-2-什么是间隙\" class=\"headerlink\" title=\"4.3.2 什么是间隙\"></a>4.3.2 什么是间隙</h5><p>​\t\t指索引值之间的空白区间。例如，表中某索引列存在值<code>10、20、30</code>，则间隙包括：<code>(-∞, 10)</code>、<code>(10, 20)</code>、<code>(20, 30)</code>、<code>(30, +∞)</code>。</p>\n<h5 id=\"4-3-3-间隙锁的作用\"><a href=\"#4-3-3-间隙锁的作用\" class=\"headerlink\" title=\"4.3.3 间隙锁的作用\"></a>4.3.3 间隙锁的作用</h5><p>​\t\t阻止在间隙中插入新行。例如，事务 A 对<code>(10, 20)</code>加间隙锁后，其他事务无法插入<code>15</code>（属于该间隙），但可以修改已存在的<code>10、20</code>（如果没被行锁锁定）。</p>\n<h5 id=\"4-3-4-间隙锁的触发场景\"><a href=\"#4-3-4-间隙锁的触发场景\" class=\"headerlink\" title=\"4.3.4 间隙锁的触发场景\"></a>4.3.4 间隙锁的触发场景</h5><p>​\t\t在 RR 隔离级别下，使用非唯一索引或范围查询（如<code>WHERE id &gt; 10 AND id &lt; 20</code>）时，InnoDB 会对匹配不到行的范围加间隙锁。</p>\n<blockquote>\n<p>注意：间隙锁之间不冲突（多个事务可同时对同一间隙加间隙锁）。</p>\n</blockquote>\n<h4 id=\"4-4-临键锁\"><a href=\"#4-4-临键锁\" class=\"headerlink\" title=\"4.4 临键锁\"></a>4.4 临键锁</h4><h5 id=\"4-4-1-临键锁的概念\"><a href=\"#4-4-1-临键锁的概念\" class=\"headerlink\" title=\"4.4.1 临键锁的概念\"></a>4.4.1 临键锁的概念</h5><p>​\t\t临键锁是<strong>行锁与间隙锁的组合</strong>，是 InnoDB 在 RR 隔离级别下默认的行级锁类型，既锁定具体行，也锁定该行前面的间隙。</p>\n<h5 id=\"4-4-2-临键锁的作用\"><a href=\"#4-4-2-临键锁的作用\" class=\"headerlink\" title=\"4.4.2 临键锁的作用\"></a>4.4.2 临键锁的作用</h5><p>​\t\t临键锁主要用来防止两种冲突</p>\n<ul>\n<li>其他事务修改锁定的行（行锁的作用）。</li>\n<li>其他事务在锁定的间隙中插入新行（间隙锁的作用）。</li>\n</ul>\n<h5 id=\"4-4-3-临键锁的触发场景\"><a href=\"#4-4-3-临键锁的触发场景\" class=\"headerlink\" title=\"4.4.3 临键锁的触发场景\"></a>4.4.3 临键锁的触发场景</h5><p>​\t\t在 RR 隔离级别下，使用<strong>非唯一索引进行等值查询或范围查询</strong>时，若命中行，InnoDB 会对该行加行锁，同时对该行左侧的间隙加间隙锁，<strong>组合为临键锁</strong>。</p>\n","excerpt":"","more":"<h3 id=\"1、锁的分类\"><a href=\"#1、锁的分类\" class=\"headerlink\" title=\"1、锁的分类\"></a>1、锁的分类</h3><ul>\n<li>全局锁：锁住整个数据库，也就是锁住数据库中所有的表。</li>\n<li>表级锁：锁住整张表。</li>\n<li>行级锁：锁住单独的一行数据。</li>\n</ul>\n<h3 id=\"2、全局锁\"><a href=\"#2、全局锁\" class=\"headerlink\" title=\"2、全局锁\"></a>2、全局锁</h3><h4 id=\"2-1-全局锁的分类和作用\"><a href=\"#2-1-全局锁的分类和作用\" class=\"headerlink\" title=\"2.1 全局锁的分类和作用\"></a>2.1 全局锁的分类和作用</h4><p>​\t\tMySQL全局锁是针对整个数据库的锁。最常用的全局锁是读锁和写锁。</p>\n<ul>\n<li>读锁（共享锁）：它阻止其他用户更新数据，但允许他们读取数据。</li>\n<li>写锁（排他锁）：它阻止其他用户读取和更新数据。</li>\n</ul>\n<h4 id=\"2-2-全局锁的用法\"><a href=\"#2-2-全局锁的用法\" class=\"headerlink\" title=\"2.2 全局锁的用法\"></a>2.2 全局锁的用法</h4><ul>\n<li><code>FLUSH TABLES WITH READ/WRITE LOCK(FTWRL)</code>：用来锁住整个数据库</li>\n<li><code>UNLOCK TABLES</code> ：进行解锁</li>\n</ul>\n<h4 id=\"2-3-全局锁的使用场景\"><a href=\"#2-3-全局锁的使用场景\" class=\"headerlink\" title=\"2.3 全局锁的使用场景\"></a>2.3 全局锁的使用场景</h4><ul>\n<li><strong>备份全库</strong>：使用全局锁可以确保在备份过程中，数据库的所有表都保持一致的状态。</li>\n<li><strong>整体数据迁移</strong>：将整个数据库从一个服务器迁移到另一个服务器，需要阻止任何写操作，以确保所有的数据都被正确地迁移到新的服务器。</li>\n<li><strong>全库只读</strong>：在某些情况下，可能希望将整个数据库设置为只读模式。</li>\n</ul>\n<h3 id=\"3、表级锁\"><a href=\"#3、表级锁\" class=\"headerlink\" title=\"3、表级锁\"></a>3、表级锁</h3><h4 id=\"3-1-表级锁的分类\"><a href=\"#3-1-表级锁的分类\" class=\"headerlink\" title=\"3.1 表级锁的分类\"></a>3.1 表级锁的分类</h4><ul>\n<li><p>表锁</p>\n</li>\n<li><p>元数据锁</p>\n</li>\n<li><p>意向锁</p>\n<blockquote>\n<p>​        这里可能会疑惑为什么有表锁、意向锁、元数据锁会<strong>处于同一层级</strong>，不应该是表锁包含元数据锁和意向锁吗，这里其实陷入了一个误区，其实，表锁、意向锁、元数据锁 都属于 表<strong>级</strong>锁，而表<strong>级</strong>锁当然包括了表锁，同时，元数据锁和意向锁也都属于表<strong>级</strong>锁，同样，行锁和行<strong>级</strong>锁也是同样的道理，后面就不赘述了。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"3-2-表锁\"><a href=\"#3-2-表锁\" class=\"headerlink\" title=\"3.2 表锁\"></a>3.2 表锁</h4><h5 id=\"3-2-1-表锁的概念和分类\"><a href=\"#3-2-1-表锁的概念和分类\" class=\"headerlink\" title=\"3.2.1 表锁的概念和分类\"></a>3.2.1 表锁的概念和分类</h5><p>​\t\t表锁是<strong>最基础的表级锁</strong>，直接对整个表进行锁定，分为<strong>读锁和写锁</strong>，二者遵循 “读共享、写独占” 原则。</p>\n<ul>\n<li><strong>读锁（Shared Lock，简称 S 锁）</strong>：事务加读锁后，自身和其他事务只能读表，不能修改表数据。多个事务可同时对同一表加读锁，互不阻塞。</li>\n<li><strong>写锁（Exclusive Lock，简称 X 锁）</strong>：事务加写锁后，只有自身能读写表数据，其他事务无法加读锁或写锁，也不能查询或者修改数据，会被阻塞直到当前事务的写锁释放。</li>\n</ul>\n<h5 id=\"3-2-2-表锁的用法\"><a href=\"#3-2-2-表锁的用法\" class=\"headerlink\" title=\"3.2.2 表锁的用法\"></a>3.2.2 表锁的用法</h5><ul>\n<li>加锁：<code>lock tables 表名... read/write</code></li>\n<li>解锁：<code>unlock tables 或者 客户端连接断开</code></li>\n</ul>\n<h5 id=\"3-2-3-与MyISAM-存储引擎的关联\"><a href=\"#3-2-3-与MyISAM-存储引擎的关联\" class=\"headerlink\" title=\"3.2.3 与MyISAM 存储引擎的关联\"></a>3.2.3 与MyISAM 存储引擎的关联</h5><p>​\t\t由于MyISAM 引擎不支持行锁，所有操作都依赖表锁，且默认会在<code>select</code>时隐式加读锁、<code>insert/update/delete</code>时隐式加写锁并自动释放。</p>\n<h4 id=\"3-3-元数据锁\"><a href=\"#3-3-元数据锁\" class=\"headerlink\" title=\"3.3 元数据锁\"></a>3.3 元数据锁</h4><h5 id=\"3-3-1-元数据锁的概念和分类\"><a href=\"#3-3-1-元数据锁的概念和分类\" class=\"headerlink\" title=\"3.3.1 元数据锁的概念和分类\"></a>3.3.1 元数据锁的概念和分类</h5><p>​\t\t<strong>元数据锁（Metadata Lock，简称 MDL）<code>MDL</code> 不锁定数据本身，而是</strong>保护表的元数据（如表结构、字段类型、索引信息等），避免 “表结构修改” 与 “数据读写” 同时进行导致的不一致。</p>\n<ul>\n<li><strong>共享 MDL 锁（Shared MDL）</strong>：事务执行查询（如<code>SELECT</code>）时自动加共享 <code>MDL</code> 锁，多个事务可同时加，互不影响。</li>\n<li><strong>排他 MDL 锁（Exclusive MDL）</strong>：事务执行表结构修改（如<code>ALTER TABLE</code>、<code>DROP COLUMN</code>）时自动加排他 MDL锁，加锁期间会阻塞所有其他事务的共享 <code>MDL</code> 锁请求。</li>\n</ul>\n<h4 id=\"3-4-意向锁\"><a href=\"#3-4-意向锁\" class=\"headerlink\" title=\"3.4 意向锁\"></a>3.4 意向锁</h4><h5 id=\"3-4-1-意向锁的概念和分类\"><a href=\"#3-4-1-意向锁的概念和分类\" class=\"headerlink\" title=\"3.4.1 意向锁的概念和分类\"></a>3.4.1 意向锁的概念和分类</h5><p>​\t\t意向锁是 “中间层锁”，作用是<strong>快速判断表内是否存在行级锁</strong>，避免表锁与行锁的冲突检查需要遍历所有行，提升效率。它仅标识 “意向”，不直接阻止数据读写。</p>\n<ul>\n<li><strong>意向共享锁（Intention Shared Lock，简称 IS 锁）</strong>：事务计划对表中某些行加读锁（行级 <code>S</code> 锁）前，会先对表加 <code>IS</code> 锁。</li>\n<li><strong>意向排他锁（Intention Exclusive Lock，简称 IX 锁）</strong>：事务计划对表中某些行加写锁（行级 <code>X</code> 锁）前，会先对表加 <code>IX</code> 锁。</li>\n</ul>\n<h5 id=\"3-4-2-意向锁的执行过程\"><a href=\"#3-4-2-意向锁的执行过程\" class=\"headerlink\" title=\"3.4.2 意向锁的执行过程\"></a>3.4.2 意向锁的执行过程</h5><p>​\t\t<strong>原来</strong>：当执行根据 <code>id</code> 更新数据库表中的某一行数据时，会在这一行加上行锁，但是当另一个客户端需要加表锁的时候，会逐行检查是否有行锁的存在。效率极低。</p>\n<p>​\t\t<strong>现在</strong>(有了意向锁后)：当加行锁的时候，<strong>同时会给这张表加上意向锁</strong>，当另一个客户端需要加表锁的时候，就会先去检查这个意向锁<strong>是否与自己要获取的锁兼容</strong>，如果兼容，获取锁成功，如果不兼容，获取锁失败。</p>\n<h3 id=\"4、行级锁\"><a href=\"#4、行级锁\" class=\"headerlink\" title=\"4、行级锁\"></a>4、行级锁</h3><h4 id=\"4-1-行级锁的分类\"><a href=\"#4-1-行级锁的分类\" class=\"headerlink\" title=\"4.1 行级锁的分类\"></a>4.1 行级锁的分类</h4><ul>\n<li>行锁</li>\n<li>间隙锁</li>\n<li>临键锁</li>\n</ul>\n<h4 id=\"4-2-行锁\"><a href=\"#4-2-行锁\" class=\"headerlink\" title=\"4.2 行锁\"></a>4.2 行锁</h4><h5 id=\"4-2-1-行锁的概念和分类\"><a href=\"#4-2-1-行锁的概念和分类\" class=\"headerlink\" title=\"4.2.1 行锁的概念和分类\"></a>4.2.1 行锁的概念和分类</h5><p>​\t\t行锁是最基础的行级锁，<strong>直接锁定表中某一行记录</strong>，仅对锁定的行生效，不影响其他行。</p>\n<ul>\n<li>共享锁（<code>S</code> 锁）：事务对某行加 <code>S</code> 锁后，自身可读该行，其他事务可加 <code>S</code> 锁（共享读），但不能加 <code>X</code> 锁（阻塞写）。</li>\n<li>排他锁（<code>X</code> 锁）：事务对某行加 <code>X</code> 锁后，自身可读写该行，其他事务既不能加 <code>S</code> 锁也不能加 <code>X</code> 锁（读写都阻塞）。</li>\n</ul>\n<h5 id=\"4-2-2-行锁的特点\"><a href=\"#4-2-2-行锁的特点\" class=\"headerlink\" title=\"4.2.2 行锁的特点\"></a>4.2.2 行锁的特点</h5><p>​\t\t仅锁定具体行，粒度最细，并发影响最小，但加锁 &#x2F; 释放锁开销略高于表锁。行锁必须<strong>基于索引生效</strong>，若查询未使用索引（进行的是全表扫描），InnoDB 会退化为表锁（意向锁 + 表锁）。</p>\n<h4 id=\"4-3-间隙锁\"><a href=\"#4-3-间隙锁\" class=\"headerlink\" title=\"4.3 间隙锁\"></a>4.3 间隙锁</h4><h5 id=\"4-3-1-间隙锁的概念\"><a href=\"#4-3-1-间隙锁的概念\" class=\"headerlink\" title=\"4.3.1 间隙锁的概念\"></a>4.3.1 间隙锁的概念</h5><p>​\t\t间隙锁是<strong>锁定索引记录之间的 “间隙”</strong>，不锁定具体行，仅防止其他事务在间隙中插入新记录，解决 “幻读” 问题（RR 隔离级别下生效）。</p>\n<h5 id=\"4-3-2-什么是间隙\"><a href=\"#4-3-2-什么是间隙\" class=\"headerlink\" title=\"4.3.2 什么是间隙\"></a>4.3.2 什么是间隙</h5><p>​\t\t指索引值之间的空白区间。例如，表中某索引列存在值<code>10、20、30</code>，则间隙包括：<code>(-∞, 10)</code>、<code>(10, 20)</code>、<code>(20, 30)</code>、<code>(30, +∞)</code>。</p>\n<h5 id=\"4-3-3-间隙锁的作用\"><a href=\"#4-3-3-间隙锁的作用\" class=\"headerlink\" title=\"4.3.3 间隙锁的作用\"></a>4.3.3 间隙锁的作用</h5><p>​\t\t阻止在间隙中插入新行。例如，事务 A 对<code>(10, 20)</code>加间隙锁后，其他事务无法插入<code>15</code>（属于该间隙），但可以修改已存在的<code>10、20</code>（如果没被行锁锁定）。</p>\n<h5 id=\"4-3-4-间隙锁的触发场景\"><a href=\"#4-3-4-间隙锁的触发场景\" class=\"headerlink\" title=\"4.3.4 间隙锁的触发场景\"></a>4.3.4 间隙锁的触发场景</h5><p>​\t\t在 RR 隔离级别下，使用非唯一索引或范围查询（如<code>WHERE id &gt; 10 AND id &lt; 20</code>）时，InnoDB 会对匹配不到行的范围加间隙锁。</p>\n<blockquote>\n<p>注意：间隙锁之间不冲突（多个事务可同时对同一间隙加间隙锁）。</p>\n</blockquote>\n<h4 id=\"4-4-临键锁\"><a href=\"#4-4-临键锁\" class=\"headerlink\" title=\"4.4 临键锁\"></a>4.4 临键锁</h4><h5 id=\"4-4-1-临键锁的概念\"><a href=\"#4-4-1-临键锁的概念\" class=\"headerlink\" title=\"4.4.1 临键锁的概念\"></a>4.4.1 临键锁的概念</h5><p>​\t\t临键锁是<strong>行锁与间隙锁的组合</strong>，是 InnoDB 在 RR 隔离级别下默认的行级锁类型，既锁定具体行，也锁定该行前面的间隙。</p>\n<h5 id=\"4-4-2-临键锁的作用\"><a href=\"#4-4-2-临键锁的作用\" class=\"headerlink\" title=\"4.4.2 临键锁的作用\"></a>4.4.2 临键锁的作用</h5><p>​\t\t临键锁主要用来防止两种冲突</p>\n<ul>\n<li>其他事务修改锁定的行（行锁的作用）。</li>\n<li>其他事务在锁定的间隙中插入新行（间隙锁的作用）。</li>\n</ul>\n<h5 id=\"4-4-3-临键锁的触发场景\"><a href=\"#4-4-3-临键锁的触发场景\" class=\"headerlink\" title=\"4.4.3 临键锁的触发场景\"></a>4.4.3 临键锁的触发场景</h5><p>​\t\t在 RR 隔离级别下，使用<strong>非唯一索引进行等值查询或范围查询</strong>时，若命中行，InnoDB 会对该行加行锁，同时对该行左侧的间隙加间隙锁，<strong>组合为临键锁</strong>。</p>\n"},{"title":"测试文章02","description":"文章缩略，支持 `Markdown` **文档格式**\n","pinned":0,"lang":"zh","abbrlink":"cc7c02e8","wordCount":112,"charCount":2135,"imgCount":0,"vidCount":0,"wsCount":0,"cbCount":0,"readTime":"约48秒","date":"2025-10-18T13:48:31.000Z","_content":"## 一、String 的特性\n\n### 1、String 为什么是不可变的？\n\n##### 1）原因：\n\n① **安全性**：String 类常用于存储敏感信息，如密码，路径等，如果它是可变的，攻击者可能通过修改字符串内容来绕过安全检查。同时Java的类加载器在加载类时会使用String来存储类名和包名，如果String是可变的，攻击者可能加载恶意的类破坏系统。Java String 类的不可变性，确保了这些关键字符串在创建并传递后，其值绝对无法被任何代码（包括自身）所改变，从根本上杜绝了被篡改的风险。是系统安全性的基石。\n\n② **字符串常量池依赖不可变性**：String 类是程序中最常用的，同时存在大量重复字符串，为了解决大量重复的问题，引入了字符串常量池，当创建字符串时，JVM 会优先从池中找，没有再创建，而这个优化完全依赖String的不可变性，因为常量池中的一个对象可能被多次引用，如果其中的任何一个引用能修改对象的值，那末就会导致所有共享该对象的引用全部出错。\n\n③ 在**多线程**模式下，可以自由传递、共享 String，不需要任何同步机制，简化了开发。\n\n④ 由于 String 的不可变性，因此 String 对象的hash值只用计算一次，后续直接从缓存中读取，提高了集合的性能。\n\n##### 2）实现方法：\n\n​      `String` 类的核心参数为 `value` 数组，在`JDK 9` 之后，使用 `byte[]`  代替 `char[]` 。`value` 值由` final` 关键字修饰，保证数据引用的不变性，用 `private`修饰，保证外部无法直接修改，同时 `String` 类由 `final` 修饰，保证不会被继承，防止子类的修改。在 `JDK 9` 版本时，还引用了`Java` 的内部注解`@Stable`，修饰 `value` ，用于提示 `JVM` ，这是一个稳定的字段，一旦赋值，基本不会改变，是运行时的稳定承诺。当访问一个普通字段时，因可能被其他线程修改，理论上需每次从内存加载（但实际受 CPU 缓存优化影响，可能读取旧值）；但是由`@Stable` 注解修饰后，在高频访问时，可能在读取后，就将值存储到一个寄存器中，后续直接从寄存器中取值即可。同时，在编译时可能直接把这个值当作常量，将其内敛到使用它的地方，也被称为 常量折叠 提升运行速度。注意：仍可以用反射调用修改，但是开发者往往不被允许。\n\n### 2、String、StirngBuffer、StirngBuilder 的区别？\n\n##### 1）不可变性：\n\n​      String 是不可变的，任何操作都会产生新的对象，原字符串不做改变。StringBuilder 和 StringBuffer 都是可变的，都是直接在原对象上修改，避免创建新的对象。具体是StringBuilder 和 StringBuffer 都继承AbstractStringBuilder抽象类，其字符都是存储在 value 中，没有使用 final 修饰，当修改时，若 value 容量不够，则会将 value 数组进行扩容，之后，将新串复制到扩容后的数组中。因此只是替换了value数组，原StringBuilder 和 StringBuffer 对象的引用没有改变。\n\n##### 2）线程安全性：\n\n​      String 由不可变性，天然就是线程安全的。StringBuilder 是线程不安全的，多线程模式下可能会导致数据不一致问题。StringBuffer 是线程安全的，所有的方法都是用 Synchorized 修饰。\n\n##### 3）性能（大致）：\n\n​      String（反复创建对象） < StringBuffer（多线程下的加锁解锁） < StringBuilder （单线程下性能高）\n\n### 3、字符串常量池？\n\n##### 1）存储位置：\n\n​      在 JDK 7 之前，字符串常量池位于方法区的永久代中，在JDK 7 之后，字符串常量池也被移动至堆内。\n\n##### 2）存储内容：\n\n​      在 JDK 7 之前，存储的是字符串本身，在移动到堆后，存储的是字符串在堆内存上的引用。对于没有引用的对象，可被垃圾回收器回收，防止内存泄漏。\n\n##### 3）使用方法：\n\n​      String s1 = “Hello” ，则会自动入池，并通过池中的引用指向堆中的“Hello”，而String s2 = new String(“Hello”) ,则是直接在堆内存中创建了一个新的对象，不会进入字符串常量池中。但是可以使用 s2.intern() 方法，将字符串手动添加到常量池中，并返回引用。\n\n##### 4）数据结构：\n\n​      字符串常量池是通过基于Hash表的StringTable实现，JDK 7 之前，固定大小，之后，可指定大小， JDK 9 时，将char[] 改为 byte[]。\n\n### 4、JDK 9 为什么将Stirng的char[]改为byte[]？\n\n##### 1）内存的优化：\n\n​      用char数组时，一个char 占用 2 个字节，实际中，英文，数字，特殊字符占使用的大多数，且是需要 1 个字节。对于byte数组，字符，英文，数字等，都只占用 1 个字节，中文占用 2 个字。例如，对于 “Hello” ，char 数组存需要 5 * 2 = 10B，对于byte数组只需要 5B，节省了近50%的空间。\n\n##### 2）自适应编码\n\n​      根据不同的字符串使用不同的编码。当仅包含 1 个字节的字符时，String 中的coder标志位为 0 ，表示使用单字节编码字符集，当字符串中存在 2 个字节的字符时，String 中的coder标志位为 1，表示采用双字节编码字符集，同时，当单字节字符串拼接上双字节字符串时，会将coder升级为1，表示采用双字节编码字符集。\n\n### 5、Substring() 的优化？\n\n​      substring：在JDK 6 以及之前，时复用原数组，即使只是用一小部分呢，但是要保留整个字符串，导致原字符串无法被GC，在JDK 7 之后，则是会创建一个新的字符串返回，原字符串可以被GC。","source":"_posts/测试文章02.md","raw":"---\ntitle: 测试文章02\ndescription: |\n  文章缩略，支持 `Markdown` **文档格式**\ntags: \n  - 测试\npinned: 0\nlang: zh\nabbrlink: cc7c02e8\nwordCount: 112\ncharCount: 2135\nimgCount: 0\nvidCount: 0\nwsCount: 0\ncbCount: 0\nreadTime: 约48秒\ndate: 2025-10-18 21:48:31\n---\n## 一、String 的特性\n\n### 1、String 为什么是不可变的？\n\n##### 1）原因：\n\n① **安全性**：String 类常用于存储敏感信息，如密码，路径等，如果它是可变的，攻击者可能通过修改字符串内容来绕过安全检查。同时Java的类加载器在加载类时会使用String来存储类名和包名，如果String是可变的，攻击者可能加载恶意的类破坏系统。Java String 类的不可变性，确保了这些关键字符串在创建并传递后，其值绝对无法被任何代码（包括自身）所改变，从根本上杜绝了被篡改的风险。是系统安全性的基石。\n\n② **字符串常量池依赖不可变性**：String 类是程序中最常用的，同时存在大量重复字符串，为了解决大量重复的问题，引入了字符串常量池，当创建字符串时，JVM 会优先从池中找，没有再创建，而这个优化完全依赖String的不可变性，因为常量池中的一个对象可能被多次引用，如果其中的任何一个引用能修改对象的值，那末就会导致所有共享该对象的引用全部出错。\n\n③ 在**多线程**模式下，可以自由传递、共享 String，不需要任何同步机制，简化了开发。\n\n④ 由于 String 的不可变性，因此 String 对象的hash值只用计算一次，后续直接从缓存中读取，提高了集合的性能。\n\n##### 2）实现方法：\n\n​      `String` 类的核心参数为 `value` 数组，在`JDK 9` 之后，使用 `byte[]`  代替 `char[]` 。`value` 值由` final` 关键字修饰，保证数据引用的不变性，用 `private`修饰，保证外部无法直接修改，同时 `String` 类由 `final` 修饰，保证不会被继承，防止子类的修改。在 `JDK 9` 版本时，还引用了`Java` 的内部注解`@Stable`，修饰 `value` ，用于提示 `JVM` ，这是一个稳定的字段，一旦赋值，基本不会改变，是运行时的稳定承诺。当访问一个普通字段时，因可能被其他线程修改，理论上需每次从内存加载（但实际受 CPU 缓存优化影响，可能读取旧值）；但是由`@Stable` 注解修饰后，在高频访问时，可能在读取后，就将值存储到一个寄存器中，后续直接从寄存器中取值即可。同时，在编译时可能直接把这个值当作常量，将其内敛到使用它的地方，也被称为 常量折叠 提升运行速度。注意：仍可以用反射调用修改，但是开发者往往不被允许。\n\n### 2、String、StirngBuffer、StirngBuilder 的区别？\n\n##### 1）不可变性：\n\n​      String 是不可变的，任何操作都会产生新的对象，原字符串不做改变。StringBuilder 和 StringBuffer 都是可变的，都是直接在原对象上修改，避免创建新的对象。具体是StringBuilder 和 StringBuffer 都继承AbstractStringBuilder抽象类，其字符都是存储在 value 中，没有使用 final 修饰，当修改时，若 value 容量不够，则会将 value 数组进行扩容，之后，将新串复制到扩容后的数组中。因此只是替换了value数组，原StringBuilder 和 StringBuffer 对象的引用没有改变。\n\n##### 2）线程安全性：\n\n​      String 由不可变性，天然就是线程安全的。StringBuilder 是线程不安全的，多线程模式下可能会导致数据不一致问题。StringBuffer 是线程安全的，所有的方法都是用 Synchorized 修饰。\n\n##### 3）性能（大致）：\n\n​      String（反复创建对象） < StringBuffer（多线程下的加锁解锁） < StringBuilder （单线程下性能高）\n\n### 3、字符串常量池？\n\n##### 1）存储位置：\n\n​      在 JDK 7 之前，字符串常量池位于方法区的永久代中，在JDK 7 之后，字符串常量池也被移动至堆内。\n\n##### 2）存储内容：\n\n​      在 JDK 7 之前，存储的是字符串本身，在移动到堆后，存储的是字符串在堆内存上的引用。对于没有引用的对象，可被垃圾回收器回收，防止内存泄漏。\n\n##### 3）使用方法：\n\n​      String s1 = “Hello” ，则会自动入池，并通过池中的引用指向堆中的“Hello”，而String s2 = new String(“Hello”) ,则是直接在堆内存中创建了一个新的对象，不会进入字符串常量池中。但是可以使用 s2.intern() 方法，将字符串手动添加到常量池中，并返回引用。\n\n##### 4）数据结构：\n\n​      字符串常量池是通过基于Hash表的StringTable实现，JDK 7 之前，固定大小，之后，可指定大小， JDK 9 时，将char[] 改为 byte[]。\n\n### 4、JDK 9 为什么将Stirng的char[]改为byte[]？\n\n##### 1）内存的优化：\n\n​      用char数组时，一个char 占用 2 个字节，实际中，英文，数字，特殊字符占使用的大多数，且是需要 1 个字节。对于byte数组，字符，英文，数字等，都只占用 1 个字节，中文占用 2 个字。例如，对于 “Hello” ，char 数组存需要 5 * 2 = 10B，对于byte数组只需要 5B，节省了近50%的空间。\n\n##### 2）自适应编码\n\n​      根据不同的字符串使用不同的编码。当仅包含 1 个字节的字符时，String 中的coder标志位为 0 ，表示使用单字节编码字符集，当字符串中存在 2 个字节的字符时，String 中的coder标志位为 1，表示采用双字节编码字符集，同时，当单字节字符串拼接上双字节字符串时，会将coder升级为1，表示采用双字节编码字符集。\n\n### 5、Substring() 的优化？\n\n​      substring：在JDK 6 以及之前，时复用原数组，即使只是用一小部分呢，但是要保留整个字符串，导致原字符串无法被GC，在JDK 7 之后，则是会创建一个新的字符串返回，原字符串可以被GC。","slug":"测试文章02","published":1,"updated":"2025-10-25T07:16:18.590Z","comments":1,"layout":"post","photos":[],"_id":"cuidFRoQ94qS_21H7IxbHcBB0","content":"<h2 id=\"一、String-的特性\"><a href=\"#一、String-的特性\" class=\"headerlink\" title=\"一、String 的特性\"></a>一、String 的特性</h2><h3 id=\"1、String-为什么是不可变的？\"><a href=\"#1、String-为什么是不可变的？\" class=\"headerlink\" title=\"1、String 为什么是不可变的？\"></a>1、String 为什么是不可变的？</h3><h5 id=\"1）原因：\"><a href=\"#1）原因：\" class=\"headerlink\" title=\"1）原因：\"></a>1）原因：</h5><p>① <strong>安全性</strong>：String 类常用于存储敏感信息，如密码，路径等，如果它是可变的，攻击者可能通过修改字符串内容来绕过安全检查。同时Java的类加载器在加载类时会使用String来存储类名和包名，如果String是可变的，攻击者可能加载恶意的类破坏系统。Java String 类的不可变性，确保了这些关键字符串在创建并传递后，其值绝对无法被任何代码（包括自身）所改变，从根本上杜绝了被篡改的风险。是系统安全性的基石。</p>\n<p>② <strong>字符串常量池依赖不可变性</strong>：String 类是程序中最常用的，同时存在大量重复字符串，为了解决大量重复的问题，引入了字符串常量池，当创建字符串时，JVM 会优先从池中找，没有再创建，而这个优化完全依赖String的不可变性，因为常量池中的一个对象可能被多次引用，如果其中的任何一个引用能修改对象的值，那末就会导致所有共享该对象的引用全部出错。</p>\n<p>③ 在<strong>多线程</strong>模式下，可以自由传递、共享 String，不需要任何同步机制，简化了开发。</p>\n<p>④ 由于 String 的不可变性，因此 String 对象的hash值只用计算一次，后续直接从缓存中读取，提高了集合的性能。</p>\n<h5 id=\"2）实现方法：\"><a href=\"#2）实现方法：\" class=\"headerlink\" title=\"2）实现方法：\"></a>2）实现方法：</h5><p>​      <code>String</code> 类的核心参数为 <code>value</code> 数组，在<code>JDK 9</code> 之后，使用 <code>byte[]</code>  代替 <code>char[]</code> 。<code>value</code> 值由<code> final</code> 关键字修饰，保证数据引用的不变性，用 <code>private</code>修饰，保证外部无法直接修改，同时 <code>String</code> 类由 <code>final</code> 修饰，保证不会被继承，防止子类的修改。在 <code>JDK 9</code> 版本时，还引用了<code>Java</code> 的内部注解<code>@Stable</code>，修饰 <code>value</code> ，用于提示 <code>JVM</code> ，这是一个稳定的字段，一旦赋值，基本不会改变，是运行时的稳定承诺。当访问一个普通字段时，因可能被其他线程修改，理论上需每次从内存加载（但实际受 CPU 缓存优化影响，可能读取旧值）；但是由<code>@Stable</code> 注解修饰后，在高频访问时，可能在读取后，就将值存储到一个寄存器中，后续直接从寄存器中取值即可。同时，在编译时可能直接把这个值当作常量，将其内敛到使用它的地方，也被称为 常量折叠 提升运行速度。注意：仍可以用反射调用修改，但是开发者往往不被允许。</p>\n<h3 id=\"2、String、StirngBuffer、StirngBuilder-的区别？\"><a href=\"#2、String、StirngBuffer、StirngBuilder-的区别？\" class=\"headerlink\" title=\"2、String、StirngBuffer、StirngBuilder 的区别？\"></a>2、String、StirngBuffer、StirngBuilder 的区别？</h3><h5 id=\"1）不可变性：\"><a href=\"#1）不可变性：\" class=\"headerlink\" title=\"1）不可变性：\"></a>1）不可变性：</h5><p>​      String 是不可变的，任何操作都会产生新的对象，原字符串不做改变。StringBuilder 和 StringBuffer 都是可变的，都是直接在原对象上修改，避免创建新的对象。具体是StringBuilder 和 StringBuffer 都继承AbstractStringBuilder抽象类，其字符都是存储在 value 中，没有使用 final 修饰，当修改时，若 value 容量不够，则会将 value 数组进行扩容，之后，将新串复制到扩容后的数组中。因此只是替换了value数组，原StringBuilder 和 StringBuffer 对象的引用没有改变。</p>\n<h5 id=\"2）线程安全性：\"><a href=\"#2）线程安全性：\" class=\"headerlink\" title=\"2）线程安全性：\"></a>2）线程安全性：</h5><p>​      String 由不可变性，天然就是线程安全的。StringBuilder 是线程不安全的，多线程模式下可能会导致数据不一致问题。StringBuffer 是线程安全的，所有的方法都是用 Synchorized 修饰。</p>\n<h5 id=\"3）性能（大致）：\"><a href=\"#3）性能（大致）：\" class=\"headerlink\" title=\"3）性能（大致）：\"></a>3）性能（大致）：</h5><p>​      String（反复创建对象） &lt; StringBuffer（多线程下的加锁解锁） &lt; StringBuilder （单线程下性能高）</p>\n<h3 id=\"3、字符串常量池？\"><a href=\"#3、字符串常量池？\" class=\"headerlink\" title=\"3、字符串常量池？\"></a>3、字符串常量池？</h3><h5 id=\"1）存储位置：\"><a href=\"#1）存储位置：\" class=\"headerlink\" title=\"1）存储位置：\"></a>1）存储位置：</h5><p>​      在 JDK 7 之前，字符串常量池位于方法区的永久代中，在JDK 7 之后，字符串常量池也被移动至堆内。</p>\n<h5 id=\"2）存储内容：\"><a href=\"#2）存储内容：\" class=\"headerlink\" title=\"2）存储内容：\"></a>2）存储内容：</h5><p>​      在 JDK 7 之前，存储的是字符串本身，在移动到堆后，存储的是字符串在堆内存上的引用。对于没有引用的对象，可被垃圾回收器回收，防止内存泄漏。</p>\n<h5 id=\"3）使用方法：\"><a href=\"#3）使用方法：\" class=\"headerlink\" title=\"3）使用方法：\"></a>3）使用方法：</h5><p>​      String s1 &#x3D; “Hello” ，则会自动入池，并通过池中的引用指向堆中的“Hello”，而String s2 &#x3D; new String(“Hello”) ,则是直接在堆内存中创建了一个新的对象，不会进入字符串常量池中。但是可以使用 s2.intern() 方法，将字符串手动添加到常量池中，并返回引用。</p>\n<h5 id=\"4）数据结构：\"><a href=\"#4）数据结构：\" class=\"headerlink\" title=\"4）数据结构：\"></a>4）数据结构：</h5><p>​      字符串常量池是通过基于Hash表的StringTable实现，JDK 7 之前，固定大小，之后，可指定大小， JDK 9 时，将char[] 改为 byte[]。</p>\n<h3 id=\"4、JDK-9-为什么将Stirng的char-改为byte-？\"><a href=\"#4、JDK-9-为什么将Stirng的char-改为byte-？\" class=\"headerlink\" title=\"4、JDK 9 为什么将Stirng的char[]改为byte[]？\"></a>4、JDK 9 为什么将Stirng的char[]改为byte[]？</h3><h5 id=\"1）内存的优化：\"><a href=\"#1）内存的优化：\" class=\"headerlink\" title=\"1）内存的优化：\"></a>1）内存的优化：</h5><p>​      用char数组时，一个char 占用 2 个字节，实际中，英文，数字，特殊字符占使用的大多数，且是需要 1 个字节。对于byte数组，字符，英文，数字等，都只占用 1 个字节，中文占用 2 个字。例如，对于 “Hello” ，char 数组存需要 5 * 2 &#x3D; 10B，对于byte数组只需要 5B，节省了近50%的空间。</p>\n<h5 id=\"2）自适应编码\"><a href=\"#2）自适应编码\" class=\"headerlink\" title=\"2）自适应编码\"></a>2）自适应编码</h5><p>​      根据不同的字符串使用不同的编码。当仅包含 1 个字节的字符时，String 中的coder标志位为 0 ，表示使用单字节编码字符集，当字符串中存在 2 个字节的字符时，String 中的coder标志位为 1，表示采用双字节编码字符集，同时，当单字节字符串拼接上双字节字符串时，会将coder升级为1，表示采用双字节编码字符集。</p>\n<h3 id=\"5、Substring-的优化？\"><a href=\"#5、Substring-的优化？\" class=\"headerlink\" title=\"5、Substring() 的优化？\"></a>5、Substring() 的优化？</h3><p>​      substring：在JDK 6 以及之前，时复用原数组，即使只是用一小部分呢，但是要保留整个字符串，导致原字符串无法被GC，在JDK 7 之后，则是会创建一个新的字符串返回，原字符串可以被GC。</p>\n","excerpt":"","more":"<h2 id=\"一、String-的特性\"><a href=\"#一、String-的特性\" class=\"headerlink\" title=\"一、String 的特性\"></a>一、String 的特性</h2><h3 id=\"1、String-为什么是不可变的？\"><a href=\"#1、String-为什么是不可变的？\" class=\"headerlink\" title=\"1、String 为什么是不可变的？\"></a>1、String 为什么是不可变的？</h3><h5 id=\"1）原因：\"><a href=\"#1）原因：\" class=\"headerlink\" title=\"1）原因：\"></a>1）原因：</h5><p>① <strong>安全性</strong>：String 类常用于存储敏感信息，如密码，路径等，如果它是可变的，攻击者可能通过修改字符串内容来绕过安全检查。同时Java的类加载器在加载类时会使用String来存储类名和包名，如果String是可变的，攻击者可能加载恶意的类破坏系统。Java String 类的不可变性，确保了这些关键字符串在创建并传递后，其值绝对无法被任何代码（包括自身）所改变，从根本上杜绝了被篡改的风险。是系统安全性的基石。</p>\n<p>② <strong>字符串常量池依赖不可变性</strong>：String 类是程序中最常用的，同时存在大量重复字符串，为了解决大量重复的问题，引入了字符串常量池，当创建字符串时，JVM 会优先从池中找，没有再创建，而这个优化完全依赖String的不可变性，因为常量池中的一个对象可能被多次引用，如果其中的任何一个引用能修改对象的值，那末就会导致所有共享该对象的引用全部出错。</p>\n<p>③ 在<strong>多线程</strong>模式下，可以自由传递、共享 String，不需要任何同步机制，简化了开发。</p>\n<p>④ 由于 String 的不可变性，因此 String 对象的hash值只用计算一次，后续直接从缓存中读取，提高了集合的性能。</p>\n<h5 id=\"2）实现方法：\"><a href=\"#2）实现方法：\" class=\"headerlink\" title=\"2）实现方法：\"></a>2）实现方法：</h5><p>​      <code>String</code> 类的核心参数为 <code>value</code> 数组，在<code>JDK 9</code> 之后，使用 <code>byte[]</code>  代替 <code>char[]</code> 。<code>value</code> 值由<code> final</code> 关键字修饰，保证数据引用的不变性，用 <code>private</code>修饰，保证外部无法直接修改，同时 <code>String</code> 类由 <code>final</code> 修饰，保证不会被继承，防止子类的修改。在 <code>JDK 9</code> 版本时，还引用了<code>Java</code> 的内部注解<code>@Stable</code>，修饰 <code>value</code> ，用于提示 <code>JVM</code> ，这是一个稳定的字段，一旦赋值，基本不会改变，是运行时的稳定承诺。当访问一个普通字段时，因可能被其他线程修改，理论上需每次从内存加载（但实际受 CPU 缓存优化影响，可能读取旧值）；但是由<code>@Stable</code> 注解修饰后，在高频访问时，可能在读取后，就将值存储到一个寄存器中，后续直接从寄存器中取值即可。同时，在编译时可能直接把这个值当作常量，将其内敛到使用它的地方，也被称为 常量折叠 提升运行速度。注意：仍可以用反射调用修改，但是开发者往往不被允许。</p>\n<h3 id=\"2、String、StirngBuffer、StirngBuilder-的区别？\"><a href=\"#2、String、StirngBuffer、StirngBuilder-的区别？\" class=\"headerlink\" title=\"2、String、StirngBuffer、StirngBuilder 的区别？\"></a>2、String、StirngBuffer、StirngBuilder 的区别？</h3><h5 id=\"1）不可变性：\"><a href=\"#1）不可变性：\" class=\"headerlink\" title=\"1）不可变性：\"></a>1）不可变性：</h5><p>​      String 是不可变的，任何操作都会产生新的对象，原字符串不做改变。StringBuilder 和 StringBuffer 都是可变的，都是直接在原对象上修改，避免创建新的对象。具体是StringBuilder 和 StringBuffer 都继承AbstractStringBuilder抽象类，其字符都是存储在 value 中，没有使用 final 修饰，当修改时，若 value 容量不够，则会将 value 数组进行扩容，之后，将新串复制到扩容后的数组中。因此只是替换了value数组，原StringBuilder 和 StringBuffer 对象的引用没有改变。</p>\n<h5 id=\"2）线程安全性：\"><a href=\"#2）线程安全性：\" class=\"headerlink\" title=\"2）线程安全性：\"></a>2）线程安全性：</h5><p>​      String 由不可变性，天然就是线程安全的。StringBuilder 是线程不安全的，多线程模式下可能会导致数据不一致问题。StringBuffer 是线程安全的，所有的方法都是用 Synchorized 修饰。</p>\n<h5 id=\"3）性能（大致）：\"><a href=\"#3）性能（大致）：\" class=\"headerlink\" title=\"3）性能（大致）：\"></a>3）性能（大致）：</h5><p>​      String（反复创建对象） &lt; StringBuffer（多线程下的加锁解锁） &lt; StringBuilder （单线程下性能高）</p>\n<h3 id=\"3、字符串常量池？\"><a href=\"#3、字符串常量池？\" class=\"headerlink\" title=\"3、字符串常量池？\"></a>3、字符串常量池？</h3><h5 id=\"1）存储位置：\"><a href=\"#1）存储位置：\" class=\"headerlink\" title=\"1）存储位置：\"></a>1）存储位置：</h5><p>​      在 JDK 7 之前，字符串常量池位于方法区的永久代中，在JDK 7 之后，字符串常量池也被移动至堆内。</p>\n<h5 id=\"2）存储内容：\"><a href=\"#2）存储内容：\" class=\"headerlink\" title=\"2）存储内容：\"></a>2）存储内容：</h5><p>​      在 JDK 7 之前，存储的是字符串本身，在移动到堆后，存储的是字符串在堆内存上的引用。对于没有引用的对象，可被垃圾回收器回收，防止内存泄漏。</p>\n<h5 id=\"3）使用方法：\"><a href=\"#3）使用方法：\" class=\"headerlink\" title=\"3）使用方法：\"></a>3）使用方法：</h5><p>​      String s1 &#x3D; “Hello” ，则会自动入池，并通过池中的引用指向堆中的“Hello”，而String s2 &#x3D; new String(“Hello”) ,则是直接在堆内存中创建了一个新的对象，不会进入字符串常量池中。但是可以使用 s2.intern() 方法，将字符串手动添加到常量池中，并返回引用。</p>\n<h5 id=\"4）数据结构：\"><a href=\"#4）数据结构：\" class=\"headerlink\" title=\"4）数据结构：\"></a>4）数据结构：</h5><p>​      字符串常量池是通过基于Hash表的StringTable实现，JDK 7 之前，固定大小，之后，可指定大小， JDK 9 时，将char[] 改为 byte[]。</p>\n<h3 id=\"4、JDK-9-为什么将Stirng的char-改为byte-？\"><a href=\"#4、JDK-9-为什么将Stirng的char-改为byte-？\" class=\"headerlink\" title=\"4、JDK 9 为什么将Stirng的char[]改为byte[]？\"></a>4、JDK 9 为什么将Stirng的char[]改为byte[]？</h3><h5 id=\"1）内存的优化：\"><a href=\"#1）内存的优化：\" class=\"headerlink\" title=\"1）内存的优化：\"></a>1）内存的优化：</h5><p>​      用char数组时，一个char 占用 2 个字节，实际中，英文，数字，特殊字符占使用的大多数，且是需要 1 个字节。对于byte数组，字符，英文，数字等，都只占用 1 个字节，中文占用 2 个字。例如，对于 “Hello” ，char 数组存需要 5 * 2 &#x3D; 10B，对于byte数组只需要 5B，节省了近50%的空间。</p>\n<h5 id=\"2）自适应编码\"><a href=\"#2）自适应编码\" class=\"headerlink\" title=\"2）自适应编码\"></a>2）自适应编码</h5><p>​      根据不同的字符串使用不同的编码。当仅包含 1 个字节的字符时，String 中的coder标志位为 0 ，表示使用单字节编码字符集，当字符串中存在 2 个字节的字符时，String 中的coder标志位为 1，表示采用双字节编码字符集，同时，当单字节字符串拼接上双字节字符串时，会将coder升级为1，表示采用双字节编码字符集。</p>\n<h3 id=\"5、Substring-的优化？\"><a href=\"#5、Substring-的优化？\" class=\"headerlink\" title=\"5、Substring() 的优化？\"></a>5、Substring() 的优化？</h3><p>​      substring：在JDK 6 以及之前，时复用原数组，即使只是用一小部分呢，但是要保留整个字符串，导致原字符串无法被GC，在JDK 7 之后，则是会创建一个新的字符串返回，原字符串可以被GC。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cuide8VRWDVwkZfPD5BVkxwER","tag_id":"cuiduEShVdl9efqEiYWg3dCZs","_id":"cuidW9c7TEA4EXeYXPtGHXHfe"},{"post_id":"cuid-HNBgA_Cgt9UDV2HlI-uC","tag_id":"cuid3OnNtSxepYiBxl6uo71sS","_id":"cuidi4Ogh88NdJqLmVhhKKqCF"},{"post_id":"cuidFRoQ94qS_21H7IxbHcBB0","tag_id":"cuiduEShVdl9efqEiYWg3dCZs","_id":"cuidLnR5U2VXe3kqdZC0vRiZP"}],"Tag":[{"name":"测试","_id":"cuiduEShVdl9efqEiYWg3dCZs"},{"name":"MySQL","_id":"cuid3OnNtSxepYiBxl6uo71sS"}]}}