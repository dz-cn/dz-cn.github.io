{"meta":{"version":1,"warehouse":"6.0.0"},"models":{"Asset":[{"_id":"themes/particlex/source/css/main.css","path":"css/main.css","modified":1,"renderable":1},{"_id":"themes/particlex/source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/particlex/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/crypto.js","path":"js/lib/crypto.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/highlight.js","path":"js/lib/highlight.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/math.js","path":"js/lib/math.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/home.js","path":"js/lib/home.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/preview.js","path":"js/lib/preview.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/search.js","path":"js/lib/search.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/images/background/01.png","path":"images/background/01.png","modified":1,"renderable":1},{"_id":"themes/particlex/source/images/background/02.jpeg","path":"images/background/02.jpeg","modified":1,"renderable":1},{"_id":"themes/particlex/source/images/background/03.png","path":"images/background/03.png","modified":1,"renderable":1},{"_id":"themes/particlex/source/images/background/04.png","path":"images/background/04.png","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/测试文章01.md","hash":"4117da13e629138e29e0c45ac1ed7b37a43be68e","modified":1760838901186},{"_id":"source/_posts/测试文章02.md","hash":"769a3bc4d6600e983d8368aa5d80670c3603c1c4","modified":1760838901187},{"_id":"themes/particlex/.npmignore","hash":"5410a1bef9807f666cd92a0d2020f700e67e4096","modified":1760789613045},{"_id":"themes/particlex/LICENSE","hash":"c42335f46096b2ec5509087ab122e5dfd43e2cf4","modified":1760789613045},{"_id":"themes/particlex/README.md","hash":"19b124670bc5c9aa8cff0fc191be1e9a40c841a0","modified":1760789613047},{"_id":"themes/particlex/package.json","hash":"db00b08d699e394ba9c88edcf280792075e35654","modified":1760789613050},{"_id":"themes/particlex/_config.yml","hash":"8a11977c4973ff7c81e1d5ffc3860187382f3bd2","modified":1760839970101},{"_id":"themes/particlex/layout/archives.ejs","hash":"c3878ffe435aa37ba46a0ee25c34257c2f2a1d87","modified":1760789613047},{"_id":"themes/particlex/pnpm-lock.yaml","hash":"4c7a4f39b776af75374d0dc6f6619dcbf0e58b97","modified":1760789613050},{"_id":"themes/particlex/layout/card.ejs","hash":"65e0c46a79c02212982c8a9aef1b16bfc3430429","modified":1760789613047},{"_id":"themes/particlex/layout/categories.ejs","hash":"73ff20a582c72e7cf138c7b42006447e4a2e110a","modified":1760789613047},{"_id":"themes/particlex/layout/comment.ejs","hash":"267809e50962af7ab6bc5892855f765d754a62e4","modified":1760789613047},{"_id":"themes/particlex/layout/current.ejs","hash":"4e75c06c9d0b1336c69c210567581e7efded5621","modified":1760789613047},{"_id":"themes/particlex/layout/footer.ejs","hash":"6ccde848ceb1011792c230d98ee84320fa284d90","modified":1760837104678},{"_id":"themes/particlex/layout/index.ejs","hash":"0921f22d3d4ff0c3a1821db3247564be5f0300eb","modified":1760837591075},{"_id":"themes/particlex/layout/menu.ejs","hash":"1c78bd05cdfb3ae7a47ed572229a1970335fe8b8","modified":1760789613047},{"_id":"themes/particlex/layout/layout.ejs","hash":"bc6f2c3c0a47b755590f3345ef6159d58b29683f","modified":1760789613047},{"_id":"themes/particlex/layout/import.ejs","hash":"7800720150b46a9abaf513316602a05293b3991b","modified":1760789613047},{"_id":"themes/particlex/layout/posts.ejs","hash":"18209210f37d7e8775ca54e4724ce66ad09d873f","modified":1760789613047},{"_id":"themes/particlex/layout/tags.ejs","hash":"f5b821d45f2f44443adade62eb032f92215e0d62","modified":1760789613047},{"_id":"themes/particlex/source/css/main.css","hash":"dc0026a7ea7b8c5d3cf4e137a5fc2c27e8f100c2","modified":1760837528846},{"_id":"themes/particlex/layout/post.ejs","hash":"659d5bd4f6a5d717adb2b8f5c5604783aae71aa5","modified":1760839530510},{"_id":"themes/particlex/source/images/loading.gif","hash":"9c840c5c3e7b97a184deb390df2f6926d6161708","modified":1760789613058},{"_id":"themes/particlex/source/js/lib/crypto.js","hash":"3db8692ac636d9f72dc94127216d21f9793e6602","modified":1760789613059},{"_id":"themes/particlex/source/js/main.js","hash":"420d9ab7f2e0cb44bdc5335389344ec1e7253db5","modified":1760789613059},{"_id":"themes/particlex/source/js/lib/highlight.js","hash":"58fdb5f2d5e409bfc10aac6ccc464c87327806a5","modified":1760797519840},{"_id":"themes/particlex/source/js/lib/home.js","hash":"5ec113e1d72efaab5eb31addc05eb9dcf26ce1af","modified":1760789613059},{"_id":"themes/particlex/source/js/lib/math.js","hash":"f7716e83ef236818239fcae91defe730d5bfbc6d","modified":1760789613059},{"_id":"themes/particlex/source/js/lib/preview.js","hash":"d3050c6ed6d52e451cc1810843c5d595eadb8e5a","modified":1760789613059},{"_id":"themes/particlex/source/js/lib/search.js","hash":"d507facc680300c046f2b967279959541313e1f9","modified":1760789613059},{"_id":"themes/particlex/source/images/avatar.jpg","hash":"cd5b921252d1a4f15e17858f4f816ba768a6acf7","modified":1760789613053},{"_id":"themes/particlex/source/images/background/02.jpeg","hash":"fb0379e3d28922d59ca55822765033ed49bbf87c","modified":1758783425818},{"_id":"themes/particlex/source/images/background/04.png","hash":"f228f5ebb89143a7debac551f21289719260ae77","modified":1742782445000},{"_id":"themes/particlex/source/images/background/03.png","hash":"8ed8cd24312f35f231a6626f10ab1fc52cde2079","modified":1742782447000},{"_id":"themes/particlex/source/images/background/01.png","hash":"9045362ac3960c29f11c40bda42cf6406ec2cdcc","modified":1742697699000},{"_id":"public/posts/cc7c02e8.html","hash":"31f4046415c8436129f6afe26d186b07c4455ab2","modified":1761227010941},{"_id":"public/posts/55755352.html","hash":"4b5fb45b410ec7b994be8f6bebad9bb827bb36d7","modified":1761227010941},{"_id":"public/tags/测试/index.html","hash":"81e60c6b2c387e1e78c5ec1eac9780371c4806dd","modified":1761227010941},{"_id":"public/archives/index.html","hash":"18923c6fa8383dcf259453d0464516e5bdb39a15","modified":1761227010941},{"_id":"public/archives/2025/index.html","hash":"b14188e5b56e070de11c1cf99c494de7aa16cc28","modified":1761227010941},{"_id":"public/archives/2025/10/index.html","hash":"89fc32172f26768afeccf66cdf9218e3856dc965","modified":1761227010941},{"_id":"public/index.html","hash":"2cc464a1702e511efbedc1eaa85bf2c57b03c1d9","modified":1761227010941},{"_id":"public/images/loading.gif","hash":"9c840c5c3e7b97a184deb390df2f6926d6161708","modified":1761227010941},{"_id":"public/css/main.css","hash":"68afc95f7d19f84655a4b2d47378f8a2fa4a275d","modified":1761227010941},{"_id":"public/js/main.js","hash":"a9cb52bac89783c3957c77cbb4ffc8fbb93a92a1","modified":1761227010941},{"_id":"public/js/lib/crypto.js","hash":"bc4a0c41cf5b61faa204a2a820fc042b563142cf","modified":1761227010941},{"_id":"public/js/lib/home.js","hash":"c2bf22772fd052cff88a9b5f547a30a6eb97e545","modified":1761227010941},{"_id":"public/js/lib/preview.js","hash":"595cfc3aff107b8dd0fdda214995c6f1bb5be39a","modified":1761227010941},{"_id":"public/js/lib/math.js","hash":"24c182cd3f5dd1c0f0192ca4cc143de71e076d2a","modified":1761227010941},{"_id":"public/js/lib/highlight.js","hash":"a9ee0fd40904e2e50ab5ecab4c718a49c095836f","modified":1761227010941},{"_id":"public/js/lib/search.js","hash":"b631b87fa126a9a4a81b60b1a0516f765879963e","modified":1761227010941},{"_id":"public/images/avatar.jpg","hash":"cd5b921252d1a4f15e17858f4f816ba768a6acf7","modified":1761227010941},{"_id":"public/images/background/02.jpeg","hash":"fb0379e3d28922d59ca55822765033ed49bbf87c","modified":1761227010941},{"_id":"public/images/background/04.png","hash":"f228f5ebb89143a7debac551f21289719260ae77","modified":1761227010941},{"_id":"public/images/background/03.png","hash":"8ed8cd24312f35f231a6626f10ab1fc52cde2079","modified":1761227010941},{"_id":"public/images/background/01.png","hash":"9045362ac3960c29f11c40bda42cf6406ec2cdcc","modified":1761227010941}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"测试文章01","description":"文章缩略，支持 `Markdown` **文档格式**\n","pinned":1,"abbrlink":"55755352","date":"2025-10-18T13:05:32.000Z","_content":"\n# 算法\n\n## 一、平方剩余和\n\n> 主要用于快速的判断两个数的乘积是否为完全平方数。\n> 如果平方剩余和相等，则两个数的乘积是完全平方数。\n\n```java\nimport java.util.HashSet;\nclass Solution {\n    // 平方剩余和 的预处理\n    static int[] core = new int[1010];\n    static int limit = 1000;\n    static {\n        // 求 1~1000 的所有数的平方剩余和\n        for(int i = 1;i <= limit;i++) {\n            if(core[i] == 0) {\n                // 说明没有被计算过\n                for(int j = 1;i*j*j <= limit;j++) {\n                    core[i*j*j] = i;\n                }\n            }\n        }\n    }\n\n    // 验证，平方剩余和 时，两个数的乘积为完全平方数\n    public static void main(String[] args) {\n        for(int i = 1;i <= 1000;i++) {\n            for(int j = i + 1;j <= 1000;j++) {\n                if(core[i] == core[j]) {\n                    System.out.println((i * j) + \" == \" + (String.format(\"%.0f\",Math.sqrt(i * j))) + \"^2\");\n                }\n            }\n        }\n    }\n}\n```","source":"_posts/测试文章01.md","raw":"---\ntitle: 测试文章01\ntags: 测试\ndescription: |\n  文章缩略，支持 `Markdown` **文档格式**\npinned: 1\nabbrlink: '55755352'\ndate: 2025-10-18 21:05:32\n---\n\n# 算法\n\n## 一、平方剩余和\n\n> 主要用于快速的判断两个数的乘积是否为完全平方数。\n> 如果平方剩余和相等，则两个数的乘积是完全平方数。\n\n```java\nimport java.util.HashSet;\nclass Solution {\n    // 平方剩余和 的预处理\n    static int[] core = new int[1010];\n    static int limit = 1000;\n    static {\n        // 求 1~1000 的所有数的平方剩余和\n        for(int i = 1;i <= limit;i++) {\n            if(core[i] == 0) {\n                // 说明没有被计算过\n                for(int j = 1;i*j*j <= limit;j++) {\n                    core[i*j*j] = i;\n                }\n            }\n        }\n    }\n\n    // 验证，平方剩余和 时，两个数的乘积为完全平方数\n    public static void main(String[] args) {\n        for(int i = 1;i <= 1000;i++) {\n            for(int j = i + 1;j <= 1000;j++) {\n                if(core[i] == core[j]) {\n                    System.out.println((i * j) + \" == \" + (String.format(\"%.0f\",Math.sqrt(i * j))) + \"^2\");\n                }\n            }\n        }\n    }\n}\n```","slug":"测试文章01","published":1,"updated":"2025-10-19T01:55:01.186Z","comments":1,"layout":"post","photos":[],"_id":"cuidJPcLM2LKMFxo39c41lkAa","content":"<h1 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h1><h2 id=\"一、平方剩余和\"><a href=\"#一、平方剩余和\" class=\"headerlink\" title=\"一、平方剩余和\"></a>一、平方剩余和</h2><blockquote>\n<p>主要用于快速的判断两个数的乘积是否为完全平方数。<br>如果平方剩余和相等，则两个数的乘积是完全平方数。</p>\n</blockquote>\n<pre><code class=\"language-java\">import java.util.HashSet;\nclass Solution {\n    // 平方剩余和 的预处理\n    static int[] core = new int[1010];\n    static int limit = 1000;\n    static {\n        // 求 1~1000 的所有数的平方剩余和\n        for(int i = 1;i &lt;= limit;i++) {\n            if(core[i] == 0) {\n                // 说明没有被计算过\n                for(int j = 1;i*j*j &lt;= limit;j++) {\n                    core[i*j*j] = i;\n                }\n            }\n        }\n    }\n\n    // 验证，平方剩余和 时，两个数的乘积为完全平方数\n    public static void main(String[] args) {\n        for(int i = 1;i &lt;= 1000;i++) {\n            for(int j = i + 1;j &lt;= 1000;j++) {\n                if(core[i] == core[j]) {\n                    System.out.println((i * j) + &quot; == &quot; + (String.format(&quot;%.0f&quot;,Math.sqrt(i * j))) + &quot;^2&quot;);\n                }\n            }\n        }\n    }\n}\n</code></pre>\n","excerpt":"","more":"<h1 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h1><h2 id=\"一、平方剩余和\"><a href=\"#一、平方剩余和\" class=\"headerlink\" title=\"一、平方剩余和\"></a>一、平方剩余和</h2><blockquote>\n<p>主要用于快速的判断两个数的乘积是否为完全平方数。<br>如果平方剩余和相等，则两个数的乘积是完全平方数。</p>\n</blockquote>\n<pre><code class=\"language-java\">import java.util.HashSet;\nclass Solution {\n    // 平方剩余和 的预处理\n    static int[] core = new int[1010];\n    static int limit = 1000;\n    static {\n        // 求 1~1000 的所有数的平方剩余和\n        for(int i = 1;i &lt;= limit;i++) {\n            if(core[i] == 0) {\n                // 说明没有被计算过\n                for(int j = 1;i*j*j &lt;= limit;j++) {\n                    core[i*j*j] = i;\n                }\n            }\n        }\n    }\n\n    // 验证，平方剩余和 时，两个数的乘积为完全平方数\n    public static void main(String[] args) {\n        for(int i = 1;i &lt;= 1000;i++) {\n            for(int j = i + 1;j &lt;= 1000;j++) {\n                if(core[i] == core[j]) {\n                    System.out.println((i * j) + &quot; == &quot; + (String.format(&quot;%.0f&quot;,Math.sqrt(i * j))) + &quot;^2&quot;);\n                }\n            }\n        }\n    }\n}\n</code></pre>\n"},{"title":"测试文章02","description":"文章缩略，支持 `Markdown` **文档格式**\n","pinned":0,"abbrlink":"cc7c02e8","date":"2025-10-18T13:48:31.000Z","_content":"## 一、String 的特性\n\n### 1、String 为什么是不可变的？\n\n##### 1）原因：\n\n① **安全性**：String 类常用于存储敏感信息，如密码，路径等，如果它是可变的，攻击者可能通过修改字符串内容来绕过安全检查。同时Java的类加载器在加载类时会使用String来存储类名和包名，如果String是可变的，攻击者可能加载恶意的类破坏系统。Java String 类的不可变性，确保了这些关键字符串在创建并传递后，其值绝对无法被任何代码（包括自身）所改变，从根本上杜绝了被篡改的风险。是系统安全性的基石。\n\n② **字符串常量池依赖不可变性**：String 类是程序中最常用的，同时存在大量重复字符串，为了解决大量重复的问题，引入了字符串常量池，当创建字符串时，JVM 会优先从池中找，没有再创建，而这个优化完全依赖String的不可变性，因为常量池中的一个对象可能被多次引用，如果其中的任何一个引用能修改对象的值，那末就会导致所有共享该对象的引用全部出错。\n\n③ 在**多线程**模式下，可以自由传递、共享 String，不需要任何同步机制，简化了开发。\n\n④ 由于 String 的不可变性，因此 String 对象的hash值只用计算一次，后续直接从缓存中读取，提高了集合的性能。\n\n##### 2）实现方法：\n\n​      `String` 类的核心参数为 `value` 数组，在`JDK 9` 之后，使用 `byte[]`  代替 `char[]` 。`value` 值由` final` 关键字修饰，保证数据引用的不变性，用 `private`修饰，保证外部无法直接修改，同时 `String` 类由 `final` 修饰，保证不会被继承，防止子类的修改。在 `JDK 9` 版本时，还引用了`Java` 的内部注解`@Stable`，修饰 `value` ，用于提示 `JVM` ，这是一个稳定的字段，一旦赋值，基本不会改变，是运行时的稳定承诺。当访问一个普通字段时，因可能被其他线程修改，理论上需每次从内存加载（但实际受 CPU 缓存优化影响，可能读取旧值）；但是由`@Stable` 注解修饰后，在高频访问时，可能在读取后，就将值存储到一个寄存器中，后续直接从寄存器中取值即可。同时，在编译时可能直接把这个值当作常量，将其内敛到使用它的地方，也被称为 常量折叠 提升运行速度。注意：仍可以用反射调用修改，但是开发者往往不被允许。\n\n### 2、String、StirngBuffer、StirngBuilder 的区别？\n\n##### 1）不可变性：\n\n​      String 是不可变的，任何操作都会产生新的对象，原字符串不做改变。StringBuilder 和 StringBuffer 都是可变的，都是直接在原对象上修改，避免创建新的对象。具体是StringBuilder 和 StringBuffer 都继承AbstractStringBuilder抽象类，其字符都是存储在 value 中，没有使用 final 修饰，当修改时，若 value 容量不够，则会将 value 数组进行扩容，之后，将新串复制到扩容后的数组中。因此只是替换了value数组，原StringBuilder 和 StringBuffer 对象的引用没有改变。\n\n##### 2）线程安全性：\n\n​      String 由不可变性，天然就是线程安全的。StringBuilder 是线程不安全的，多线程模式下可能会导致数据不一致问题。StringBuffer 是线程安全的，所有的方法都是用 Synchorized 修饰。\n\n##### 3）性能（大致）：\n\n​      String（反复创建对象） < StringBuffer（多线程下的加锁解锁） < StringBuilder （单线程下性能高）\n\n### 3、字符串常量池？\n\n##### 1）存储位置：\n\n​      在 JDK 7 之前，字符串常量池位于方法区的永久代中，在JDK 7 之后，字符串常量池也被移动至堆内。\n\n##### 2）存储内容：\n\n​      在 JDK 7 之前，存储的是字符串本身，在移动到堆后，存储的是字符串在堆内存上的引用。对于没有引用的对象，可被垃圾回收器回收，防止内存泄漏。\n\n##### 3）使用方法：\n\n​      String s1 = “Hello” ，则会自动入池，并通过池中的引用指向堆中的“Hello”，而String s2 = new String(“Hello”) ,则是直接在堆内存中创建了一个新的对象，不会进入字符串常量池中。但是可以使用 s2.intern() 方法，将字符串手动添加到常量池中，并返回引用。\n\n##### 4）数据结构：\n\n​      字符串常量池是通过基于Hash表的StringTable实现，JDK 7 之前，固定大小，之后，可指定大小， JDK 9 时，将char[] 改为 byte[]。\n\n### 4、JDK 9 为什么将Stirng的char[]改为byte[]？\n\n##### 1）内存的优化：\n\n​      用char数组时，一个char 占用 2 个字节，实际中，英文，数字，特殊字符占使用的大多数，且是需要 1 个字节。对于byte数组，字符，英文，数字等，都只占用 1 个字节，中文占用 2 个字。例如，对于 “Hello” ，char 数组存需要 5 * 2 = 10B，对于byte数组只需要 5B，节省了近50%的空间。\n\n##### 2）自适应编码\n\n​      根据不同的字符串使用不同的编码。当仅包含 1 个字节的字符时，String 中的coder标志位为 0 ，表示使用单字节编码字符集，当字符串中存在 2 个字节的字符时，String 中的coder标志位为 1，表示采用双字节编码字符集，同时，当单字节字符串拼接上双字节字符串时，会将coder升级为1，表示采用双字节编码字符集。\n\n### 5、Substring() 的优化？\n\n​      substring：在JDK 6 以及之前，时复用原数组，即使只是用一小部分呢，但是要保留整个字符串，导致原字符串无法被GC，在JDK 7 之后，则是会创建一个新的字符串返回，原字符串可以被GC。","source":"_posts/测试文章02.md","raw":"---\ntitle: 测试文章02\ndescription: |\n  文章缩略，支持 `Markdown` **文档格式**\ntags: 测试\npinned: 0\nabbrlink: cc7c02e8\ndate: 2025-10-18 21:48:31\n---\n## 一、String 的特性\n\n### 1、String 为什么是不可变的？\n\n##### 1）原因：\n\n① **安全性**：String 类常用于存储敏感信息，如密码，路径等，如果它是可变的，攻击者可能通过修改字符串内容来绕过安全检查。同时Java的类加载器在加载类时会使用String来存储类名和包名，如果String是可变的，攻击者可能加载恶意的类破坏系统。Java String 类的不可变性，确保了这些关键字符串在创建并传递后，其值绝对无法被任何代码（包括自身）所改变，从根本上杜绝了被篡改的风险。是系统安全性的基石。\n\n② **字符串常量池依赖不可变性**：String 类是程序中最常用的，同时存在大量重复字符串，为了解决大量重复的问题，引入了字符串常量池，当创建字符串时，JVM 会优先从池中找，没有再创建，而这个优化完全依赖String的不可变性，因为常量池中的一个对象可能被多次引用，如果其中的任何一个引用能修改对象的值，那末就会导致所有共享该对象的引用全部出错。\n\n③ 在**多线程**模式下，可以自由传递、共享 String，不需要任何同步机制，简化了开发。\n\n④ 由于 String 的不可变性，因此 String 对象的hash值只用计算一次，后续直接从缓存中读取，提高了集合的性能。\n\n##### 2）实现方法：\n\n​      `String` 类的核心参数为 `value` 数组，在`JDK 9` 之后，使用 `byte[]`  代替 `char[]` 。`value` 值由` final` 关键字修饰，保证数据引用的不变性，用 `private`修饰，保证外部无法直接修改，同时 `String` 类由 `final` 修饰，保证不会被继承，防止子类的修改。在 `JDK 9` 版本时，还引用了`Java` 的内部注解`@Stable`，修饰 `value` ，用于提示 `JVM` ，这是一个稳定的字段，一旦赋值，基本不会改变，是运行时的稳定承诺。当访问一个普通字段时，因可能被其他线程修改，理论上需每次从内存加载（但实际受 CPU 缓存优化影响，可能读取旧值）；但是由`@Stable` 注解修饰后，在高频访问时，可能在读取后，就将值存储到一个寄存器中，后续直接从寄存器中取值即可。同时，在编译时可能直接把这个值当作常量，将其内敛到使用它的地方，也被称为 常量折叠 提升运行速度。注意：仍可以用反射调用修改，但是开发者往往不被允许。\n\n### 2、String、StirngBuffer、StirngBuilder 的区别？\n\n##### 1）不可变性：\n\n​      String 是不可变的，任何操作都会产生新的对象，原字符串不做改变。StringBuilder 和 StringBuffer 都是可变的，都是直接在原对象上修改，避免创建新的对象。具体是StringBuilder 和 StringBuffer 都继承AbstractStringBuilder抽象类，其字符都是存储在 value 中，没有使用 final 修饰，当修改时，若 value 容量不够，则会将 value 数组进行扩容，之后，将新串复制到扩容后的数组中。因此只是替换了value数组，原StringBuilder 和 StringBuffer 对象的引用没有改变。\n\n##### 2）线程安全性：\n\n​      String 由不可变性，天然就是线程安全的。StringBuilder 是线程不安全的，多线程模式下可能会导致数据不一致问题。StringBuffer 是线程安全的，所有的方法都是用 Synchorized 修饰。\n\n##### 3）性能（大致）：\n\n​      String（反复创建对象） < StringBuffer（多线程下的加锁解锁） < StringBuilder （单线程下性能高）\n\n### 3、字符串常量池？\n\n##### 1）存储位置：\n\n​      在 JDK 7 之前，字符串常量池位于方法区的永久代中，在JDK 7 之后，字符串常量池也被移动至堆内。\n\n##### 2）存储内容：\n\n​      在 JDK 7 之前，存储的是字符串本身，在移动到堆后，存储的是字符串在堆内存上的引用。对于没有引用的对象，可被垃圾回收器回收，防止内存泄漏。\n\n##### 3）使用方法：\n\n​      String s1 = “Hello” ，则会自动入池，并通过池中的引用指向堆中的“Hello”，而String s2 = new String(“Hello”) ,则是直接在堆内存中创建了一个新的对象，不会进入字符串常量池中。但是可以使用 s2.intern() 方法，将字符串手动添加到常量池中，并返回引用。\n\n##### 4）数据结构：\n\n​      字符串常量池是通过基于Hash表的StringTable实现，JDK 7 之前，固定大小，之后，可指定大小， JDK 9 时，将char[] 改为 byte[]。\n\n### 4、JDK 9 为什么将Stirng的char[]改为byte[]？\n\n##### 1）内存的优化：\n\n​      用char数组时，一个char 占用 2 个字节，实际中，英文，数字，特殊字符占使用的大多数，且是需要 1 个字节。对于byte数组，字符，英文，数字等，都只占用 1 个字节，中文占用 2 个字。例如，对于 “Hello” ，char 数组存需要 5 * 2 = 10B，对于byte数组只需要 5B，节省了近50%的空间。\n\n##### 2）自适应编码\n\n​      根据不同的字符串使用不同的编码。当仅包含 1 个字节的字符时，String 中的coder标志位为 0 ，表示使用单字节编码字符集，当字符串中存在 2 个字节的字符时，String 中的coder标志位为 1，表示采用双字节编码字符集，同时，当单字节字符串拼接上双字节字符串时，会将coder升级为1，表示采用双字节编码字符集。\n\n### 5、Substring() 的优化？\n\n​      substring：在JDK 6 以及之前，时复用原数组，即使只是用一小部分呢，但是要保留整个字符串，导致原字符串无法被GC，在JDK 7 之后，则是会创建一个新的字符串返回，原字符串可以被GC。","slug":"测试文章02","published":1,"updated":"2025-10-19T01:55:01.187Z","comments":1,"layout":"post","photos":[],"_id":"cuid7ybiXDUCLCV3Ba7yi2ohf","content":"<h2 id=\"一、String-的特性\"><a href=\"#一、String-的特性\" class=\"headerlink\" title=\"一、String 的特性\"></a>一、String 的特性</h2><h3 id=\"1、String-为什么是不可变的？\"><a href=\"#1、String-为什么是不可变的？\" class=\"headerlink\" title=\"1、String 为什么是不可变的？\"></a>1、String 为什么是不可变的？</h3><h5 id=\"1）原因：\"><a href=\"#1）原因：\" class=\"headerlink\" title=\"1）原因：\"></a>1）原因：</h5><p>① <strong>安全性</strong>：String 类常用于存储敏感信息，如密码，路径等，如果它是可变的，攻击者可能通过修改字符串内容来绕过安全检查。同时Java的类加载器在加载类时会使用String来存储类名和包名，如果String是可变的，攻击者可能加载恶意的类破坏系统。Java String 类的不可变性，确保了这些关键字符串在创建并传递后，其值绝对无法被任何代码（包括自身）所改变，从根本上杜绝了被篡改的风险。是系统安全性的基石。</p>\n<p>② <strong>字符串常量池依赖不可变性</strong>：String 类是程序中最常用的，同时存在大量重复字符串，为了解决大量重复的问题，引入了字符串常量池，当创建字符串时，JVM 会优先从池中找，没有再创建，而这个优化完全依赖String的不可变性，因为常量池中的一个对象可能被多次引用，如果其中的任何一个引用能修改对象的值，那末就会导致所有共享该对象的引用全部出错。</p>\n<p>③ 在<strong>多线程</strong>模式下，可以自由传递、共享 String，不需要任何同步机制，简化了开发。</p>\n<p>④ 由于 String 的不可变性，因此 String 对象的hash值只用计算一次，后续直接从缓存中读取，提高了集合的性能。</p>\n<h5 id=\"2）实现方法：\"><a href=\"#2）实现方法：\" class=\"headerlink\" title=\"2）实现方法：\"></a>2）实现方法：</h5><p>​      <code>String</code> 类的核心参数为 <code>value</code> 数组，在<code>JDK 9</code> 之后，使用 <code>byte[]</code>  代替 <code>char[]</code> 。<code>value</code> 值由<code> final</code> 关键字修饰，保证数据引用的不变性，用 <code>private</code>修饰，保证外部无法直接修改，同时 <code>String</code> 类由 <code>final</code> 修饰，保证不会被继承，防止子类的修改。在 <code>JDK 9</code> 版本时，还引用了<code>Java</code> 的内部注解<code>@Stable</code>，修饰 <code>value</code> ，用于提示 <code>JVM</code> ，这是一个稳定的字段，一旦赋值，基本不会改变，是运行时的稳定承诺。当访问一个普通字段时，因可能被其他线程修改，理论上需每次从内存加载（但实际受 CPU 缓存优化影响，可能读取旧值）；但是由<code>@Stable</code> 注解修饰后，在高频访问时，可能在读取后，就将值存储到一个寄存器中，后续直接从寄存器中取值即可。同时，在编译时可能直接把这个值当作常量，将其内敛到使用它的地方，也被称为 常量折叠 提升运行速度。注意：仍可以用反射调用修改，但是开发者往往不被允许。</p>\n<h3 id=\"2、String、StirngBuffer、StirngBuilder-的区别？\"><a href=\"#2、String、StirngBuffer、StirngBuilder-的区别？\" class=\"headerlink\" title=\"2、String、StirngBuffer、StirngBuilder 的区别？\"></a>2、String、StirngBuffer、StirngBuilder 的区别？</h3><h5 id=\"1）不可变性：\"><a href=\"#1）不可变性：\" class=\"headerlink\" title=\"1）不可变性：\"></a>1）不可变性：</h5><p>​      String 是不可变的，任何操作都会产生新的对象，原字符串不做改变。StringBuilder 和 StringBuffer 都是可变的，都是直接在原对象上修改，避免创建新的对象。具体是StringBuilder 和 StringBuffer 都继承AbstractStringBuilder抽象类，其字符都是存储在 value 中，没有使用 final 修饰，当修改时，若 value 容量不够，则会将 value 数组进行扩容，之后，将新串复制到扩容后的数组中。因此只是替换了value数组，原StringBuilder 和 StringBuffer 对象的引用没有改变。</p>\n<h5 id=\"2）线程安全性：\"><a href=\"#2）线程安全性：\" class=\"headerlink\" title=\"2）线程安全性：\"></a>2）线程安全性：</h5><p>​      String 由不可变性，天然就是线程安全的。StringBuilder 是线程不安全的，多线程模式下可能会导致数据不一致问题。StringBuffer 是线程安全的，所有的方法都是用 Synchorized 修饰。</p>\n<h5 id=\"3）性能（大致）：\"><a href=\"#3）性能（大致）：\" class=\"headerlink\" title=\"3）性能（大致）：\"></a>3）性能（大致）：</h5><p>​      String（反复创建对象） &lt; StringBuffer（多线程下的加锁解锁） &lt; StringBuilder （单线程下性能高）</p>\n<h3 id=\"3、字符串常量池？\"><a href=\"#3、字符串常量池？\" class=\"headerlink\" title=\"3、字符串常量池？\"></a>3、字符串常量池？</h3><h5 id=\"1）存储位置：\"><a href=\"#1）存储位置：\" class=\"headerlink\" title=\"1）存储位置：\"></a>1）存储位置：</h5><p>​      在 JDK 7 之前，字符串常量池位于方法区的永久代中，在JDK 7 之后，字符串常量池也被移动至堆内。</p>\n<h5 id=\"2）存储内容：\"><a href=\"#2）存储内容：\" class=\"headerlink\" title=\"2）存储内容：\"></a>2）存储内容：</h5><p>​      在 JDK 7 之前，存储的是字符串本身，在移动到堆后，存储的是字符串在堆内存上的引用。对于没有引用的对象，可被垃圾回收器回收，防止内存泄漏。</p>\n<h5 id=\"3）使用方法：\"><a href=\"#3）使用方法：\" class=\"headerlink\" title=\"3）使用方法：\"></a>3）使用方法：</h5><p>​      String s1 &#x3D; “Hello” ，则会自动入池，并通过池中的引用指向堆中的“Hello”，而String s2 &#x3D; new String(“Hello”) ,则是直接在堆内存中创建了一个新的对象，不会进入字符串常量池中。但是可以使用 s2.intern() 方法，将字符串手动添加到常量池中，并返回引用。</p>\n<h5 id=\"4）数据结构：\"><a href=\"#4）数据结构：\" class=\"headerlink\" title=\"4）数据结构：\"></a>4）数据结构：</h5><p>​      字符串常量池是通过基于Hash表的StringTable实现，JDK 7 之前，固定大小，之后，可指定大小， JDK 9 时，将char[] 改为 byte[]。</p>\n<h3 id=\"4、JDK-9-为什么将Stirng的char-改为byte-？\"><a href=\"#4、JDK-9-为什么将Stirng的char-改为byte-？\" class=\"headerlink\" title=\"4、JDK 9 为什么将Stirng的char[]改为byte[]？\"></a>4、JDK 9 为什么将Stirng的char[]改为byte[]？</h3><h5 id=\"1）内存的优化：\"><a href=\"#1）内存的优化：\" class=\"headerlink\" title=\"1）内存的优化：\"></a>1）内存的优化：</h5><p>​      用char数组时，一个char 占用 2 个字节，实际中，英文，数字，特殊字符占使用的大多数，且是需要 1 个字节。对于byte数组，字符，英文，数字等，都只占用 1 个字节，中文占用 2 个字。例如，对于 “Hello” ，char 数组存需要 5 * 2 &#x3D; 10B，对于byte数组只需要 5B，节省了近50%的空间。</p>\n<h5 id=\"2）自适应编码\"><a href=\"#2）自适应编码\" class=\"headerlink\" title=\"2）自适应编码\"></a>2）自适应编码</h5><p>​      根据不同的字符串使用不同的编码。当仅包含 1 个字节的字符时，String 中的coder标志位为 0 ，表示使用单字节编码字符集，当字符串中存在 2 个字节的字符时，String 中的coder标志位为 1，表示采用双字节编码字符集，同时，当单字节字符串拼接上双字节字符串时，会将coder升级为1，表示采用双字节编码字符集。</p>\n<h3 id=\"5、Substring-的优化？\"><a href=\"#5、Substring-的优化？\" class=\"headerlink\" title=\"5、Substring() 的优化？\"></a>5、Substring() 的优化？</h3><p>​      substring：在JDK 6 以及之前，时复用原数组，即使只是用一小部分呢，但是要保留整个字符串，导致原字符串无法被GC，在JDK 7 之后，则是会创建一个新的字符串返回，原字符串可以被GC。</p>\n","excerpt":"","more":"<h2 id=\"一、String-的特性\"><a href=\"#一、String-的特性\" class=\"headerlink\" title=\"一、String 的特性\"></a>一、String 的特性</h2><h3 id=\"1、String-为什么是不可变的？\"><a href=\"#1、String-为什么是不可变的？\" class=\"headerlink\" title=\"1、String 为什么是不可变的？\"></a>1、String 为什么是不可变的？</h3><h5 id=\"1）原因：\"><a href=\"#1）原因：\" class=\"headerlink\" title=\"1）原因：\"></a>1）原因：</h5><p>① <strong>安全性</strong>：String 类常用于存储敏感信息，如密码，路径等，如果它是可变的，攻击者可能通过修改字符串内容来绕过安全检查。同时Java的类加载器在加载类时会使用String来存储类名和包名，如果String是可变的，攻击者可能加载恶意的类破坏系统。Java String 类的不可变性，确保了这些关键字符串在创建并传递后，其值绝对无法被任何代码（包括自身）所改变，从根本上杜绝了被篡改的风险。是系统安全性的基石。</p>\n<p>② <strong>字符串常量池依赖不可变性</strong>：String 类是程序中最常用的，同时存在大量重复字符串，为了解决大量重复的问题，引入了字符串常量池，当创建字符串时，JVM 会优先从池中找，没有再创建，而这个优化完全依赖String的不可变性，因为常量池中的一个对象可能被多次引用，如果其中的任何一个引用能修改对象的值，那末就会导致所有共享该对象的引用全部出错。</p>\n<p>③ 在<strong>多线程</strong>模式下，可以自由传递、共享 String，不需要任何同步机制，简化了开发。</p>\n<p>④ 由于 String 的不可变性，因此 String 对象的hash值只用计算一次，后续直接从缓存中读取，提高了集合的性能。</p>\n<h5 id=\"2）实现方法：\"><a href=\"#2）实现方法：\" class=\"headerlink\" title=\"2）实现方法：\"></a>2）实现方法：</h5><p>​      <code>String</code> 类的核心参数为 <code>value</code> 数组，在<code>JDK 9</code> 之后，使用 <code>byte[]</code>  代替 <code>char[]</code> 。<code>value</code> 值由<code> final</code> 关键字修饰，保证数据引用的不变性，用 <code>private</code>修饰，保证外部无法直接修改，同时 <code>String</code> 类由 <code>final</code> 修饰，保证不会被继承，防止子类的修改。在 <code>JDK 9</code> 版本时，还引用了<code>Java</code> 的内部注解<code>@Stable</code>，修饰 <code>value</code> ，用于提示 <code>JVM</code> ，这是一个稳定的字段，一旦赋值，基本不会改变，是运行时的稳定承诺。当访问一个普通字段时，因可能被其他线程修改，理论上需每次从内存加载（但实际受 CPU 缓存优化影响，可能读取旧值）；但是由<code>@Stable</code> 注解修饰后，在高频访问时，可能在读取后，就将值存储到一个寄存器中，后续直接从寄存器中取值即可。同时，在编译时可能直接把这个值当作常量，将其内敛到使用它的地方，也被称为 常量折叠 提升运行速度。注意：仍可以用反射调用修改，但是开发者往往不被允许。</p>\n<h3 id=\"2、String、StirngBuffer、StirngBuilder-的区别？\"><a href=\"#2、String、StirngBuffer、StirngBuilder-的区别？\" class=\"headerlink\" title=\"2、String、StirngBuffer、StirngBuilder 的区别？\"></a>2、String、StirngBuffer、StirngBuilder 的区别？</h3><h5 id=\"1）不可变性：\"><a href=\"#1）不可变性：\" class=\"headerlink\" title=\"1）不可变性：\"></a>1）不可变性：</h5><p>​      String 是不可变的，任何操作都会产生新的对象，原字符串不做改变。StringBuilder 和 StringBuffer 都是可变的，都是直接在原对象上修改，避免创建新的对象。具体是StringBuilder 和 StringBuffer 都继承AbstractStringBuilder抽象类，其字符都是存储在 value 中，没有使用 final 修饰，当修改时，若 value 容量不够，则会将 value 数组进行扩容，之后，将新串复制到扩容后的数组中。因此只是替换了value数组，原StringBuilder 和 StringBuffer 对象的引用没有改变。</p>\n<h5 id=\"2）线程安全性：\"><a href=\"#2）线程安全性：\" class=\"headerlink\" title=\"2）线程安全性：\"></a>2）线程安全性：</h5><p>​      String 由不可变性，天然就是线程安全的。StringBuilder 是线程不安全的，多线程模式下可能会导致数据不一致问题。StringBuffer 是线程安全的，所有的方法都是用 Synchorized 修饰。</p>\n<h5 id=\"3）性能（大致）：\"><a href=\"#3）性能（大致）：\" class=\"headerlink\" title=\"3）性能（大致）：\"></a>3）性能（大致）：</h5><p>​      String（反复创建对象） &lt; StringBuffer（多线程下的加锁解锁） &lt; StringBuilder （单线程下性能高）</p>\n<h3 id=\"3、字符串常量池？\"><a href=\"#3、字符串常量池？\" class=\"headerlink\" title=\"3、字符串常量池？\"></a>3、字符串常量池？</h3><h5 id=\"1）存储位置：\"><a href=\"#1）存储位置：\" class=\"headerlink\" title=\"1）存储位置：\"></a>1）存储位置：</h5><p>​      在 JDK 7 之前，字符串常量池位于方法区的永久代中，在JDK 7 之后，字符串常量池也被移动至堆内。</p>\n<h5 id=\"2）存储内容：\"><a href=\"#2）存储内容：\" class=\"headerlink\" title=\"2）存储内容：\"></a>2）存储内容：</h5><p>​      在 JDK 7 之前，存储的是字符串本身，在移动到堆后，存储的是字符串在堆内存上的引用。对于没有引用的对象，可被垃圾回收器回收，防止内存泄漏。</p>\n<h5 id=\"3）使用方法：\"><a href=\"#3）使用方法：\" class=\"headerlink\" title=\"3）使用方法：\"></a>3）使用方法：</h5><p>​      String s1 &#x3D; “Hello” ，则会自动入池，并通过池中的引用指向堆中的“Hello”，而String s2 &#x3D; new String(“Hello”) ,则是直接在堆内存中创建了一个新的对象，不会进入字符串常量池中。但是可以使用 s2.intern() 方法，将字符串手动添加到常量池中，并返回引用。</p>\n<h5 id=\"4）数据结构：\"><a href=\"#4）数据结构：\" class=\"headerlink\" title=\"4）数据结构：\"></a>4）数据结构：</h5><p>​      字符串常量池是通过基于Hash表的StringTable实现，JDK 7 之前，固定大小，之后，可指定大小， JDK 9 时，将char[] 改为 byte[]。</p>\n<h3 id=\"4、JDK-9-为什么将Stirng的char-改为byte-？\"><a href=\"#4、JDK-9-为什么将Stirng的char-改为byte-？\" class=\"headerlink\" title=\"4、JDK 9 为什么将Stirng的char[]改为byte[]？\"></a>4、JDK 9 为什么将Stirng的char[]改为byte[]？</h3><h5 id=\"1）内存的优化：\"><a href=\"#1）内存的优化：\" class=\"headerlink\" title=\"1）内存的优化：\"></a>1）内存的优化：</h5><p>​      用char数组时，一个char 占用 2 个字节，实际中，英文，数字，特殊字符占使用的大多数，且是需要 1 个字节。对于byte数组，字符，英文，数字等，都只占用 1 个字节，中文占用 2 个字。例如，对于 “Hello” ，char 数组存需要 5 * 2 &#x3D; 10B，对于byte数组只需要 5B，节省了近50%的空间。</p>\n<h5 id=\"2）自适应编码\"><a href=\"#2）自适应编码\" class=\"headerlink\" title=\"2）自适应编码\"></a>2）自适应编码</h5><p>​      根据不同的字符串使用不同的编码。当仅包含 1 个字节的字符时，String 中的coder标志位为 0 ，表示使用单字节编码字符集，当字符串中存在 2 个字节的字符时，String 中的coder标志位为 1，表示采用双字节编码字符集，同时，当单字节字符串拼接上双字节字符串时，会将coder升级为1，表示采用双字节编码字符集。</p>\n<h3 id=\"5、Substring-的优化？\"><a href=\"#5、Substring-的优化？\" class=\"headerlink\" title=\"5、Substring() 的优化？\"></a>5、Substring() 的优化？</h3><p>​      substring：在JDK 6 以及之前，时复用原数组，即使只是用一小部分呢，但是要保留整个字符串，导致原字符串无法被GC，在JDK 7 之后，则是会创建一个新的字符串返回，原字符串可以被GC。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cuidJPcLM2LKMFxo39c41lkAa","tag_id":"cuidQuxXDkwoVdRurr3VGEXWz","_id":"cuidjKsk0kRnZujoyweBvCO8f"},{"post_id":"cuid7ybiXDUCLCV3Ba7yi2ohf","tag_id":"cuidQuxXDkwoVdRurr3VGEXWz","_id":"cuidK5EoegXbN8mg34NmeMvX7"}],"Tag":[{"name":"测试","_id":"cuidQuxXDkwoVdRurr3VGEXWz"}]}}