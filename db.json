{"meta":{"version":1,"warehouse":"6.0.0"},"models":{"Asset":[{"_id":"themes/particlex/source/css/main.css","path":"css/main.css","modified":1,"renderable":1},{"_id":"themes/particlex/source/images/avatar-d.jpg","path":"images/avatar-d.jpg","modified":1,"renderable":1},{"_id":"themes/particlex/source/images/avatar.png","path":"images/avatar.png","modified":1,"renderable":1},{"_id":"themes/particlex/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/particlex/source/images/loading-d.gif","path":"images/loading-d.gif","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/images/background/01.png","path":"images/background/01.png","modified":1,"renderable":1},{"_id":"themes/particlex/source/images/background/02.jpeg","path":"images/background/02.jpeg","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/highlight.js","path":"js/lib/highlight.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/images/background/04.png","path":"images/background/04.png","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/crypto.js","path":"js/lib/crypto.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/home.js","path":"js/lib/home.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/images/background/03.png","path":"images/background/03.png","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/math.js","path":"js/lib/math.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/preview.js","path":"js/lib/preview.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/search.js","path":"js/lib/search.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/ArrayList集合.md","hash":"bffa74285d0c67db4e8352ff52f1ab5ebe159bb1","modified":1761575291542},{"_id":"source/_posts/HashMap集合.md","hash":"cf53cc1f4a4cf0d479f078957504adf10520aaed","modified":1761575291541},{"_id":"source/_posts/MySQL事务.md","hash":"953161f567b274fbabd5fb3e80fda63ab1de606e","modified":1761640337769},{"_id":"source/_posts/MySQL的MVCC.md","hash":"0d8531eb2b3f106b14499a82af4f0eee455ee347","modified":1761641137440},{"_id":"source/_posts/MySQL锁.md","hash":"34d72d69c2ef758d883a7a1e3600d7bbb51e1303","modified":1761640885179},{"_id":"source/_posts/MySQL索引.md","hash":"70e252e1ccadfa9213a15b0bca1cd4def69fd1fe","modified":1761640808800},{"_id":"source/_posts/String的特性.md","hash":"51eddeec4ebffad68a0e3b96841988acb6f09d51","modified":1761576076298},{"_id":"source/categories/index.md","hash":"efdb6bb7cfb98f06cf6990f3553c8e26825fdd78","modified":1761526946922},{"_id":"source/_posts/操作系统知识点.md","hash":"d739eb7c3f4ea2dff9468ae3dcc2b7f576117042","modified":1761641230670},{"_id":"source/echarts/index.md","hash":"157245a2e614f4d9b31f210699ca7c2f5c01990a","modified":1761534980979},{"_id":"source/_posts/测试文章02.md","hash":"a08a5308ef6cf12776b962d7391babfe6b149888","modified":1761442043980},{"_id":"source/_posts/测试文章01.md","hash":"4b47fef29d668139c390f9bb11d761b74f0c6b21","modified":1761533023027},{"_id":"source/custom/index.md","hash":"c266b1b06f405f13ee9503593025f684dc3c07c6","modified":1761532847196},{"_id":"source/tags/index.md","hash":"fac98d1c9e3e94deb390981911b31cc21d7d80db","modified":1761526946940},{"_id":"source/_posts/images/MySQL的MVCC-01.png","hash":"da436596c0b26ebdbaa908591ada0b3daae51ee0","modified":1758531394117},{"_id":"source/_posts/images/MySQL的MVCC-02.png","hash":"a3823d8a2c8290b84f1f4911476cda3119bdb04e","modified":1758531394117},{"_id":"themes/particlex/layout/archives.ejs","hash":"d0caf49695e73841e9933374c638c27038547b9b","modified":1761575593097},{"_id":"themes/particlex/.npmignore","hash":"5410a1bef9807f666cd92a0d2020f700e67e4096","modified":1761367061811},{"_id":"themes/particlex/README.md","hash":"19b124670bc5c9aa8cff0fc191be1e9a40c841a0","modified":1761367061811},{"_id":"themes/particlex/layout/categories.ejs","hash":"93dc0ac41cda545aac38a4754103f9050a250360","modified":1761575593086},{"_id":"themes/particlex/LICENSE","hash":"c42335f46096b2ec5509087ab122e5dfd43e2cf4","modified":1761367061811},{"_id":"themes/particlex/_config.yml","hash":"1793ec3224f5cf2c5618163475997b85aaefdc45","modified":1761575792410},{"_id":"themes/particlex/package.json","hash":"db00b08d699e394ba9c88edcf280792075e35654","modified":1761367061818},{"_id":"themes/particlex/layout/card.ejs","hash":"65e0c46a79c02212982c8a9aef1b16bfc3430429","modified":1761367061812},{"_id":"themes/particlex/layout/comment.ejs","hash":"267809e50962af7ab6bc5892855f765d754a62e4","modified":1761367061812},{"_id":"themes/particlex/pnpm-lock.yaml","hash":"4c7a4f39b776af75374d0dc6f6619dcbf0e58b97","modified":1761367061818},{"_id":"themes/particlex/layout/current.ejs","hash":"4e75c06c9d0b1336c69c210567581e7efded5621","modified":1761367061812},{"_id":"themes/particlex/layout/echarts.ejs","hash":"72200a68adb8122e129b9754080e281907b5eb0e","modified":1761535448820},{"_id":"themes/particlex/layout/custom.ejs","hash":"afd6b19ee1d80f734d885a88b9b67f12e5bef1e9","modified":1761533160897},{"_id":"themes/particlex/layout/import.ejs","hash":"7ac80e3afdcd75b109d471399f74261eda70142a","modified":1761363942816},{"_id":"themes/particlex/layout/footer.ejs","hash":"ee3b610c5f388642c93b86827f0c779529d4f809","modified":1761362760692},{"_id":"themes/particlex/layout/layout.ejs","hash":"b213b0fa952cfca7f8e0874911a44ebf46c4c835","modified":1761533370215},{"_id":"themes/particlex/layout/menu.ejs","hash":"1c78bd05cdfb3ae7a47ed572229a1970335fe8b8","modified":1761367061817},{"_id":"themes/particlex/layout/post.ejs","hash":"6c0c40c4e1a1a0da64351006f2582e48b1a8d9ad","modified":1761575593095},{"_id":"themes/particlex/layout/tags.ejs","hash":"3d2e36916f90b1d25d758cec371666aa53db5d07","modified":1761575593092},{"_id":"themes/particlex/source/css/main.css","hash":"72cb9a7f098708f82e03943eea3631ce1e25ce36","modified":1761533855436},{"_id":"themes/particlex/layout/posts.ejs","hash":"5da096cc669ba1ea7b54edf33697fa7b8ff2b449","modified":1761575593097},{"_id":"themes/particlex/layout/index.ejs","hash":"7fd8d9eb3c4b1a186a94d6bce3becdecca28534d","modified":1761378399613},{"_id":"themes/particlex/source/js/lib/highlight.js","hash":"58fdb5f2d5e409bfc10aac6ccc464c87327806a5","modified":1761367062019},{"_id":"themes/particlex/source/js/main.js","hash":"420d9ab7f2e0cb44bdc5335389344ec1e7253db5","modified":1761367062019},{"_id":"themes/particlex/source/js/lib/crypto.js","hash":"3db8692ac636d9f72dc94127216d21f9793e6602","modified":1761367062019},{"_id":"themes/particlex/source/js/lib/home.js","hash":"5ec113e1d72efaab5eb31addc05eb9dcf26ce1af","modified":1761440369181},{"_id":"themes/particlex/source/js/lib/math.js","hash":"f7716e83ef236818239fcae91defe730d5bfbc6d","modified":1761367062019},{"_id":"themes/particlex/source/js/lib/preview.js","hash":"d3050c6ed6d52e451cc1810843c5d595eadb8e5a","modified":1761367062019},{"_id":"themes/particlex/source/images/loading-d.gif","hash":"9c840c5c3e7b97a184deb390df2f6926d6161708","modified":1761367062018},{"_id":"themes/particlex/source/js/lib/search.js","hash":"d507facc680300c046f2b967279959541313e1f9","modified":1761367062019},{"_id":"source/_posts/images/MySQL索引-02.png","hash":"79954db9a6a0cbd34c3ead7266607e9b7bf1d78e","modified":1758531394121},{"_id":"source/_posts/images/MySQL索引-03.png","hash":"6902e459be9d93f9d3ebfe39a641449d5a5cdbee","modified":1758531394122},{"_id":"themes/particlex/source/images/loading.gif","hash":"1e9f899b335bb6325a36c2580430ce10553439d3","modified":1759829303001},{"_id":"source/_posts/images/MySQL索引-01.png","hash":"9dac7e17630c66582d3be15402778a5bc5d1a446","modified":1758531394129},{"_id":"source/_posts/images/MySQL的MVCC-03.png","hash":"6232f6156f310a6c394e9e3d3b816279f3ec5053","modified":1758531394143},{"_id":"themes/particlex/source/images/avatar-d.jpg","hash":"cd5b921252d1a4f15e17858f4f816ba768a6acf7","modified":1761367061819},{"_id":"themes/particlex/source/images/background/02.jpeg","hash":"fb0379e3d28922d59ca55822765033ed49bbf87c","modified":1761367061944},{"_id":"themes/particlex/source/images/background/04.png","hash":"f228f5ebb89143a7debac551f21289719260ae77","modified":1761367062018},{"_id":"themes/particlex/source/images/background/03.png","hash":"8ed8cd24312f35f231a6626f10ab1fc52cde2079","modified":1761367061983},{"_id":"themes/particlex/source/images/avatar.png","hash":"e724e0a002bc1cc2f7bfdb5a3eed547b6955bcd0","modified":1742697390000},{"_id":"themes/particlex/source/images/background/01.png","hash":"9045362ac3960c29f11c40bda42cf6406ec2cdcc","modified":1761367061941},{"_id":"public/categories/index.html","hash":"cc1ed991052d48cd60710cc0103e83e747a9509c","modified":1761641306744},{"_id":"public/echarts/index.html","hash":"34c964847a9d04ccf04915060a90d12a59e02642","modified":1761641306744},{"_id":"public/custom/index.html","hash":"b7be1a9c0ba1934527d33c339928a3a50c500684","modified":1761641306744},{"_id":"public/tags/index.html","hash":"04de186202af22c29c9c4815638dba8b95f52878","modified":1761641306744},{"_id":"public/posts/38059bce.html","hash":"df57a15e2d5893693787432550f8f129b32b3c68","modified":1761641306744},{"_id":"public/posts/121cc63b.html","hash":"759f2a547f1bb17c8fc21085d32085640a156fc9","modified":1761641306744},{"_id":"public/posts/d940f18d.html","hash":"708a7c18af7672cbb322ff53c0556cbe51440437","modified":1761641306744},{"_id":"public/posts/43a71ae4.html","hash":"80b08ae7cee17f32ebf07a94432e154aa7b596d3","modified":1761641306744},{"_id":"public/posts/f91535f.html","hash":"89221b0504407b5e4eebf7fab574c4920b97eaa6","modified":1761641306744},{"_id":"public/posts/43ade6e4.html","hash":"d76299a6d49fc7bef1bf1452db08bc4d0682c507","modified":1761641306744},{"_id":"public/posts/6ff8c531.html","hash":"f06093054a045d07ea9da8525178323c0a787e45","modified":1761641306744},{"_id":"public/posts/70e3fcb2.html","hash":"4a54ebdfdc14c1112c3fbc3e3d3460a7fa5d06cf","modified":1761641306744},{"_id":"public/posts/cc7c02e8.html","hash":"ae4a1d55fef2e98d187d6c0cf0aeeae1f9710a66","modified":1761641306744},{"_id":"public/posts/55755352.html","hash":"1d1c0409f5cbd5034d09fdb1c94ddc2bc49ae73e","modified":1761641306744},{"_id":"public/archives/index.html","hash":"37e7329498fc04b16cc250db3ecacb3e75b6cbe4","modified":1761641306744},{"_id":"public/archives/2025/index.html","hash":"37e7329498fc04b16cc250db3ecacb3e75b6cbe4","modified":1761641306744},{"_id":"public/archives/2025/10/index.html","hash":"37e7329498fc04b16cc250db3ecacb3e75b6cbe4","modified":1761641306744},{"_id":"public/index.html","hash":"67d271440736af6c2559274e380287384ba49894","modified":1761641306744},{"_id":"public/categories/Java-基础篇/index.html","hash":"ca17182991f6f19b0591f3a995688d29696745ba","modified":1761641306744},{"_id":"public/categories/MySQL-篇/index.html","hash":"a7a11dc5757f3647a4aa3c65ddc1e7dea48a6b0d","modified":1761641306744},{"_id":"public/categories/操作系统/index.html","hash":"30b9a0c1c6da1100a2f72178fc5ff579b837a2b4","modified":1761641306744},{"_id":"public/categories/测试/index.html","hash":"6b515c9be3b3205754840779a94e9a9325ec73a5","modified":1761641306744},{"_id":"public/tags/ArrayList/index.html","hash":"f1ac16bd30fcc7948adbd4f97cf28241a3d55fdd","modified":1761641306744},{"_id":"public/tags/事务/index.html","hash":"a816ea21952f717b4899dc661533d2bc95ad3cd7","modified":1761641306744},{"_id":"public/tags/MySQL的MVCC/index.html","hash":"fde0213e6614c748593c75d733984db40a3aad68","modified":1761641306744},{"_id":"public/tags/HashMap/index.html","hash":"f261b66f00a7ff6380420f7349b20bf9af4eba0a","modified":1761641306744},{"_id":"public/tags/MySQL索引/index.html","hash":"a6294c4d00e15fe3fb9d630461a42a74bed08763","modified":1761641306744},{"_id":"public/tags/MySQL锁/index.html","hash":"82ac68c1ab5c9a367ba4a7268838351b3c71cf80","modified":1761641306744},{"_id":"public/tags/操作系统/index.html","hash":"3520ce699cab38e85550665068474de502cad05f","modified":1761641306744},{"_id":"public/tags/String/index.html","hash":"b49f90a9ac42d97cd88a6cf68a3bedbd27c79b42","modified":1761641306744},{"_id":"public/tags/测试/index.html","hash":"1343df69b719e1856fa5854795a67e8c176367a8","modified":1761641306744},{"_id":"public/images/loading-d.gif","hash":"9c840c5c3e7b97a184deb390df2f6926d6161708","modified":1761641306744},{"_id":"public/css/main.css","hash":"78239bb7251cb0c34f5f35343708066194f54d2d","modified":1761641306744},{"_id":"public/js/main.js","hash":"a9cb52bac89783c3957c77cbb4ffc8fbb93a92a1","modified":1761641306744},{"_id":"public/js/lib/highlight.js","hash":"a9ee0fd40904e2e50ab5ecab4c718a49c095836f","modified":1761641306744},{"_id":"public/js/lib/crypto.js","hash":"bc4a0c41cf5b61faa204a2a820fc042b563142cf","modified":1761641306744},{"_id":"public/js/lib/math.js","hash":"24c182cd3f5dd1c0f0192ca4cc143de71e076d2a","modified":1761641306744},{"_id":"public/js/lib/home.js","hash":"c2bf22772fd052cff88a9b5f547a30a6eb97e545","modified":1761641306744},{"_id":"public/js/lib/preview.js","hash":"595cfc3aff107b8dd0fdda214995c6f1bb5be39a","modified":1761641306744},{"_id":"public/js/lib/search.js","hash":"b631b87fa126a9a4a81b60b1a0516f765879963e","modified":1761641306744},{"_id":"public/images/loading.gif","hash":"1e9f899b335bb6325a36c2580430ce10553439d3","modified":1761641306744},{"_id":"public/images/avatar-d.jpg","hash":"cd5b921252d1a4f15e17858f4f816ba768a6acf7","modified":1761641306744},{"_id":"public/images/background/02.jpeg","hash":"fb0379e3d28922d59ca55822765033ed49bbf87c","modified":1761641306744},{"_id":"public/images/background/04.png","hash":"f228f5ebb89143a7debac551f21289719260ae77","modified":1761641306744},{"_id":"public/images/avatar.png","hash":"e724e0a002bc1cc2f7bfdb5a3eed547b6955bcd0","modified":1761641306744},{"_id":"public/images/background/03.png","hash":"8ed8cd24312f35f231a6626f10ab1fc52cde2079","modified":1761641306744},{"_id":"public/images/background/01.png","hash":"9045362ac3960c29f11c40bda42cf6406ec2cdcc","modified":1761641306744}],"Category":[{"name":"Java 基础篇","_id":"cuidpIMMiq2QOdY5KI9vvtMnD"},{"name":"MySQL 篇","_id":"cuidSwlKlNrpVd-Y6rZs9gDGw"},{"name":"操作系统","_id":"cuid_EHLmSU2kdMH7abaloc8T"},{"name":"测试","_id":"cuidHYwoa11LEIMwE6Cw32u6Z"}],"Data":[],"Page":[{"title":"Tags","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: Tags\n# 用来表示页面的类型，这是tags类型，表示使用layout中的tags模板\ntype: categories\n---","date":"2025-10-27T01:02:26.922Z","updated":"2025-10-27T01:02:26.922Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cuidap5U9pGrBK3XI-o4hwoRu","content":"","excerpt":"","more":""},{"title":"文章总览","type":"echarts","_content":"{% heatmapchart forest 2025 no-footer%} 文章提交热力图 {% endheatmapchart %}\n\n","source":"echarts/index.md","raw":"---\ntitle: 文章总览\ntype: echarts\n---\n{% heatmapchart forest 2025 no-footer%} 文章提交热力图 {% endheatmapchart %}\n\n","date":"2025-10-27T03:16:20.979Z","updated":"2025-10-27T03:16:20.979Z","path":"echarts/index.html","comments":1,"layout":"page","_id":"cuid1xsEX-oSCF2bdrCDIIzH7","content":"\n        <script>\n            document.addEventListener('DOMContentLoaded', function() {\n                const heatmapChartDom = document.getElementById('heatmapChart-0');\n                if (heatmapChartDom) {\n                    const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;\n                    const backgroundColor = isDarkMode ? '#333' : 'transparent';\n                    let heatmapChart = echarts.init(heatmapChartDom, isDarkMode ? 'dark' : 'light');\n                    const cellSize = [16, 16];\n\n                    const groupedData = {\"2025\":[[\"2025-10-27\",3],[\"2025-10-28\",5],[\"2025-10-18\",2]]};\n                    const years = Object.keys(groupedData).reverse();\n                    const initYear = '2025' || years[0];\n\n                    // Define color themes\n                    const themes = {\n                        oceanic: ['#A6D8E8', '#6FB3D2', '#4A90BF', '#2E6A8E', '#1A4461'],\n                        forest: ['#ACE7AE', '#8FD694', '#69C16D', '#549F57', '#3A7D3E'],\n                        sunset: ['#FFD1A6', '#FFA07A', '#FF6F52', '#D94A3D', '#A62B2B'],\n                        earthy: ['#E3C8A8', '#C4A076', '#A57C52', '#7A5A3A', '#4E3A28'],\n                        pastel: ['#F5D5E6', '#E8B8D0', '#D18FB8', '#A86A8E', '#7A4A61'],\n                        golden: ['#FFEBB5', '#FFD966', '#FFB74D', '#D18F4A', '#A66B2B'],\n                        berry: ['#F4C2D7', '#E88BB3', '#D94A7A', '#A62B5C', '#7A1F3D'],\n                        charcoal: ['#E0E0E0', '#9E9E9E', '#616161', '#424242', '#212121'],\n                    };\n\n                    // Function to get a random theme\n                    function getRandomTheme() {\n                        const themeKeys = Object.keys(themes);\n                        const randomKey = themeKeys[Math.floor(Math.random() * themeKeys.length)];\n                        return themes[randomKey];\n                    }\n\n                    // Use the specified theme or default to 'random'\n                    const colors = themes['forest'.toLowerCase()] || getRandomTheme();\n\n                    const chartOptions = {\n                        backgroundColor: backgroundColor,\n                        tooltip: {\n                            position: 'top',\n                            confine: true,\n                            formatter: params => `${params.value[0]}: ${params.value[1]} Article${params.value[1] !== 1 ? 's' : ''}`,\n                        },\n                        calendar: {\n                            top: '13%',\n                            left: '2%',\n                            right: '8%',\n                            range: initYear,\n                            cellSize: cellSize,\n                            splitLine: { lineStyle: { color: '#E0E0E0', width: 1 } },\n                            itemStyle: { borderWidth: 1, borderColor: '#E0E0E0', color: backgroundColor },\n                            dayLabel: { show: false },\n                            monthLabel: { show: true },\n                            yearLabel: { show: false },\n                        },\n                        visualMap: {\n                            show: true,\n                            right: '8%',\n                            bottom: '5%',\n                            type: 'piecewise',\n                            orient: 'horizontal',\n                            text: ['More', 'Less'],\n                            min: 0,\n                            max: Math.max(...groupedData[initYear].map(item => item[1])),\n                            inRange: { color: colors },\n                        },\n                        legend: {\n                            type: 'scroll',\n                            icon: 'none',\n                            data: years,\n                            orient: 'vertical',\n                            top: '5%',\n                            right: 'right',\n                            itemWidth: 20,\n                            itemHeight: 20,\n                            itemGap: 10,\n                            pageIconSize: 10,\n                            pageTextStyle: { fontSize: 14 },\n                            selectedMode: 'single',\n                        },\n                        series: years.map(year => ({\n                            type: 'heatmap',\n                            coordinateSystem: 'calendar',\n                            data: groupedData[year],\n                            name: year,\n                            emphasis: { disabled: true },\n                            silent: year !== initYear,\n                        })),\n                    };\n\n                    heatmapChart.setOption(chartOptions);\n\n                    heatmapChart.dispatchAction({\n                        type: 'legendSelect',\n                        name: initYear,\n                    });\n\n                    // Function to handle legend selection changes\n                    const handleLegendSelectChanged = function(params) {\n                        const selectedYear = Object.keys(params.selected).find(key => params.selected[key]);\n                        if (selectedYear && groupedData[selectedYear]) {\n                            heatmapChart.setOption({\n                                calendar: { range: selectedYear },\n                                visualMap: {\n                                    max: Math.max(...groupedData[selectedYear].map(item => item[1])),\n                                },\n                                series: years.map(year => ({\n                                    type: 'heatmap',\n                                    coordinateSystem: 'calendar',\n                                    data: groupedData[year],\n                                    name: year,\n                                    emphasis: { disabled: true },\n                                    silent: year !== selectedYear,\n                                })),\n                            });\n                        }\n                    };\n                    \n                    const handleClick = function(params) {\n                        if (params.componentType === 'series') {\n                            const [year, month] = params.value[0].split('-');\n                            window.location.href = '/archives/' + year + '/' + month;\n                        }\n                    };\n\n                    heatmapChart.on('legendselectchanged', handleLegendSelectChanged);\n                    heatmapChart.on('click', handleClick);\n\n                    // Listen for theme changes\n                    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (event) => {\n                        heatmapChart.dispose();\n                        heatmapChart = echarts.init(heatmapChartDom, event.matches ? 'dark' : 'light');\n                        const newBackgroundColor = event.matches ? '#333' : 'transparent';\n                        chartOptions.backgroundColor = newBackgroundColor;\n                        chartOptions.calendar.itemStyle.color = newBackgroundColor;\n                        heatmapChart.setOption(chartOptions);\n                        \n                        // Re-select the initial year\n                        heatmapChart.dispatchAction({\n                            type: 'legendSelect',\n                            name: initYear,\n                        });\n\n                        // Reattach the event listeners\n                        heatmapChart.on('legendselectchanged', handleLegendSelectChanged);\n                        heatmapChart.on('click', handleClick);\n                    });\n                }\n            });\n        </script>\n        <div style=\"width: 100%\">\n            <!-- Title -->\n            \n        <div style=\"text-align: center; font-size: 24px; font-weight: bold; margin-bottom: 10px;\">\n            文章提交热力图 \n        </div>\n    \n            <!-- Heatmap Chart -->\n            <div id=\"heatmapChart-0\" style=\"width: 100%; height: 200px; overflow-x: auto; overflow-y: hidden;\"></div>\n            <!-- Footer -->\n            \n        </div>\n    \n\n","excerpt":"","more":"\n        <script>\n            document.addEventListener('DOMContentLoaded', function() {\n                const heatmapChartDom = document.getElementById('heatmapChart-0');\n                if (heatmapChartDom) {\n                    const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;\n                    const backgroundColor = isDarkMode ? '#333' : 'transparent';\n                    let heatmapChart = echarts.init(heatmapChartDom, isDarkMode ? 'dark' : 'light');\n                    const cellSize = [16, 16];\n\n                    const groupedData = {\"2025\":[[\"2025-10-27\",3],[\"2025-10-28\",5],[\"2025-10-18\",2]]};\n                    const years = Object.keys(groupedData).reverse();\n                    const initYear = '2025' || years[0];\n\n                    // Define color themes\n                    const themes = {\n                        oceanic: ['#A6D8E8', '#6FB3D2', '#4A90BF', '#2E6A8E', '#1A4461'],\n                        forest: ['#ACE7AE', '#8FD694', '#69C16D', '#549F57', '#3A7D3E'],\n                        sunset: ['#FFD1A6', '#FFA07A', '#FF6F52', '#D94A3D', '#A62B2B'],\n                        earthy: ['#E3C8A8', '#C4A076', '#A57C52', '#7A5A3A', '#4E3A28'],\n                        pastel: ['#F5D5E6', '#E8B8D0', '#D18FB8', '#A86A8E', '#7A4A61'],\n                        golden: ['#FFEBB5', '#FFD966', '#FFB74D', '#D18F4A', '#A66B2B'],\n                        berry: ['#F4C2D7', '#E88BB3', '#D94A7A', '#A62B5C', '#7A1F3D'],\n                        charcoal: ['#E0E0E0', '#9E9E9E', '#616161', '#424242', '#212121'],\n                    };\n\n                    // Function to get a random theme\n                    function getRandomTheme() {\n                        const themeKeys = Object.keys(themes);\n                        const randomKey = themeKeys[Math.floor(Math.random() * themeKeys.length)];\n                        return themes[randomKey];\n                    }\n\n                    // Use the specified theme or default to 'random'\n                    const colors = themes['forest'.toLowerCase()] || getRandomTheme();\n\n                    const chartOptions = {\n                        backgroundColor: backgroundColor,\n                        tooltip: {\n                            position: 'top',\n                            confine: true,\n                            formatter: params => `${params.value[0]}: ${params.value[1]} Article${params.value[1] !== 1 ? 's' : ''}`,\n                        },\n                        calendar: {\n                            top: '13%',\n                            left: '2%',\n                            right: '8%',\n                            range: initYear,\n                            cellSize: cellSize,\n                            splitLine: { lineStyle: { color: '#E0E0E0', width: 1 } },\n                            itemStyle: { borderWidth: 1, borderColor: '#E0E0E0', color: backgroundColor },\n                            dayLabel: { show: false },\n                            monthLabel: { show: true },\n                            yearLabel: { show: false },\n                        },\n                        visualMap: {\n                            show: true,\n                            right: '8%',\n                            bottom: '5%',\n                            type: 'piecewise',\n                            orient: 'horizontal',\n                            text: ['More', 'Less'],\n                            min: 0,\n                            max: Math.max(...groupedData[initYear].map(item => item[1])),\n                            inRange: { color: colors },\n                        },\n                        legend: {\n                            type: 'scroll',\n                            icon: 'none',\n                            data: years,\n                            orient: 'vertical',\n                            top: '5%',\n                            right: 'right',\n                            itemWidth: 20,\n                            itemHeight: 20,\n                            itemGap: 10,\n                            pageIconSize: 10,\n                            pageTextStyle: { fontSize: 14 },\n                            selectedMode: 'single',\n                        },\n                        series: years.map(year => ({\n                            type: 'heatmap',\n                            coordinateSystem: 'calendar',\n                            data: groupedData[year],\n                            name: year,\n                            emphasis: { disabled: true },\n                            silent: year !== initYear,\n                        })),\n                    };\n\n                    heatmapChart.setOption(chartOptions);\n\n                    heatmapChart.dispatchAction({\n                        type: 'legendSelect',\n                        name: initYear,\n                    });\n\n                    // Function to handle legend selection changes\n                    const handleLegendSelectChanged = function(params) {\n                        const selectedYear = Object.keys(params.selected).find(key => params.selected[key]);\n                        if (selectedYear && groupedData[selectedYear]) {\n                            heatmapChart.setOption({\n                                calendar: { range: selectedYear },\n                                visualMap: {\n                                    max: Math.max(...groupedData[selectedYear].map(item => item[1])),\n                                },\n                                series: years.map(year => ({\n                                    type: 'heatmap',\n                                    coordinateSystem: 'calendar',\n                                    data: groupedData[year],\n                                    name: year,\n                                    emphasis: { disabled: true },\n                                    silent: year !== selectedYear,\n                                })),\n                            });\n                        }\n                    };\n                    \n                    const handleClick = function(params) {\n                        if (params.componentType === 'series') {\n                            const [year, month] = params.value[0].split('-');\n                            window.location.href = '/archives/' + year + '/' + month;\n                        }\n                    };\n\n                    heatmapChart.on('legendselectchanged', handleLegendSelectChanged);\n                    heatmapChart.on('click', handleClick);\n\n                    // Listen for theme changes\n                    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (event) => {\n                        heatmapChart.dispose();\n                        heatmapChart = echarts.init(heatmapChartDom, event.matches ? 'dark' : 'light');\n                        const newBackgroundColor = event.matches ? '#333' : 'transparent';\n                        chartOptions.backgroundColor = newBackgroundColor;\n                        chartOptions.calendar.itemStyle.color = newBackgroundColor;\n                        heatmapChart.setOption(chartOptions);\n                        \n                        // Re-select the initial year\n                        heatmapChart.dispatchAction({\n                            type: 'legendSelect',\n                            name: initYear,\n                        });\n\n                        // Reattach the event listeners\n                        heatmapChart.on('legendselectchanged', handleLegendSelectChanged);\n                        heatmapChart.on('click', handleClick);\n                    });\n                }\n            });\n        </script>\n        <div style=\"width: 100%\">\n            <!-- Title -->\n            \n        <div style=\"text-align: center; font-size: 24px; font-weight: bold; margin-bottom: 10px;\">\n            文章提交热力图 \n        </div>\n    \n            <!-- Heatmap Chart -->\n            <div id=\"heatmapChart-0\" style=\"width: 100%; height: 200px; overflow-x: auto; overflow-y: hidden;\"></div>\n            <!-- Footer -->\n            \n        </div>\n    \n\n"},{"title":"自定义页面","type":"custom","_content":"{% heatmapchart %}Blog Heatmap{% endheatmapchart %}","source":"custom/index.md","raw":"---\ntitle: 自定义页面\ntype: custom\n---\n{% heatmapchart %}Blog Heatmap{% endheatmapchart %}","date":"2025-10-27T02:40:47.196Z","updated":"2025-10-27T02:40:47.196Z","path":"custom/index.html","comments":1,"layout":"page","_id":"cuidZ90XpPOkiLs6glN7dMpyC","content":"\n        <script>\n            document.addEventListener('DOMContentLoaded', function() {\n                const heatmapChartDom = document.getElementById('heatmapChart-1');\n                if (heatmapChartDom) {\n                    const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;\n                    const backgroundColor = isDarkMode ? '#333' : 'transparent';\n                    let heatmapChart = echarts.init(heatmapChartDom, isDarkMode ? 'dark' : 'light');\n                    const cellSize = [16, 16];\n\n                    const groupedData = {\"2025\":[[\"2025-10-27\",3],[\"2025-10-28\",5],[\"2025-10-18\",2]]};\n                    const years = Object.keys(groupedData).reverse();\n                    const initYear = '2025' || years[0];\n\n                    // Define color themes\n                    const themes = {\n                        oceanic: ['#A6D8E8', '#6FB3D2', '#4A90BF', '#2E6A8E', '#1A4461'],\n                        forest: ['#ACE7AE', '#8FD694', '#69C16D', '#549F57', '#3A7D3E'],\n                        sunset: ['#FFD1A6', '#FFA07A', '#FF6F52', '#D94A3D', '#A62B2B'],\n                        earthy: ['#E3C8A8', '#C4A076', '#A57C52', '#7A5A3A', '#4E3A28'],\n                        pastel: ['#F5D5E6', '#E8B8D0', '#D18FB8', '#A86A8E', '#7A4A61'],\n                        golden: ['#FFEBB5', '#FFD966', '#FFB74D', '#D18F4A', '#A66B2B'],\n                        berry: ['#F4C2D7', '#E88BB3', '#D94A7A', '#A62B5C', '#7A1F3D'],\n                        charcoal: ['#E0E0E0', '#9E9E9E', '#616161', '#424242', '#212121'],\n                    };\n\n                    // Function to get a random theme\n                    function getRandomTheme() {\n                        const themeKeys = Object.keys(themes);\n                        const randomKey = themeKeys[Math.floor(Math.random() * themeKeys.length)];\n                        return themes[randomKey];\n                    }\n\n                    // Use the specified theme or default to 'random'\n                    const colors = themes['random'.toLowerCase()] || getRandomTheme();\n\n                    const chartOptions = {\n                        backgroundColor: backgroundColor,\n                        tooltip: {\n                            position: 'top',\n                            confine: true,\n                            formatter: params => `${params.value[0]}: ${params.value[1]} Article${params.value[1] !== 1 ? 's' : ''}`,\n                        },\n                        calendar: {\n                            top: '13%',\n                            left: '2%',\n                            right: '8%',\n                            range: initYear,\n                            cellSize: cellSize,\n                            splitLine: { lineStyle: { color: '#E0E0E0', width: 1 } },\n                            itemStyle: { borderWidth: 1, borderColor: '#E0E0E0', color: backgroundColor },\n                            dayLabel: { show: false },\n                            monthLabel: { show: true },\n                            yearLabel: { show: false },\n                        },\n                        visualMap: {\n                            show: true,\n                            right: '8%',\n                            bottom: '5%',\n                            type: 'piecewise',\n                            orient: 'horizontal',\n                            text: ['More', 'Less'],\n                            min: 0,\n                            max: Math.max(...groupedData[initYear].map(item => item[1])),\n                            inRange: { color: colors },\n                        },\n                        legend: {\n                            type: 'scroll',\n                            icon: 'none',\n                            data: years,\n                            orient: 'vertical',\n                            top: '5%',\n                            right: 'right',\n                            itemWidth: 20,\n                            itemHeight: 20,\n                            itemGap: 10,\n                            pageIconSize: 10,\n                            pageTextStyle: { fontSize: 14 },\n                            selectedMode: 'single',\n                        },\n                        series: years.map(year => ({\n                            type: 'heatmap',\n                            coordinateSystem: 'calendar',\n                            data: groupedData[year],\n                            name: year,\n                            emphasis: { disabled: true },\n                            silent: year !== initYear,\n                        })),\n                    };\n\n                    heatmapChart.setOption(chartOptions);\n\n                    heatmapChart.dispatchAction({\n                        type: 'legendSelect',\n                        name: initYear,\n                    });\n\n                    // Function to handle legend selection changes\n                    const handleLegendSelectChanged = function(params) {\n                        const selectedYear = Object.keys(params.selected).find(key => params.selected[key]);\n                        if (selectedYear && groupedData[selectedYear]) {\n                            heatmapChart.setOption({\n                                calendar: { range: selectedYear },\n                                visualMap: {\n                                    max: Math.max(...groupedData[selectedYear].map(item => item[1])),\n                                },\n                                series: years.map(year => ({\n                                    type: 'heatmap',\n                                    coordinateSystem: 'calendar',\n                                    data: groupedData[year],\n                                    name: year,\n                                    emphasis: { disabled: true },\n                                    silent: year !== selectedYear,\n                                })),\n                            });\n                        }\n                    };\n                    \n                    const handleClick = function(params) {\n                        if (params.componentType === 'series') {\n                            const [year, month] = params.value[0].split('-');\n                            window.location.href = '/archives/' + year + '/' + month;\n                        }\n                    };\n\n                    heatmapChart.on('legendselectchanged', handleLegendSelectChanged);\n                    heatmapChart.on('click', handleClick);\n\n                    // Listen for theme changes\n                    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (event) => {\n                        heatmapChart.dispose();\n                        heatmapChart = echarts.init(heatmapChartDom, event.matches ? 'dark' : 'light');\n                        const newBackgroundColor = event.matches ? '#333' : 'transparent';\n                        chartOptions.backgroundColor = newBackgroundColor;\n                        chartOptions.calendar.itemStyle.color = newBackgroundColor;\n                        heatmapChart.setOption(chartOptions);\n                        \n                        // Re-select the initial year\n                        heatmapChart.dispatchAction({\n                            type: 'legendSelect',\n                            name: initYear,\n                        });\n\n                        // Reattach the event listeners\n                        heatmapChart.on('legendselectchanged', handleLegendSelectChanged);\n                        heatmapChart.on('click', handleClick);\n                    });\n                }\n            });\n        </script>\n        <div style=\"width: 100%\">\n            <!-- Title -->\n            \n        <div style=\"text-align: center; font-size: 24px; font-weight: bold; margin-bottom: 10px;\">\n            Blog Heatmap\n        </div>\n    \n            <!-- Heatmap Chart -->\n            <div id=\"heatmapChart-1\" style=\"width: 100%; height: 200px; overflow-x: auto; overflow-y: hidden;\"></div>\n            <!-- Footer -->\n            \n        <div style=\"text-align: center; font-size: 12px; color: #666; margin-top: 10px; margin-bottom: 20px;\">\n            Powered by <a href=\"https://github.com/erispyu/hexo-stats-echarts\" style=\"color: inherit; text-decoration: none;\" target=\"_blank\">hexo-stats-echarts</a>\n        </div>\n    \n        </div>\n    ","excerpt":"","more":"\n        <script>\n            document.addEventListener('DOMContentLoaded', function() {\n                const heatmapChartDom = document.getElementById('heatmapChart-1');\n                if (heatmapChartDom) {\n                    const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;\n                    const backgroundColor = isDarkMode ? '#333' : 'transparent';\n                    let heatmapChart = echarts.init(heatmapChartDom, isDarkMode ? 'dark' : 'light');\n                    const cellSize = [16, 16];\n\n                    const groupedData = {\"2025\":[[\"2025-10-27\",3],[\"2025-10-28\",5],[\"2025-10-18\",2]]};\n                    const years = Object.keys(groupedData).reverse();\n                    const initYear = '2025' || years[0];\n\n                    // Define color themes\n                    const themes = {\n                        oceanic: ['#A6D8E8', '#6FB3D2', '#4A90BF', '#2E6A8E', '#1A4461'],\n                        forest: ['#ACE7AE', '#8FD694', '#69C16D', '#549F57', '#3A7D3E'],\n                        sunset: ['#FFD1A6', '#FFA07A', '#FF6F52', '#D94A3D', '#A62B2B'],\n                        earthy: ['#E3C8A8', '#C4A076', '#A57C52', '#7A5A3A', '#4E3A28'],\n                        pastel: ['#F5D5E6', '#E8B8D0', '#D18FB8', '#A86A8E', '#7A4A61'],\n                        golden: ['#FFEBB5', '#FFD966', '#FFB74D', '#D18F4A', '#A66B2B'],\n                        berry: ['#F4C2D7', '#E88BB3', '#D94A7A', '#A62B5C', '#7A1F3D'],\n                        charcoal: ['#E0E0E0', '#9E9E9E', '#616161', '#424242', '#212121'],\n                    };\n\n                    // Function to get a random theme\n                    function getRandomTheme() {\n                        const themeKeys = Object.keys(themes);\n                        const randomKey = themeKeys[Math.floor(Math.random() * themeKeys.length)];\n                        return themes[randomKey];\n                    }\n\n                    // Use the specified theme or default to 'random'\n                    const colors = themes['random'.toLowerCase()] || getRandomTheme();\n\n                    const chartOptions = {\n                        backgroundColor: backgroundColor,\n                        tooltip: {\n                            position: 'top',\n                            confine: true,\n                            formatter: params => `${params.value[0]}: ${params.value[1]} Article${params.value[1] !== 1 ? 's' : ''}`,\n                        },\n                        calendar: {\n                            top: '13%',\n                            left: '2%',\n                            right: '8%',\n                            range: initYear,\n                            cellSize: cellSize,\n                            splitLine: { lineStyle: { color: '#E0E0E0', width: 1 } },\n                            itemStyle: { borderWidth: 1, borderColor: '#E0E0E0', color: backgroundColor },\n                            dayLabel: { show: false },\n                            monthLabel: { show: true },\n                            yearLabel: { show: false },\n                        },\n                        visualMap: {\n                            show: true,\n                            right: '8%',\n                            bottom: '5%',\n                            type: 'piecewise',\n                            orient: 'horizontal',\n                            text: ['More', 'Less'],\n                            min: 0,\n                            max: Math.max(...groupedData[initYear].map(item => item[1])),\n                            inRange: { color: colors },\n                        },\n                        legend: {\n                            type: 'scroll',\n                            icon: 'none',\n                            data: years,\n                            orient: 'vertical',\n                            top: '5%',\n                            right: 'right',\n                            itemWidth: 20,\n                            itemHeight: 20,\n                            itemGap: 10,\n                            pageIconSize: 10,\n                            pageTextStyle: { fontSize: 14 },\n                            selectedMode: 'single',\n                        },\n                        series: years.map(year => ({\n                            type: 'heatmap',\n                            coordinateSystem: 'calendar',\n                            data: groupedData[year],\n                            name: year,\n                            emphasis: { disabled: true },\n                            silent: year !== initYear,\n                        })),\n                    };\n\n                    heatmapChart.setOption(chartOptions);\n\n                    heatmapChart.dispatchAction({\n                        type: 'legendSelect',\n                        name: initYear,\n                    });\n\n                    // Function to handle legend selection changes\n                    const handleLegendSelectChanged = function(params) {\n                        const selectedYear = Object.keys(params.selected).find(key => params.selected[key]);\n                        if (selectedYear && groupedData[selectedYear]) {\n                            heatmapChart.setOption({\n                                calendar: { range: selectedYear },\n                                visualMap: {\n                                    max: Math.max(...groupedData[selectedYear].map(item => item[1])),\n                                },\n                                series: years.map(year => ({\n                                    type: 'heatmap',\n                                    coordinateSystem: 'calendar',\n                                    data: groupedData[year],\n                                    name: year,\n                                    emphasis: { disabled: true },\n                                    silent: year !== selectedYear,\n                                })),\n                            });\n                        }\n                    };\n                    \n                    const handleClick = function(params) {\n                        if (params.componentType === 'series') {\n                            const [year, month] = params.value[0].split('-');\n                            window.location.href = '/archives/' + year + '/' + month;\n                        }\n                    };\n\n                    heatmapChart.on('legendselectchanged', handleLegendSelectChanged);\n                    heatmapChart.on('click', handleClick);\n\n                    // Listen for theme changes\n                    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (event) => {\n                        heatmapChart.dispose();\n                        heatmapChart = echarts.init(heatmapChartDom, event.matches ? 'dark' : 'light');\n                        const newBackgroundColor = event.matches ? '#333' : 'transparent';\n                        chartOptions.backgroundColor = newBackgroundColor;\n                        chartOptions.calendar.itemStyle.color = newBackgroundColor;\n                        heatmapChart.setOption(chartOptions);\n                        \n                        // Re-select the initial year\n                        heatmapChart.dispatchAction({\n                            type: 'legendSelect',\n                            name: initYear,\n                        });\n\n                        // Reattach the event listeners\n                        heatmapChart.on('legendselectchanged', handleLegendSelectChanged);\n                        heatmapChart.on('click', handleClick);\n                    });\n                }\n            });\n        </script>\n        <div style=\"width: 100%\">\n            <!-- Title -->\n            \n        <div style=\"text-align: center; font-size: 24px; font-weight: bold; margin-bottom: 10px;\">\n            Blog Heatmap\n        </div>\n    \n            <!-- Heatmap Chart -->\n            <div id=\"heatmapChart-1\" style=\"width: 100%; height: 200px; overflow-x: auto; overflow-y: hidden;\"></div>\n            <!-- Footer -->\n            \n        <div style=\"text-align: center; font-size: 12px; color: #666; margin-top: 10px; margin-bottom: 20px;\">\n            Powered by <a href=\"https://github.com/erispyu/hexo-stats-echarts\" style=\"color: inherit; text-decoration: none;\" target=\"_blank\">hexo-stats-echarts</a>\n        </div>\n    \n        </div>\n    "},{"title":"Tags","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: Tags\n# 用来表示页面的类型，这是tags类型，表示使用layout中的tags模板\ntype: tags\n---","date":"2025-10-27T01:02:26.940Z","updated":"2025-10-27T01:02:26.940Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cuidd7a1wIekZrfoTHmmF0BN3","content":"","excerpt":"","more":""}],"Post":[{"title":"ArrayList集合","description":"文章缩略，支持 `Markdown` **文档格式**\n","pinned":0,"lang":"zh","type":"post","wordCount":49,"charCount":1853,"imgCount":0,"vidCount":0,"wsCount":0,"cbCount":0,"readTime":"约24秒","abbrlink":"6ff8c531","date":"2025-10-27T14:25:43.000Z","_content":"### 1、ArrayList 的底层数据结构是什么？\n\n​      ArrayList 的底层数据结构是 Object 类型的 elementData 数组，该数组具有动态可扩容机制，即动态可扩容数组。该数组由 transient 修饰，标记为不可序列化，用来解决在数组序列化时，会将空元素也序列化的问题。同时实现了 writeObject 和 readObject 方法，来手动实现有效元素的序列化和反序列化。\n\n### 2、ArrayList 如何添加元素？扩容机制是什么？\n\n#####       1）添加元素：\n\n​            通过 add() 方法用来添加元素，而 add() 方法，实际上是调用内部私有的add() 方法，向elementData 数组中添加元素。\n\n#####       2）扩容机制：\n\n- 首先，检查数组当前的有效元素的数量是否等于elementData的总长度。\n    - 如果不相等，说明数组未满，则直接添加，并将size的大小加一。\n    - 如果相等，说明当前的空间已经用完，则进入gow()，并将扩容后的数组赋值给elementData数组，然后继续将元素放入，size的大小加一。\n        - 对于grow()方法，入参为最小扩容量，即扩容后的大小一定大于等于这个入参的值，具体的实现为，先获取到数组的整个长度，然后将数组的长度增加为原来的1.5倍后，与入参，即最小扩容量相比。\n            - 如果大于等于入参，那末直接用1.5倍的值作为新数组长度。\n            - 反之直接用最小扩容量最为新数组的长度。\n            - 最后调用Arrays的copy()方法，将数组进行扩容，而这个方法本质是调用底层的System.arraycopy的本地方法来进行数组的扩容。\n\n### 3、ArrayList 是否线程安全？如何解决？\n\n#####       1）线程安全：\n\n​           是非线程安全的，其根本原因是内部没有同步机制，所有的操作都是共享数组和计数器，关键操作并没有原子性。多线程模式下容易出现ConcurrentModificationException 等异常。\n\n#####       2）解决方案：\n\n​           ① 对于轻度并发场景，使用并发工具包Collections的SynchronizedList() 方法，构造线程安全的集合，原理就是通过包装器为所有的方法都加上Synchronized锁，但是，并发性能低，迭代时必须显示的加上锁，因为并发工具包只是为独立的方法加上了 Synchroized(mutex)，而迭代时的多个操作，涉及hasNext、next操作，这些组合操作本身并不是原子的，因此在迭代时，需要显示的加上锁。\n\n​           ② CopyOnWriteArrayList 适用于读多写少的情况，原理就是，在写操作时，复制整个数组，同时数组的长度加1，在新数组的最后位置加上一个元素，再用新数组替换旧数组。而在添加的过程中，在jdk 9 之前用的都是 ReentrantLook 锁，而在jdk 9 之后，用的就是Synchroized。\n\n​           ③ Vector，是线程安全的，原理就是每个方法都用 Synchroized 锁，但是性能较低，迭代器问题未解决。由于锁的力度比较粗，所有公共方法都被Synchroized 修饰，单线程每次调用都有锁的开销，而在多线程模式下，即使是读操作之间也会互斥，无法并发。并且默认扩容为原来的2倍，容易造成内存泄漏。同时迭代器也没有实现线程安全。\n\n​           ④ 手动同步。\n\n### 4、为什么ArrayList扩容为原来的1.5倍？\n\n​      扩容较大会有OOM以及内存浪费，扩容较小会有多次扩容，浪费性能。而1.5是在扩容频率适中，空间利用率最高的大小。\n\n### 5、如何在迭代过程中删除元素？\n\n​      调用迭代器自身提供的remove()方法，进行删除元素，原理是在调用过程中，会更新modCount的值，不会触发快速失败。\n\n### 6、modCount 字段的作用是什么？\n\n​      modCount 是结构修改哨兵，任何有关修改数组的结构的操作都会导致modCount加1，包括添加元素，删除元素，但是替换元素不会导致modCount加1。当在迭代过程中，会先记录modCount的值，每次迭代调用next()方法都会对比是否相同，不相同直接抛出ConcurrantModificationException。多线程下，防止一个线程迭代，一个线程修改的情况，单线程中以最低的成本实现快速失败，防止数据不一致。\n\n### 7、快速失败 + 安全失败\n\n​    *快速失败*：通过检测集合的并发修改，及时抛出异常来避免潜在的逻辑错误。即：通过修改计数器 modCont 记录修改次数，当出现不一致的情况时，立即抛出 `ConcurrentModificationException` 异常。但它**不解决线程安全问题**，仅用于快速暴露问题。\n\n*安全失败*：例如 `CopyOnWriteArrayList` 在创建迭代器时，会生成当前集合的快照，遍历通过这个快照进行遍历。因此，当迭代过程中进行修改时，修改的结果不会影响快照的内容，导致迭代过程中无法感知集合的实时变化。适合读多写少、对实时性要求不高的场景。","source":"_posts/ArrayList集合.md","raw":"---\ntitle: ArrayList集合\ntags:\n  - ArrayList\ndescription: |\n  文章缩略，支持 `Markdown` **文档格式**\npinned: 0\nlang: zh\ncategories:\n  - Java 基础篇\ntype: post\nwordCount: 49\ncharCount: 1853\nimgCount: 0\nvidCount: 0\nwsCount: 0\ncbCount: 0\nreadTime: 约24秒\nabbrlink: 6ff8c531\ndate: 2025-10-27 22:25:43\n---\n### 1、ArrayList 的底层数据结构是什么？\n\n​      ArrayList 的底层数据结构是 Object 类型的 elementData 数组，该数组具有动态可扩容机制，即动态可扩容数组。该数组由 transient 修饰，标记为不可序列化，用来解决在数组序列化时，会将空元素也序列化的问题。同时实现了 writeObject 和 readObject 方法，来手动实现有效元素的序列化和反序列化。\n\n### 2、ArrayList 如何添加元素？扩容机制是什么？\n\n#####       1）添加元素：\n\n​            通过 add() 方法用来添加元素，而 add() 方法，实际上是调用内部私有的add() 方法，向elementData 数组中添加元素。\n\n#####       2）扩容机制：\n\n- 首先，检查数组当前的有效元素的数量是否等于elementData的总长度。\n    - 如果不相等，说明数组未满，则直接添加，并将size的大小加一。\n    - 如果相等，说明当前的空间已经用完，则进入gow()，并将扩容后的数组赋值给elementData数组，然后继续将元素放入，size的大小加一。\n        - 对于grow()方法，入参为最小扩容量，即扩容后的大小一定大于等于这个入参的值，具体的实现为，先获取到数组的整个长度，然后将数组的长度增加为原来的1.5倍后，与入参，即最小扩容量相比。\n            - 如果大于等于入参，那末直接用1.5倍的值作为新数组长度。\n            - 反之直接用最小扩容量最为新数组的长度。\n            - 最后调用Arrays的copy()方法，将数组进行扩容，而这个方法本质是调用底层的System.arraycopy的本地方法来进行数组的扩容。\n\n### 3、ArrayList 是否线程安全？如何解决？\n\n#####       1）线程安全：\n\n​           是非线程安全的，其根本原因是内部没有同步机制，所有的操作都是共享数组和计数器，关键操作并没有原子性。多线程模式下容易出现ConcurrentModificationException 等异常。\n\n#####       2）解决方案：\n\n​           ① 对于轻度并发场景，使用并发工具包Collections的SynchronizedList() 方法，构造线程安全的集合，原理就是通过包装器为所有的方法都加上Synchronized锁，但是，并发性能低，迭代时必须显示的加上锁，因为并发工具包只是为独立的方法加上了 Synchroized(mutex)，而迭代时的多个操作，涉及hasNext、next操作，这些组合操作本身并不是原子的，因此在迭代时，需要显示的加上锁。\n\n​           ② CopyOnWriteArrayList 适用于读多写少的情况，原理就是，在写操作时，复制整个数组，同时数组的长度加1，在新数组的最后位置加上一个元素，再用新数组替换旧数组。而在添加的过程中，在jdk 9 之前用的都是 ReentrantLook 锁，而在jdk 9 之后，用的就是Synchroized。\n\n​           ③ Vector，是线程安全的，原理就是每个方法都用 Synchroized 锁，但是性能较低，迭代器问题未解决。由于锁的力度比较粗，所有公共方法都被Synchroized 修饰，单线程每次调用都有锁的开销，而在多线程模式下，即使是读操作之间也会互斥，无法并发。并且默认扩容为原来的2倍，容易造成内存泄漏。同时迭代器也没有实现线程安全。\n\n​           ④ 手动同步。\n\n### 4、为什么ArrayList扩容为原来的1.5倍？\n\n​      扩容较大会有OOM以及内存浪费，扩容较小会有多次扩容，浪费性能。而1.5是在扩容频率适中，空间利用率最高的大小。\n\n### 5、如何在迭代过程中删除元素？\n\n​      调用迭代器自身提供的remove()方法，进行删除元素，原理是在调用过程中，会更新modCount的值，不会触发快速失败。\n\n### 6、modCount 字段的作用是什么？\n\n​      modCount 是结构修改哨兵，任何有关修改数组的结构的操作都会导致modCount加1，包括添加元素，删除元素，但是替换元素不会导致modCount加1。当在迭代过程中，会先记录modCount的值，每次迭代调用next()方法都会对比是否相同，不相同直接抛出ConcurrantModificationException。多线程下，防止一个线程迭代，一个线程修改的情况，单线程中以最低的成本实现快速失败，防止数据不一致。\n\n### 7、快速失败 + 安全失败\n\n​    *快速失败*：通过检测集合的并发修改，及时抛出异常来避免潜在的逻辑错误。即：通过修改计数器 modCont 记录修改次数，当出现不一致的情况时，立即抛出 `ConcurrentModificationException` 异常。但它**不解决线程安全问题**，仅用于快速暴露问题。\n\n*安全失败*：例如 `CopyOnWriteArrayList` 在创建迭代器时，会生成当前集合的快照，遍历通过这个快照进行遍历。因此，当迭代过程中进行修改时，修改的结果不会影响快照的内容，导致迭代过程中无法感知集合的实时变化。适合读多写少、对实时性要求不高的场景。","slug":"ArrayList集合","published":1,"updated":"2025-10-27T14:28:11.542Z","comments":1,"layout":"post","photos":[],"_id":"cuidYc6YLA5ukI9gK75TAKYFE","content":"<h3 id=\"1、ArrayList-的底层数据结构是什么？\"><a href=\"#1、ArrayList-的底层数据结构是什么？\" class=\"headerlink\" title=\"1、ArrayList 的底层数据结构是什么？\"></a>1、ArrayList 的底层数据结构是什么？</h3><p>​      ArrayList 的底层数据结构是 Object 类型的 elementData 数组，该数组具有动态可扩容机制，即动态可扩容数组。该数组由 transient 修饰，标记为不可序列化，用来解决在数组序列化时，会将空元素也序列化的问题。同时实现了 writeObject 和 readObject 方法，来手动实现有效元素的序列化和反序列化。</p>\n<h3 id=\"2、ArrayList-如何添加元素？扩容机制是什么？\"><a href=\"#2、ArrayList-如何添加元素？扩容机制是什么？\" class=\"headerlink\" title=\"2、ArrayList 如何添加元素？扩容机制是什么？\"></a>2、ArrayList 如何添加元素？扩容机制是什么？</h3><h5 id=\"1）添加元素：\"><a href=\"#1）添加元素：\" class=\"headerlink\" title=\"1）添加元素：\"></a>1）添加元素：</h5><p>​            通过 add() 方法用来添加元素，而 add() 方法，实际上是调用内部私有的add() 方法，向elementData 数组中添加元素。</p>\n<h5 id=\"2）扩容机制：\"><a href=\"#2）扩容机制：\" class=\"headerlink\" title=\"2）扩容机制：\"></a>2）扩容机制：</h5><ul>\n<li>首先，检查数组当前的有效元素的数量是否等于elementData的总长度。<ul>\n<li>如果不相等，说明数组未满，则直接添加，并将size的大小加一。</li>\n<li>如果相等，说明当前的空间已经用完，则进入gow()，并将扩容后的数组赋值给elementData数组，然后继续将元素放入，size的大小加一。<ul>\n<li>对于grow()方法，入参为最小扩容量，即扩容后的大小一定大于等于这个入参的值，具体的实现为，先获取到数组的整个长度，然后将数组的长度增加为原来的1.5倍后，与入参，即最小扩容量相比。<ul>\n<li>如果大于等于入参，那末直接用1.5倍的值作为新数组长度。</li>\n<li>反之直接用最小扩容量最为新数组的长度。</li>\n<li>最后调用Arrays的copy()方法，将数组进行扩容，而这个方法本质是调用底层的System.arraycopy的本地方法来进行数组的扩容。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3、ArrayList-是否线程安全？如何解决？\"><a href=\"#3、ArrayList-是否线程安全？如何解决？\" class=\"headerlink\" title=\"3、ArrayList 是否线程安全？如何解决？\"></a>3、ArrayList 是否线程安全？如何解决？</h3><h5 id=\"1）线程安全：\"><a href=\"#1）线程安全：\" class=\"headerlink\" title=\"1）线程安全：\"></a>1）线程安全：</h5><p>​           是非线程安全的，其根本原因是内部没有同步机制，所有的操作都是共享数组和计数器，关键操作并没有原子性。多线程模式下容易出现ConcurrentModificationException 等异常。</p>\n<h5 id=\"2）解决方案：\"><a href=\"#2）解决方案：\" class=\"headerlink\" title=\"2）解决方案：\"></a>2）解决方案：</h5><p>​           ① 对于轻度并发场景，使用并发工具包Collections的SynchronizedList() 方法，构造线程安全的集合，原理就是通过包装器为所有的方法都加上Synchronized锁，但是，并发性能低，迭代时必须显示的加上锁，因为并发工具包只是为独立的方法加上了 Synchroized(mutex)，而迭代时的多个操作，涉及hasNext、next操作，这些组合操作本身并不是原子的，因此在迭代时，需要显示的加上锁。</p>\n<p>​           ② CopyOnWriteArrayList 适用于读多写少的情况，原理就是，在写操作时，复制整个数组，同时数组的长度加1，在新数组的最后位置加上一个元素，再用新数组替换旧数组。而在添加的过程中，在jdk 9 之前用的都是 ReentrantLook 锁，而在jdk 9 之后，用的就是Synchroized。</p>\n<p>​           ③ Vector，是线程安全的，原理就是每个方法都用 Synchroized 锁，但是性能较低，迭代器问题未解决。由于锁的力度比较粗，所有公共方法都被Synchroized 修饰，单线程每次调用都有锁的开销，而在多线程模式下，即使是读操作之间也会互斥，无法并发。并且默认扩容为原来的2倍，容易造成内存泄漏。同时迭代器也没有实现线程安全。</p>\n<p>​           ④ 手动同步。</p>\n<h3 id=\"4、为什么ArrayList扩容为原来的1-5倍？\"><a href=\"#4、为什么ArrayList扩容为原来的1-5倍？\" class=\"headerlink\" title=\"4、为什么ArrayList扩容为原来的1.5倍？\"></a>4、为什么ArrayList扩容为原来的1.5倍？</h3><p>​      扩容较大会有OOM以及内存浪费，扩容较小会有多次扩容，浪费性能。而1.5是在扩容频率适中，空间利用率最高的大小。</p>\n<h3 id=\"5、如何在迭代过程中删除元素？\"><a href=\"#5、如何在迭代过程中删除元素？\" class=\"headerlink\" title=\"5、如何在迭代过程中删除元素？\"></a>5、如何在迭代过程中删除元素？</h3><p>​      调用迭代器自身提供的remove()方法，进行删除元素，原理是在调用过程中，会更新modCount的值，不会触发快速失败。</p>\n<h3 id=\"6、modCount-字段的作用是什么？\"><a href=\"#6、modCount-字段的作用是什么？\" class=\"headerlink\" title=\"6、modCount 字段的作用是什么？\"></a>6、modCount 字段的作用是什么？</h3><p>​      modCount 是结构修改哨兵，任何有关修改数组的结构的操作都会导致modCount加1，包括添加元素，删除元素，但是替换元素不会导致modCount加1。当在迭代过程中，会先记录modCount的值，每次迭代调用next()方法都会对比是否相同，不相同直接抛出ConcurrantModificationException。多线程下，防止一个线程迭代，一个线程修改的情况，单线程中以最低的成本实现快速失败，防止数据不一致。</p>\n<h3 id=\"7、快速失败-安全失败\"><a href=\"#7、快速失败-安全失败\" class=\"headerlink\" title=\"7、快速失败 + 安全失败\"></a>7、快速失败 + 安全失败</h3><p>​    <em>快速失败</em>：通过检测集合的并发修改，及时抛出异常来避免潜在的逻辑错误。即：通过修改计数器 modCont 记录修改次数，当出现不一致的情况时，立即抛出 <code>ConcurrentModificationException</code> 异常。但它<strong>不解决线程安全问题</strong>，仅用于快速暴露问题。</p>\n<p><em>安全失败</em>：例如 <code>CopyOnWriteArrayList</code> 在创建迭代器时，会生成当前集合的快照，遍历通过这个快照进行遍历。因此，当迭代过程中进行修改时，修改的结果不会影响快照的内容，导致迭代过程中无法感知集合的实时变化。适合读多写少、对实时性要求不高的场景。</p>\n","excerpt":"","more":"<h3 id=\"1、ArrayList-的底层数据结构是什么？\"><a href=\"#1、ArrayList-的底层数据结构是什么？\" class=\"headerlink\" title=\"1、ArrayList 的底层数据结构是什么？\"></a>1、ArrayList 的底层数据结构是什么？</h3><p>​      ArrayList 的底层数据结构是 Object 类型的 elementData 数组，该数组具有动态可扩容机制，即动态可扩容数组。该数组由 transient 修饰，标记为不可序列化，用来解决在数组序列化时，会将空元素也序列化的问题。同时实现了 writeObject 和 readObject 方法，来手动实现有效元素的序列化和反序列化。</p>\n<h3 id=\"2、ArrayList-如何添加元素？扩容机制是什么？\"><a href=\"#2、ArrayList-如何添加元素？扩容机制是什么？\" class=\"headerlink\" title=\"2、ArrayList 如何添加元素？扩容机制是什么？\"></a>2、ArrayList 如何添加元素？扩容机制是什么？</h3><h5 id=\"1）添加元素：\"><a href=\"#1）添加元素：\" class=\"headerlink\" title=\"1）添加元素：\"></a>1）添加元素：</h5><p>​            通过 add() 方法用来添加元素，而 add() 方法，实际上是调用内部私有的add() 方法，向elementData 数组中添加元素。</p>\n<h5 id=\"2）扩容机制：\"><a href=\"#2）扩容机制：\" class=\"headerlink\" title=\"2）扩容机制：\"></a>2）扩容机制：</h5><ul>\n<li>首先，检查数组当前的有效元素的数量是否等于elementData的总长度。<ul>\n<li>如果不相等，说明数组未满，则直接添加，并将size的大小加一。</li>\n<li>如果相等，说明当前的空间已经用完，则进入gow()，并将扩容后的数组赋值给elementData数组，然后继续将元素放入，size的大小加一。<ul>\n<li>对于grow()方法，入参为最小扩容量，即扩容后的大小一定大于等于这个入参的值，具体的实现为，先获取到数组的整个长度，然后将数组的长度增加为原来的1.5倍后，与入参，即最小扩容量相比。<ul>\n<li>如果大于等于入参，那末直接用1.5倍的值作为新数组长度。</li>\n<li>反之直接用最小扩容量最为新数组的长度。</li>\n<li>最后调用Arrays的copy()方法，将数组进行扩容，而这个方法本质是调用底层的System.arraycopy的本地方法来进行数组的扩容。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3、ArrayList-是否线程安全？如何解决？\"><a href=\"#3、ArrayList-是否线程安全？如何解决？\" class=\"headerlink\" title=\"3、ArrayList 是否线程安全？如何解决？\"></a>3、ArrayList 是否线程安全？如何解决？</h3><h5 id=\"1）线程安全：\"><a href=\"#1）线程安全：\" class=\"headerlink\" title=\"1）线程安全：\"></a>1）线程安全：</h5><p>​           是非线程安全的，其根本原因是内部没有同步机制，所有的操作都是共享数组和计数器，关键操作并没有原子性。多线程模式下容易出现ConcurrentModificationException 等异常。</p>\n<h5 id=\"2）解决方案：\"><a href=\"#2）解决方案：\" class=\"headerlink\" title=\"2）解决方案：\"></a>2）解决方案：</h5><p>​           ① 对于轻度并发场景，使用并发工具包Collections的SynchronizedList() 方法，构造线程安全的集合，原理就是通过包装器为所有的方法都加上Synchronized锁，但是，并发性能低，迭代时必须显示的加上锁，因为并发工具包只是为独立的方法加上了 Synchroized(mutex)，而迭代时的多个操作，涉及hasNext、next操作，这些组合操作本身并不是原子的，因此在迭代时，需要显示的加上锁。</p>\n<p>​           ② CopyOnWriteArrayList 适用于读多写少的情况，原理就是，在写操作时，复制整个数组，同时数组的长度加1，在新数组的最后位置加上一个元素，再用新数组替换旧数组。而在添加的过程中，在jdk 9 之前用的都是 ReentrantLook 锁，而在jdk 9 之后，用的就是Synchroized。</p>\n<p>​           ③ Vector，是线程安全的，原理就是每个方法都用 Synchroized 锁，但是性能较低，迭代器问题未解决。由于锁的力度比较粗，所有公共方法都被Synchroized 修饰，单线程每次调用都有锁的开销，而在多线程模式下，即使是读操作之间也会互斥，无法并发。并且默认扩容为原来的2倍，容易造成内存泄漏。同时迭代器也没有实现线程安全。</p>\n<p>​           ④ 手动同步。</p>\n<h3 id=\"4、为什么ArrayList扩容为原来的1-5倍？\"><a href=\"#4、为什么ArrayList扩容为原来的1-5倍？\" class=\"headerlink\" title=\"4、为什么ArrayList扩容为原来的1.5倍？\"></a>4、为什么ArrayList扩容为原来的1.5倍？</h3><p>​      扩容较大会有OOM以及内存浪费，扩容较小会有多次扩容，浪费性能。而1.5是在扩容频率适中，空间利用率最高的大小。</p>\n<h3 id=\"5、如何在迭代过程中删除元素？\"><a href=\"#5、如何在迭代过程中删除元素？\" class=\"headerlink\" title=\"5、如何在迭代过程中删除元素？\"></a>5、如何在迭代过程中删除元素？</h3><p>​      调用迭代器自身提供的remove()方法，进行删除元素，原理是在调用过程中，会更新modCount的值，不会触发快速失败。</p>\n<h3 id=\"6、modCount-字段的作用是什么？\"><a href=\"#6、modCount-字段的作用是什么？\" class=\"headerlink\" title=\"6、modCount 字段的作用是什么？\"></a>6、modCount 字段的作用是什么？</h3><p>​      modCount 是结构修改哨兵，任何有关修改数组的结构的操作都会导致modCount加1，包括添加元素，删除元素，但是替换元素不会导致modCount加1。当在迭代过程中，会先记录modCount的值，每次迭代调用next()方法都会对比是否相同，不相同直接抛出ConcurrantModificationException。多线程下，防止一个线程迭代，一个线程修改的情况，单线程中以最低的成本实现快速失败，防止数据不一致。</p>\n<h3 id=\"7、快速失败-安全失败\"><a href=\"#7、快速失败-安全失败\" class=\"headerlink\" title=\"7、快速失败 + 安全失败\"></a>7、快速失败 + 安全失败</h3><p>​    <em>快速失败</em>：通过检测集合的并发修改，及时抛出异常来避免潜在的逻辑错误。即：通过修改计数器 modCont 记录修改次数，当出现不一致的情况时，立即抛出 <code>ConcurrentModificationException</code> 异常。但它<strong>不解决线程安全问题</strong>，仅用于快速暴露问题。</p>\n<p><em>安全失败</em>：例如 <code>CopyOnWriteArrayList</code> 在创建迭代器时，会生成当前集合的快照，遍历通过这个快照进行遍历。因此，当迭代过程中进行修改时，修改的结果不会影响快照的内容，导致迭代过程中无法感知集合的实时变化。适合读多写少、对实时性要求不高的场景。</p>\n"},{"title":"MySQL事务","description":"文章缩略，支持 `Markdown` **文档格式**\n","pinned":0,"lang":"zh","type":"post","date":"2025-10-28T08:31:28.000Z","_content":"### 1、事务的ACID模型\n\n1、**原子性**：是最小分割的操作单元，要么全部成功，要么全部失败。\n\n2、**一致性**：事务完成时，必须使所有的数据都保持一致，即：事务前后数据的完整性和一致性。\n\n3、**隔离性**：数据库系统提供的隔离机制，通过不同的隔离级别，保证事务在不受外部并发操作影响的独立环境下运行。\n\n4、**持久性**：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的，即使机器发生故障，也可以通过日志等方式恢复数据。\n\n### 2、并发下的事务问题\n\n1、**脏读**：一个事务读取到另一个事务还没有提交的数据。\n\n2、**不可重复读**：一个事务先后读取同一条记录，但是两次读取的数据不同。\n\n3、**幻读**：在**解决**不可重复度的前提下，一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了一个幻影，再次查询又查不到，因为已经解决了不可重读的问题，因此会出现幻读的问题。前后两次查询的数据不一致，第二次查到了第一次不存在的数据。\n\n### 4、事务的隔离级别(解决并发事务的问题)：\n\n1、`Read uncommitted` ：什么都不能解决。（读未提交，可以读到其他事务尚未提交的数据）\n\n2、`Read committed` ：只能解决脏读。（读已提交，只读其他事务已经提交的数据，不能读取未提交的更改，原因就是：在读取数据时加入了共享锁，但是，只是在读取时暂时，在事务提交或回滚后，就会释放锁，从而解决脏读问题）\n\n3、`Repeatable Read(默认)` ：只解决脏读、不可重复读。（会在整个事务期间持有锁，解决脏读和不可重复读）\n\n4、`Serializable` ：所有的都能解决。（加范围锁，会对查询的范围加锁，并且事务会按照一定的顺序排队执行，不会出现并发问题）\n\n### 5、事务的原理\n\n##### 1、基本概述\n\n- 原子性、一致性、持久性：是通过底层的两个日志文件来实现的，redo log 、undo log\n- 隔离性：是通过锁机制和MVCC(多版本并发控制)来实现的。\n\n##### 2、详细解释\n\n- **持久性**\n    - 利用 `redo log` 实现。重做日志，记录事务提交时的数据**物理页**修改，即，`redo log`记录的是，**某个页的某个数据从什么值变成什么值**。\n    - 该日志主要分为两个部分\n        - **重做缓冲日志**：`redo log buffer`，存在于内存中，记录事务提交时的物理修改。\n        - **重做日志文件**：`redo log file`，存在于磁盘中。\n    - **过程**：当对缓冲区的数据进行增删改之后，会首先将**数据页的变化**记录到`redo log buffer` 中，在事务提交后，会**直接**将`redo log buffer` 中的数据刷新到磁盘文件中，之后在**脏页刷新**的时候出错了，就可以通过`redo log file`来进行恢复。\n    - **注意**：为什么不在提交事务的时候直接将脏页刷新到磁盘，而是通过 `redo log`来实现，因为，直接刷新存在**严重的性能问题**因为一个事务中，一定包含很多条语句，每条语句的数据不一定相同，会涉及到**很多随机磁盘IO**，而`log`都是追加的，因此是**顺序磁盘IO**，顺序 IO 的效率大于随机 IO\n- **原子性**\n    - `undo log`用于**回滚日志**，记录数据被修改前的信息，作用包含两个：提供回滚和`MVCC`(多版本并发控制)\n    - `undo log`是逻辑日志。可以认为当 `delete` 一条记录时，`undo log` 会记录一条对应的 insert 记录，反之亦然，当`update`一条记录时，他记录一条对应相反的`update`记录。当执行`rollback`时，就可以从`undo log` 中的逻辑记录中读取到相应的内容，并进行回滚，**从而保证数据的原子性(主要时回滚)**，实际上就是记录的是**旧版本的数据**。\n        - `Undo log`销毁：`undo log` 在事务执行时产生,，事务提交时，并不会立即删除，因为这些事务有肯能涉及到MVCC\n        - `Undo log`存储：`undo log`采用段的方式进行回滚和记录，存放在`rollback`、`segment` 回滚段中。","source":"_posts/MySQL事务.md","raw":"---\ntitle: MySQL事务\ntags:\n  - 事务\ndescription: |\n  文章缩略，支持 `Markdown` **文档格式**\npinned: 0\nlang: zh\ncategories:\n  - MySQL 篇\ntype: post\ndate: 2025-10-28 16:31:28\n---\n### 1、事务的ACID模型\n\n1、**原子性**：是最小分割的操作单元，要么全部成功，要么全部失败。\n\n2、**一致性**：事务完成时，必须使所有的数据都保持一致，即：事务前后数据的完整性和一致性。\n\n3、**隔离性**：数据库系统提供的隔离机制，通过不同的隔离级别，保证事务在不受外部并发操作影响的独立环境下运行。\n\n4、**持久性**：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的，即使机器发生故障，也可以通过日志等方式恢复数据。\n\n### 2、并发下的事务问题\n\n1、**脏读**：一个事务读取到另一个事务还没有提交的数据。\n\n2、**不可重复读**：一个事务先后读取同一条记录，但是两次读取的数据不同。\n\n3、**幻读**：在**解决**不可重复度的前提下，一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了一个幻影，再次查询又查不到，因为已经解决了不可重读的问题，因此会出现幻读的问题。前后两次查询的数据不一致，第二次查到了第一次不存在的数据。\n\n### 4、事务的隔离级别(解决并发事务的问题)：\n\n1、`Read uncommitted` ：什么都不能解决。（读未提交，可以读到其他事务尚未提交的数据）\n\n2、`Read committed` ：只能解决脏读。（读已提交，只读其他事务已经提交的数据，不能读取未提交的更改，原因就是：在读取数据时加入了共享锁，但是，只是在读取时暂时，在事务提交或回滚后，就会释放锁，从而解决脏读问题）\n\n3、`Repeatable Read(默认)` ：只解决脏读、不可重复读。（会在整个事务期间持有锁，解决脏读和不可重复读）\n\n4、`Serializable` ：所有的都能解决。（加范围锁，会对查询的范围加锁，并且事务会按照一定的顺序排队执行，不会出现并发问题）\n\n### 5、事务的原理\n\n##### 1、基本概述\n\n- 原子性、一致性、持久性：是通过底层的两个日志文件来实现的，redo log 、undo log\n- 隔离性：是通过锁机制和MVCC(多版本并发控制)来实现的。\n\n##### 2、详细解释\n\n- **持久性**\n    - 利用 `redo log` 实现。重做日志，记录事务提交时的数据**物理页**修改，即，`redo log`记录的是，**某个页的某个数据从什么值变成什么值**。\n    - 该日志主要分为两个部分\n        - **重做缓冲日志**：`redo log buffer`，存在于内存中，记录事务提交时的物理修改。\n        - **重做日志文件**：`redo log file`，存在于磁盘中。\n    - **过程**：当对缓冲区的数据进行增删改之后，会首先将**数据页的变化**记录到`redo log buffer` 中，在事务提交后，会**直接**将`redo log buffer` 中的数据刷新到磁盘文件中，之后在**脏页刷新**的时候出错了，就可以通过`redo log file`来进行恢复。\n    - **注意**：为什么不在提交事务的时候直接将脏页刷新到磁盘，而是通过 `redo log`来实现，因为，直接刷新存在**严重的性能问题**因为一个事务中，一定包含很多条语句，每条语句的数据不一定相同，会涉及到**很多随机磁盘IO**，而`log`都是追加的，因此是**顺序磁盘IO**，顺序 IO 的效率大于随机 IO\n- **原子性**\n    - `undo log`用于**回滚日志**，记录数据被修改前的信息，作用包含两个：提供回滚和`MVCC`(多版本并发控制)\n    - `undo log`是逻辑日志。可以认为当 `delete` 一条记录时，`undo log` 会记录一条对应的 insert 记录，反之亦然，当`update`一条记录时，他记录一条对应相反的`update`记录。当执行`rollback`时，就可以从`undo log` 中的逻辑记录中读取到相应的内容，并进行回滚，**从而保证数据的原子性(主要时回滚)**，实际上就是记录的是**旧版本的数据**。\n        - `Undo log`销毁：`undo log` 在事务执行时产生,，事务提交时，并不会立即删除，因为这些事务有肯能涉及到MVCC\n        - `Undo log`存储：`undo log`采用段的方式进行回滚和记录，存放在`rollback`、`segment` 回滚段中。","slug":"MySQL事务","published":1,"updated":"2025-10-28T08:32:17.769Z","comments":1,"layout":"post","photos":[],"_id":"cuidpWCT9bEovYg5gLfKfrc5-","content":"<h3 id=\"1、事务的ACID模型\"><a href=\"#1、事务的ACID模型\" class=\"headerlink\" title=\"1、事务的ACID模型\"></a>1、事务的ACID模型</h3><p>1、<strong>原子性</strong>：是最小分割的操作单元，要么全部成功，要么全部失败。</p>\n<p>2、<strong>一致性</strong>：事务完成时，必须使所有的数据都保持一致，即：事务前后数据的完整性和一致性。</p>\n<p>3、<strong>隔离性</strong>：数据库系统提供的隔离机制，通过不同的隔离级别，保证事务在不受外部并发操作影响的独立环境下运行。</p>\n<p>4、<strong>持久性</strong>：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的，即使机器发生故障，也可以通过日志等方式恢复数据。</p>\n<h3 id=\"2、并发下的事务问题\"><a href=\"#2、并发下的事务问题\" class=\"headerlink\" title=\"2、并发下的事务问题\"></a>2、并发下的事务问题</h3><p>1、<strong>脏读</strong>：一个事务读取到另一个事务还没有提交的数据。</p>\n<p>2、<strong>不可重复读</strong>：一个事务先后读取同一条记录，但是两次读取的数据不同。</p>\n<p>3、<strong>幻读</strong>：在<strong>解决</strong>不可重复度的前提下，一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了一个幻影，再次查询又查不到，因为已经解决了不可重读的问题，因此会出现幻读的问题。前后两次查询的数据不一致，第二次查到了第一次不存在的数据。</p>\n<h3 id=\"4、事务的隔离级别-解决并发事务的问题-：\"><a href=\"#4、事务的隔离级别-解决并发事务的问题-：\" class=\"headerlink\" title=\"4、事务的隔离级别(解决并发事务的问题)：\"></a>4、事务的隔离级别(解决并发事务的问题)：</h3><p>1、<code>Read uncommitted</code> ：什么都不能解决。（读未提交，可以读到其他事务尚未提交的数据）</p>\n<p>2、<code>Read committed</code> ：只能解决脏读。（读已提交，只读其他事务已经提交的数据，不能读取未提交的更改，原因就是：在读取数据时加入了共享锁，但是，只是在读取时暂时，在事务提交或回滚后，就会释放锁，从而解决脏读问题）</p>\n<p>3、<code>Repeatable Read(默认)</code> ：只解决脏读、不可重复读。（会在整个事务期间持有锁，解决脏读和不可重复读）</p>\n<p>4、<code>Serializable</code> ：所有的都能解决。（加范围锁，会对查询的范围加锁，并且事务会按照一定的顺序排队执行，不会出现并发问题）</p>\n<h3 id=\"5、事务的原理\"><a href=\"#5、事务的原理\" class=\"headerlink\" title=\"5、事务的原理\"></a>5、事务的原理</h3><h5 id=\"1、基本概述\"><a href=\"#1、基本概述\" class=\"headerlink\" title=\"1、基本概述\"></a>1、基本概述</h5><ul>\n<li>原子性、一致性、持久性：是通过底层的两个日志文件来实现的，redo log 、undo log</li>\n<li>隔离性：是通过锁机制和MVCC(多版本并发控制)来实现的。</li>\n</ul>\n<h5 id=\"2、详细解释\"><a href=\"#2、详细解释\" class=\"headerlink\" title=\"2、详细解释\"></a>2、详细解释</h5><ul>\n<li><strong>持久性</strong><ul>\n<li>利用 <code>redo log</code> 实现。重做日志，记录事务提交时的数据<strong>物理页</strong>修改，即，<code>redo log</code>记录的是，<strong>某个页的某个数据从什么值变成什么值</strong>。</li>\n<li>该日志主要分为两个部分<ul>\n<li><strong>重做缓冲日志</strong>：<code>redo log buffer</code>，存在于内存中，记录事务提交时的物理修改。</li>\n<li><strong>重做日志文件</strong>：<code>redo log file</code>，存在于磁盘中。</li>\n</ul>\n</li>\n<li><strong>过程</strong>：当对缓冲区的数据进行增删改之后，会首先将<strong>数据页的变化</strong>记录到<code>redo log buffer</code> 中，在事务提交后，会<strong>直接</strong>将<code>redo log buffer</code> 中的数据刷新到磁盘文件中，之后在<strong>脏页刷新</strong>的时候出错了，就可以通过<code>redo log file</code>来进行恢复。</li>\n<li><strong>注意</strong>：为什么不在提交事务的时候直接将脏页刷新到磁盘，而是通过 <code>redo log</code>来实现，因为，直接刷新存在<strong>严重的性能问题</strong>因为一个事务中，一定包含很多条语句，每条语句的数据不一定相同，会涉及到<strong>很多随机磁盘IO</strong>，而<code>log</code>都是追加的，因此是<strong>顺序磁盘IO</strong>，顺序 IO 的效率大于随机 IO</li>\n</ul>\n</li>\n<li><strong>原子性</strong><ul>\n<li><code>undo log</code>用于<strong>回滚日志</strong>，记录数据被修改前的信息，作用包含两个：提供回滚和<code>MVCC</code>(多版本并发控制)</li>\n<li><code>undo log</code>是逻辑日志。可以认为当 <code>delete</code> 一条记录时，<code>undo log</code> 会记录一条对应的 insert 记录，反之亦然，当<code>update</code>一条记录时，他记录一条对应相反的<code>update</code>记录。当执行<code>rollback</code>时，就可以从<code>undo log</code> 中的逻辑记录中读取到相应的内容，并进行回滚，<strong>从而保证数据的原子性(主要时回滚)</strong>，实际上就是记录的是<strong>旧版本的数据</strong>。<ul>\n<li><code>Undo log</code>销毁：<code>undo log</code> 在事务执行时产生,，事务提交时，并不会立即删除，因为这些事务有肯能涉及到MVCC</li>\n<li><code>Undo log</code>存储：<code>undo log</code>采用段的方式进行回滚和记录，存放在<code>rollback</code>、<code>segment</code> 回滚段中。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","abbrlink":"f91535f","wordCount":65,"charCount":1580,"imgCount":0,"vidCount":0,"wsCount":0,"cbCount":0,"readTime":"约30秒","excerpt":"","more":"<h3 id=\"1、事务的ACID模型\"><a href=\"#1、事务的ACID模型\" class=\"headerlink\" title=\"1、事务的ACID模型\"></a>1、事务的ACID模型</h3><p>1、<strong>原子性</strong>：是最小分割的操作单元，要么全部成功，要么全部失败。</p>\n<p>2、<strong>一致性</strong>：事务完成时，必须使所有的数据都保持一致，即：事务前后数据的完整性和一致性。</p>\n<p>3、<strong>隔离性</strong>：数据库系统提供的隔离机制，通过不同的隔离级别，保证事务在不受外部并发操作影响的独立环境下运行。</p>\n<p>4、<strong>持久性</strong>：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的，即使机器发生故障，也可以通过日志等方式恢复数据。</p>\n<h3 id=\"2、并发下的事务问题\"><a href=\"#2、并发下的事务问题\" class=\"headerlink\" title=\"2、并发下的事务问题\"></a>2、并发下的事务问题</h3><p>1、<strong>脏读</strong>：一个事务读取到另一个事务还没有提交的数据。</p>\n<p>2、<strong>不可重复读</strong>：一个事务先后读取同一条记录，但是两次读取的数据不同。</p>\n<p>3、<strong>幻读</strong>：在<strong>解决</strong>不可重复度的前提下，一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了一个幻影，再次查询又查不到，因为已经解决了不可重读的问题，因此会出现幻读的问题。前后两次查询的数据不一致，第二次查到了第一次不存在的数据。</p>\n<h3 id=\"4、事务的隔离级别-解决并发事务的问题-：\"><a href=\"#4、事务的隔离级别-解决并发事务的问题-：\" class=\"headerlink\" title=\"4、事务的隔离级别(解决并发事务的问题)：\"></a>4、事务的隔离级别(解决并发事务的问题)：</h3><p>1、<code>Read uncommitted</code> ：什么都不能解决。（读未提交，可以读到其他事务尚未提交的数据）</p>\n<p>2、<code>Read committed</code> ：只能解决脏读。（读已提交，只读其他事务已经提交的数据，不能读取未提交的更改，原因就是：在读取数据时加入了共享锁，但是，只是在读取时暂时，在事务提交或回滚后，就会释放锁，从而解决脏读问题）</p>\n<p>3、<code>Repeatable Read(默认)</code> ：只解决脏读、不可重复读。（会在整个事务期间持有锁，解决脏读和不可重复读）</p>\n<p>4、<code>Serializable</code> ：所有的都能解决。（加范围锁，会对查询的范围加锁，并且事务会按照一定的顺序排队执行，不会出现并发问题）</p>\n<h3 id=\"5、事务的原理\"><a href=\"#5、事务的原理\" class=\"headerlink\" title=\"5、事务的原理\"></a>5、事务的原理</h3><h5 id=\"1、基本概述\"><a href=\"#1、基本概述\" class=\"headerlink\" title=\"1、基本概述\"></a>1、基本概述</h5><ul>\n<li>原子性、一致性、持久性：是通过底层的两个日志文件来实现的，redo log 、undo log</li>\n<li>隔离性：是通过锁机制和MVCC(多版本并发控制)来实现的。</li>\n</ul>\n<h5 id=\"2、详细解释\"><a href=\"#2、详细解释\" class=\"headerlink\" title=\"2、详细解释\"></a>2、详细解释</h5><ul>\n<li><strong>持久性</strong><ul>\n<li>利用 <code>redo log</code> 实现。重做日志，记录事务提交时的数据<strong>物理页</strong>修改，即，<code>redo log</code>记录的是，<strong>某个页的某个数据从什么值变成什么值</strong>。</li>\n<li>该日志主要分为两个部分<ul>\n<li><strong>重做缓冲日志</strong>：<code>redo log buffer</code>，存在于内存中，记录事务提交时的物理修改。</li>\n<li><strong>重做日志文件</strong>：<code>redo log file</code>，存在于磁盘中。</li>\n</ul>\n</li>\n<li><strong>过程</strong>：当对缓冲区的数据进行增删改之后，会首先将<strong>数据页的变化</strong>记录到<code>redo log buffer</code> 中，在事务提交后，会<strong>直接</strong>将<code>redo log buffer</code> 中的数据刷新到磁盘文件中，之后在<strong>脏页刷新</strong>的时候出错了，就可以通过<code>redo log file</code>来进行恢复。</li>\n<li><strong>注意</strong>：为什么不在提交事务的时候直接将脏页刷新到磁盘，而是通过 <code>redo log</code>来实现，因为，直接刷新存在<strong>严重的性能问题</strong>因为一个事务中，一定包含很多条语句，每条语句的数据不一定相同，会涉及到<strong>很多随机磁盘IO</strong>，而<code>log</code>都是追加的，因此是<strong>顺序磁盘IO</strong>，顺序 IO 的效率大于随机 IO</li>\n</ul>\n</li>\n<li><strong>原子性</strong><ul>\n<li><code>undo log</code>用于<strong>回滚日志</strong>，记录数据被修改前的信息，作用包含两个：提供回滚和<code>MVCC</code>(多版本并发控制)</li>\n<li><code>undo log</code>是逻辑日志。可以认为当 <code>delete</code> 一条记录时，<code>undo log</code> 会记录一条对应的 insert 记录，反之亦然，当<code>update</code>一条记录时，他记录一条对应相反的<code>update</code>记录。当执行<code>rollback</code>时，就可以从<code>undo log</code> 中的逻辑记录中读取到相应的内容，并进行回滚，<strong>从而保证数据的原子性(主要时回滚)</strong>，实际上就是记录的是<strong>旧版本的数据</strong>。<ul>\n<li><code>Undo log</code>销毁：<code>undo log</code> 在事务执行时产生,，事务提交时，并不会立即删除，因为这些事务有肯能涉及到MVCC</li>\n<li><code>Undo log</code>存储：<code>undo log</code>采用段的方式进行回滚和记录，存放在<code>rollback</code>、<code>segment</code> 回滚段中。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"MySQL的MVCC","description":"文章缩略，支持 `Markdown` **文档格式**\n","pinned":0,"lang":"zh","type":"post","date":"2025-10-28T08:41:35.000Z","_content":"### 1、MVCC-基本概念\n\n- 当前读\n\n    - 读取的时记录的**最新版本**，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁，对于我们日常的操作，如：\n\n      select … lock in share mode(共享锁)，等就是一种当前读。\n\n- 快照读\n\n    - 简单的 select(不加锁) 就是快照读，快照读的就是记录的可见版本，有可能是历史版本，不加锁，是非阻塞读。\n        - `Read Committed（读已提交）`：每次 `select`都生成一个快照\n        - `Repeatable Read（可重复读）`：开启事务后的第一条`select`语句就是快照读，后续的`select`语句读取的就是第一次的快照因此才实现的可重复读。\n        - `Serializable`：快照读会退化为当前读\n\n- MVCC\n\n    - 全称 `Multi-Version-Concurrency Contry`，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log 、readView\n\n### 2、MVCC-实现原理\n\n- 记录中的隐藏字段\n\n    - `DB_TRX_ID`：最近修改事务ID，记录插入这条记录或最后一次修改该条记录的事务ID。\n    - `DB_ROLL_PTR`：回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本。\n    - `DB_ROW_ID`：隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。\n\n  > 在 MySQL 中可以使用 ibd2sdi xxx.ibd 来查看ibd文件\n\n- undo log\n\n    - 回滚日志，在insert、update、delete 的时候产生的便于数据回滚的日志。\n\n      当`insert`的时候，产生的undo log 日志只在回滚时需要，在事务提交后，可被立即删除。而`update、delete` 的时候产生的日志，不仅在回滚的时候需要，在快照读时也需要，不会被立即删除。\n\n- undo log 版本链\n\n  不同事务或相同事务对同一条记录进行修改，会导致该记录的undo log 产生一条记录版本链，链表的头部是最新的旧记录，链表尾部是最早的旧记录。\n\n![MySQL的MVCC-01.png](images/MySQL的MVCC-01.png)\n![MySQL的MVCC-02.png](images/MySQL的MVCC-02.png)\n\n- readview\n    - `ReadView`(读视图)是 **快照读** ，就是一个**快照**，**在进行快读时生成**，SQL执行时MVCC提取数据的依据，记录并维护系统中当前活跃的事务（未提交）id。\n    - 包含四个核心字段\n        - `m_ids`：当前活跃的事务id集合\n        - `min_trx_id`：最小活跃事务id\n        - `max_trx_id`：预分配事务id，当前最大事务id + 1\n        - `creator_trx_id`：ReadView 创建者 id，**每个快照读都会生成一个ReadView视图，因此都有一个对应的 creator_trx_id也即是当前事务的 id，这个字段只是存一下而不是生成，每个事务开始时，都生成自己对应的id**\n    - 具体的undo log 数据链访问规则。\n        - 首先明确 `trx_id`：就是数据库中该行数据的隐藏字段 `DB_TRX_ID` 的值。\n![MySQL的MVCC-03.png](images/MySQL的MVCC-03.png)\n    - 生成时机：\n    - `Read Committed（读已提交）`：在事务中，每次执行快照读，都会生成\n    - `Repeatable Read（可重复读）`：仅在第一次快照都时生成，后续复用（**注意：这里复用的只是ReadView，而不是数据，因为后续如果两次查询中间本事务修改了，也会读取到本事务修改后的数据，因为第一条规则**），因为只有第一次时快照读，同时，如果在两次查询中间修改了该条数据，由于第一条匹配规则，还是会读取当前事务所修改的记录，而不是旧的数据(**有解释一遍**)。 ","source":"_posts/MySQL的MVCC.md","raw":"---\ntitle: MySQL的MVCC\ntags:\n  - MySQL的MVCC\ndescription: |\n  文章缩略，支持 `Markdown` **文档格式**\npinned: 0\nlang: zh\ncategories:\n  - MySQL 篇\ntype: post\ndate: 2025-10-28 16:41:35\n---\n### 1、MVCC-基本概念\n\n- 当前读\n\n    - 读取的时记录的**最新版本**，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁，对于我们日常的操作，如：\n\n      select … lock in share mode(共享锁)，等就是一种当前读。\n\n- 快照读\n\n    - 简单的 select(不加锁) 就是快照读，快照读的就是记录的可见版本，有可能是历史版本，不加锁，是非阻塞读。\n        - `Read Committed（读已提交）`：每次 `select`都生成一个快照\n        - `Repeatable Read（可重复读）`：开启事务后的第一条`select`语句就是快照读，后续的`select`语句读取的就是第一次的快照因此才实现的可重复读。\n        - `Serializable`：快照读会退化为当前读\n\n- MVCC\n\n    - 全称 `Multi-Version-Concurrency Contry`，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log 、readView\n\n### 2、MVCC-实现原理\n\n- 记录中的隐藏字段\n\n    - `DB_TRX_ID`：最近修改事务ID，记录插入这条记录或最后一次修改该条记录的事务ID。\n    - `DB_ROLL_PTR`：回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本。\n    - `DB_ROW_ID`：隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。\n\n  > 在 MySQL 中可以使用 ibd2sdi xxx.ibd 来查看ibd文件\n\n- undo log\n\n    - 回滚日志，在insert、update、delete 的时候产生的便于数据回滚的日志。\n\n      当`insert`的时候，产生的undo log 日志只在回滚时需要，在事务提交后，可被立即删除。而`update、delete` 的时候产生的日志，不仅在回滚的时候需要，在快照读时也需要，不会被立即删除。\n\n- undo log 版本链\n\n  不同事务或相同事务对同一条记录进行修改，会导致该记录的undo log 产生一条记录版本链，链表的头部是最新的旧记录，链表尾部是最早的旧记录。\n\n![MySQL的MVCC-01.png](images/MySQL的MVCC-01.png)\n![MySQL的MVCC-02.png](images/MySQL的MVCC-02.png)\n\n- readview\n    - `ReadView`(读视图)是 **快照读** ，就是一个**快照**，**在进行快读时生成**，SQL执行时MVCC提取数据的依据，记录并维护系统中当前活跃的事务（未提交）id。\n    - 包含四个核心字段\n        - `m_ids`：当前活跃的事务id集合\n        - `min_trx_id`：最小活跃事务id\n        - `max_trx_id`：预分配事务id，当前最大事务id + 1\n        - `creator_trx_id`：ReadView 创建者 id，**每个快照读都会生成一个ReadView视图，因此都有一个对应的 creator_trx_id也即是当前事务的 id，这个字段只是存一下而不是生成，每个事务开始时，都生成自己对应的id**\n    - 具体的undo log 数据链访问规则。\n        - 首先明确 `trx_id`：就是数据库中该行数据的隐藏字段 `DB_TRX_ID` 的值。\n![MySQL的MVCC-03.png](images/MySQL的MVCC-03.png)\n    - 生成时机：\n    - `Read Committed（读已提交）`：在事务中，每次执行快照读，都会生成\n    - `Repeatable Read（可重复读）`：仅在第一次快照都时生成，后续复用（**注意：这里复用的只是ReadView，而不是数据，因为后续如果两次查询中间本事务修改了，也会读取到本事务修改后的数据，因为第一条规则**），因为只有第一次时快照读，同时，如果在两次查询中间修改了该条数据，由于第一条匹配规则，还是会读取当前事务所修改的记录，而不是旧的数据(**有解释一遍**)。 ","slug":"MySQL的MVCC","published":1,"updated":"2025-10-28T08:45:37.440Z","comments":1,"layout":"post","photos":[],"_id":"cuidqIvrD7IEOrvgrXxlJhqF8","content":"<h3 id=\"1、MVCC-基本概念\"><a href=\"#1、MVCC-基本概念\" class=\"headerlink\" title=\"1、MVCC-基本概念\"></a>1、MVCC-基本概念</h3><ul>\n<li><p>当前读</p>\n<ul>\n<li><p>读取的时记录的<strong>最新版本</strong>，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁，对于我们日常的操作，如：</p>\n<p>select … lock in share mode(共享锁)，等就是一种当前读。</p>\n</li>\n</ul>\n</li>\n<li><p>快照读</p>\n<ul>\n<li>简单的 select(不加锁) 就是快照读，快照读的就是记录的可见版本，有可能是历史版本，不加锁，是非阻塞读。<ul>\n<li><code>Read Committed（读已提交）</code>：每次 <code>select</code>都生成一个快照</li>\n<li><code>Repeatable Read（可重复读）</code>：开启事务后的第一条<code>select</code>语句就是快照读，后续的<code>select</code>语句读取的就是第一次的快照因此才实现的可重复读。</li>\n<li><code>Serializable</code>：快照读会退化为当前读</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>MVCC</p>\n<ul>\n<li>全称 <code>Multi-Version-Concurrency Contry</code>，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log 、readView</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2、MVCC-实现原理\"><a href=\"#2、MVCC-实现原理\" class=\"headerlink\" title=\"2、MVCC-实现原理\"></a>2、MVCC-实现原理</h3><ul>\n<li><p>记录中的隐藏字段</p>\n<ul>\n<li><code>DB_TRX_ID</code>：最近修改事务ID，记录插入这条记录或最后一次修改该条记录的事务ID。</li>\n<li><code>DB_ROLL_PTR</code>：回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本。</li>\n<li><code>DB_ROW_ID</code>：隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。</li>\n</ul>\n<blockquote>\n<p>在 MySQL 中可以使用 ibd2sdi xxx.ibd 来查看ibd文件</p>\n</blockquote>\n</li>\n<li><p>undo log</p>\n<ul>\n<li><p>回滚日志，在insert、update、delete 的时候产生的便于数据回滚的日志。</p>\n<p>当<code>insert</code>的时候，产生的undo log 日志只在回滚时需要，在事务提交后，可被立即删除。而<code>update、delete</code> 的时候产生的日志，不仅在回滚的时候需要，在快照读时也需要，不会被立即删除。</p>\n</li>\n</ul>\n</li>\n<li><p>undo log 版本链</p>\n<p>不同事务或相同事务对同一条记录进行修改，会导致该记录的undo log 产生一条记录版本链，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</p>\n</li>\n</ul>\n<p><img src=\"/images/MySQL%E7%9A%84MVCC-01.png\" alt=\"MySQL的MVCC-01.png\"><br><img src=\"/images/MySQL%E7%9A%84MVCC-02.png\" alt=\"MySQL的MVCC-02.png\"></p>\n<ul>\n<li>readview<ul>\n<li><code>ReadView</code>(读视图)是 <strong>快照读</strong> ，就是一个<strong>快照</strong>，<strong>在进行快读时生成</strong>，SQL执行时MVCC提取数据的依据，记录并维护系统中当前活跃的事务（未提交）id。</li>\n<li>包含四个核心字段<ul>\n<li><code>m_ids</code>：当前活跃的事务id集合</li>\n<li><code>min_trx_id</code>：最小活跃事务id</li>\n<li><code>max_trx_id</code>：预分配事务id，当前最大事务id + 1</li>\n<li><code>creator_trx_id</code>：ReadView 创建者 id，<strong>每个快照读都会生成一个ReadView视图，因此都有一个对应的 creator_trx_id也即是当前事务的 id，这个字段只是存一下而不是生成，每个事务开始时，都生成自己对应的id</strong></li>\n</ul>\n</li>\n<li>具体的undo log 数据链访问规则。<ul>\n<li>首先明确 <code>trx_id</code>：就是数据库中该行数据的隐藏字段 <code>DB_TRX_ID</code> 的值。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/images/MySQL%E7%9A%84MVCC-03.png\" alt=\"MySQL的MVCC-03.png\"><br>    - 生成时机：<br>    - <code>Read Committed（读已提交）</code>：在事务中，每次执行快照读，都会生成<br>    - <code>Repeatable Read（可重复读）</code>：仅在第一次快照都时生成，后续复用（<strong>注意：这里复用的只是ReadView，而不是数据，因为后续如果两次查询中间本事务修改了，也会读取到本事务修改后的数据，因为第一条规则</strong>），因为只有第一次时快照读，同时，如果在两次查询中间修改了该条数据，由于第一条匹配规则，还是会读取当前事务所修改的记录，而不是旧的数据(<strong>有解释一遍</strong>)。 </p>\n","abbrlink":"121cc63b","wordCount":59,"charCount":1539,"imgCount":3,"vidCount":0,"wsCount":0,"cbCount":0,"readTime":"约1分钟","excerpt":"","more":"<h3 id=\"1、MVCC-基本概念\"><a href=\"#1、MVCC-基本概念\" class=\"headerlink\" title=\"1、MVCC-基本概念\"></a>1、MVCC-基本概念</h3><ul>\n<li><p>当前读</p>\n<ul>\n<li><p>读取的时记录的<strong>最新版本</strong>，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁，对于我们日常的操作，如：</p>\n<p>select … lock in share mode(共享锁)，等就是一种当前读。</p>\n</li>\n</ul>\n</li>\n<li><p>快照读</p>\n<ul>\n<li>简单的 select(不加锁) 就是快照读，快照读的就是记录的可见版本，有可能是历史版本，不加锁，是非阻塞读。<ul>\n<li><code>Read Committed（读已提交）</code>：每次 <code>select</code>都生成一个快照</li>\n<li><code>Repeatable Read（可重复读）</code>：开启事务后的第一条<code>select</code>语句就是快照读，后续的<code>select</code>语句读取的就是第一次的快照因此才实现的可重复读。</li>\n<li><code>Serializable</code>：快照读会退化为当前读</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>MVCC</p>\n<ul>\n<li>全称 <code>Multi-Version-Concurrency Contry</code>，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log 、readView</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2、MVCC-实现原理\"><a href=\"#2、MVCC-实现原理\" class=\"headerlink\" title=\"2、MVCC-实现原理\"></a>2、MVCC-实现原理</h3><ul>\n<li><p>记录中的隐藏字段</p>\n<ul>\n<li><code>DB_TRX_ID</code>：最近修改事务ID，记录插入这条记录或最后一次修改该条记录的事务ID。</li>\n<li><code>DB_ROLL_PTR</code>：回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本。</li>\n<li><code>DB_ROW_ID</code>：隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。</li>\n</ul>\n<blockquote>\n<p>在 MySQL 中可以使用 ibd2sdi xxx.ibd 来查看ibd文件</p>\n</blockquote>\n</li>\n<li><p>undo log</p>\n<ul>\n<li><p>回滚日志，在insert、update、delete 的时候产生的便于数据回滚的日志。</p>\n<p>当<code>insert</code>的时候，产生的undo log 日志只在回滚时需要，在事务提交后，可被立即删除。而<code>update、delete</code> 的时候产生的日志，不仅在回滚的时候需要，在快照读时也需要，不会被立即删除。</p>\n</li>\n</ul>\n</li>\n<li><p>undo log 版本链</p>\n<p>不同事务或相同事务对同一条记录进行修改，会导致该记录的undo log 产生一条记录版本链，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</p>\n</li>\n</ul>\n<p><img src=\"/images/MySQL%E7%9A%84MVCC-01.png\" alt=\"MySQL的MVCC-01.png\"><br><img src=\"/images/MySQL%E7%9A%84MVCC-02.png\" alt=\"MySQL的MVCC-02.png\"></p>\n<ul>\n<li>readview<ul>\n<li><code>ReadView</code>(读视图)是 <strong>快照读</strong> ，就是一个<strong>快照</strong>，<strong>在进行快读时生成</strong>，SQL执行时MVCC提取数据的依据，记录并维护系统中当前活跃的事务（未提交）id。</li>\n<li>包含四个核心字段<ul>\n<li><code>m_ids</code>：当前活跃的事务id集合</li>\n<li><code>min_trx_id</code>：最小活跃事务id</li>\n<li><code>max_trx_id</code>：预分配事务id，当前最大事务id + 1</li>\n<li><code>creator_trx_id</code>：ReadView 创建者 id，<strong>每个快照读都会生成一个ReadView视图，因此都有一个对应的 creator_trx_id也即是当前事务的 id，这个字段只是存一下而不是生成，每个事务开始时，都生成自己对应的id</strong></li>\n</ul>\n</li>\n<li>具体的undo log 数据链访问规则。<ul>\n<li>首先明确 <code>trx_id</code>：就是数据库中该行数据的隐藏字段 <code>DB_TRX_ID</code> 的值。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/images/MySQL%E7%9A%84MVCC-03.png\" alt=\"MySQL的MVCC-03.png\"><br>    - 生成时机：<br>    - <code>Read Committed（读已提交）</code>：在事务中，每次执行快照读，都会生成<br>    - <code>Repeatable Read（可重复读）</code>：仅在第一次快照都时生成，后续复用（<strong>注意：这里复用的只是ReadView，而不是数据，因为后续如果两次查询中间本事务修改了，也会读取到本事务修改后的数据，因为第一条规则</strong>），因为只有第一次时快照读，同时，如果在两次查询中间修改了该条数据，由于第一条匹配规则，还是会读取当前事务所修改的记录，而不是旧的数据(<strong>有解释一遍</strong>)。 </p>\n"},{"title":"HashMap集合","description":"文章缩略，支持 `Markdown` **文档格式**\n","pinned":0,"lang":"zh","type":"post","wordCount":377,"charCount":5024,"imgCount":0,"vidCount":0,"wsCount":0,"cbCount":2,"readTime":"约3分钟","abbrlink":"43ade6e4","date":"2025-10-27T14:26:27.000Z","_content":"### 1、HashMap 的底层数据结构是什么?\n\n​      在JDK 8 之前，主要通过数组 + 链表的方式实现。在JDK 8之后，主要通过数组 + 链表 + 红黑树的方式实现。核心变量为Node 类型的数组 table 变量。由 transient 修饰，并重写了readObject 和 writeObject 方法实现序列化相关操作。\n\n### 2、HashMap 是如何解决哈希冲突的?\n\n​      由于通过键哈希值的运算来确定元素在table中的位置，当出现不同键的哈希值相同时，会产生哈希冲突，主要通过链地址法来解决。也就是在数组对应的位置形成链表，而对于链表结点的插入采用的是尾插法，防止在多线程模式下出现循环链表的问题。\n\n### 3、HashMap 的 put 方法的过程\n\n- **首先**，是计算hash值，即：通过将键的hash值的低16异或上高16位。\n\n- **其次**，计算该元素在哈希桶中的位置，即：将数组的长度 - 1 & 上二次哈希值作为该元素在数组中的下标。\n\n- **然后**：判断下标位置的元素情况，即：\n\n    - 如果当前位置没有元素，则直接创建node对象并存储hash值，防止二次计算，然后将当前元素储存在当前下标的位置；\n\n    - 如果当前位置有元素，就以hash值、key的引用地址，key的equales方法的比较顺序来判断key是否相同；\n\n        - 如果有一个成立，则表示key值相同，即触发替换效果，将原位置的元素的value值替换为当前元素的value 值。\n\n        - 如果判断 key 不相同，（省略：就先判断是否为树结构，如果是）继续按照之前的比较顺序遍历整个链表。\n\n            - 当发现键相同时，也是执行替换操作。\n\n            - 当遍历到最后一个时，回在最后一个结点的尾部创建一个新的Node结点。（省略：并判断当前位置的链表的长度是否大于8，当大于 8 时，则尝试树形化，在树形化的内部，会判断哈希桶的长度是否大于64，如果不是，则直接扩容，否则进行树形化）\n\n- **最后**：都会检查size是否超过扩容阈值，如果超过，则进行扩容。而put方法的返回值是当发成替换时，返回的是旧值，发生插入时，返回的是原位置的值，也就是null。\n\n- 源码展示：\n\n  ```java\n  /*添加元素源码*/\n  final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) {\n          Node<K,V>[] tab; Node<K,V> p; int n, i;\n          if ((tab = table) == null || (n = tab.length) == 0) //判断是否需要扩容\n              n = (tab = resize()).length; //执行扩容\n          if ((p = tab[i = (n - 1) & hash]) == null)  //判断要插入的位置是否存在元素\n              tab[i] = newNode(hash, key, value, null); //如果不存在，直在该数组的该位置上添加\n          else { //该位置上存在元素，判断该元素的键是否与要插入的元素的键相同\n              Node<K,V> e; K k;\n              //1、先比较hash值，如果hash不相同，则键一定不相同\n              //2、再比较键\n              \t//1、先比较键的地址\n              \t//2、最后在比较键的内容\n              //最后得出，键是否相同\n              if (p.hash == hash \n                  && ((k = p.key) == key || (key != null && key.equals(k))))\n                  e = p; //如果键相同\n              else if (p instanceof TreeNode) //如果键不相同、判断是否为树形结构\n                  e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);//是树结构\n              else {  //如果键不相同、不为树形结构\n                  for (int binCount = 0; ; ++binCount) {\n                      if ((e = p.next) == null) { //判断下一个元素是否为空\n                          p.next = newNode(hash, key, value, null); //为空，尾插法\n                          if (binCount >= TREEIFY_THRESHOLD - 1) // 判断是否需要树形化\n                              treeifyBin(tab, hash); //执行树形化\n                          break;\n                      }\n                      //不为空，判断该位置上的链表的键是否相同，相同直接跳出循环做修改操作\n                      if (e.hash == hash &&\n                          ((k = e.key) == key || (key != null && key.equals(k))))\n                          break; \n                      p = e; //给 p 更新，继续比较\n                  }\n              }\n              if (e != null) { // 键相同、执行修改操作,如果是新增操作，e必为null\n                  V oldValue = e.value; //获取到该位置上的值\n                  if (!onlyIfAbsent || oldValue == null)\n                      e.value = value; //将该位置上的值替换为新的值\n                  afterNodeAccess(e);  \n                  return oldValue; //返回旧值\n              }\n          }\n          ++modCount;\n          if (++size > threshold) //元素个数记录+1，判断是否需要扩容\n              resize();  //执行扩容\n          afterNodeInsertion(evict);\n          return null;\n      }\n  ```\n\n\n\n### 4、HashMap的扩容机制？\n\n- 首先，是当哈希桶没有初始化或者哈希桶的长度为 0 时，进行初始化扩容。\n\n    - 即：设置默认的哈希桶的长度为16，扩容阈值是 12 由 数组长度×负载因子，负载因子默认是0.75。然后创建长度为16的node结点对象并赋值给哈希桶即可。\n- 然后，是当哈希桶中的元素个数大于了扩容阈值时会触发扩容机制。\n    - 首先，确定新数组的长度以及扩容阈值：新数组的长度为原来的**2倍**，扩容阈值也变为原来的**2倍**\n    - 然后，循环遍历原数组中所有非空元素\n        - 如果该元素没有形成链表，则直接用元素的hash值 & 上新数组的长度 - 1，作为在新数组中的位置。（这也就是哈希桶的长度为什么是 2 的幂次方，因为计算元素在哈希桶中的位置非常方便）\n        - 如果改元素的 next 指针不为空，则进行结点的迁移。\n            - 1）对于链表来说\n                - 首先定义高位链表和低位链表。\n                - 然后，循环遍历链表上的所有结点。对于链表上的结点按照哈希值与原数组的长度做 & 运算的结果是否为 0 ，分为地位链表和高位链表，进而重新分配地位链表和高位链表在数组中的位置来使元素分布均匀。具体的过程以高位链表为例：先判断高位链表的尾结点是否为空，如果为空则为头节点赋初始值，反之则为尾结点的next指针赋值，最后都要将当前遍历的结点赋值给尾结点。最后将低位链表插入到新哈希桶中与原下标相同的位置，而高位链表则插入到新哈希桶中原下标 + 原数组长度的位置。\n            - 2）对于红黑树，则是调用树分裂的方法，先将树分为两个链表，对于链表中元素个数小于等于 6 的，直接转换为链表，如果大于6，则进行树形化。\n\n- 源码展示：\n\n  ```java\n  /*扩容源码*/\n  final Node<K,V>[] resize() {\n          Node<K,V>[] oldTab = table; //将数组赋值给临时变量\n          int oldCap = (oldTab == null) ? 0 : oldTab.length; //获取数组的长度\n          int oldThr = threshold; //获取扩容的临界点\n          int newCap, newThr = 0; //定义新的长度和扩容的临界点\n          if (oldCap > 0) { //判断数组长度是否大于 0，更新临界点和数组长度\n              if (oldCap >= MAXIMUM_CAPACITY) { //判断是否超出最大容量\n                  threshold = Integer.MAX_VALUE;\n                  return oldTab; //如果超出了，就不扩容，直接返回\n              }\n              else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                       oldCap >= DEFAULT_INITIAL_CAPACITY) //将新的长度为原长度的 2 倍\n                  newThr = oldThr << 1; // 新的临界点为原来临界点的 2 倍\n          }\n          else if (oldThr > 0) // 初始容量置于阈值，用于应对自定义初始值\n              newCap = oldThr;\n          else {               // 零初始阈值表示使用默认值，用于处理默认情况\n              newCap = DEFAULT_INITIAL_CAPACITY; //默认长度为 16\n              newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n              //临界值为默认长度*加载因子\n          }\n          if (newThr == 0) { //用于应对自定义负载因子\n              float ft = (float)newCap * loadFactor;\n              newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                        (int)ft : Integer.MAX_VALUE);\n          }\n          threshold = newThr; //更新临界值\n          @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n          Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap]; //创建新的数组\n          table = newTab; //将原数组指向该新的长度的数组\n          if (oldTab != null) { //用于应对第一次添加的情况\n              //源码赋值hashMap的逻辑\n              for (int j = 0; j < oldCap; ++j) {\n                  Node<K,V> e;  //创建新的节点\n                  if ((e = oldTab[j]) != null) { //判断旧数组上该位置的节点是否为空\n                      oldTab[j] = null;\n                      if (e.next == null) //如果下一个节点为空，即：该位置上就一个元素\n                          newTab[e.hash & (newCap - 1)] = e; //计算在新数组中的位置并放入\n                      else if (e instanceof TreeNode) //如果下一个有元素，判断是否为树形\n                          ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                      else { // 是链表\n                          Node<K,V> loHead = null, loTail = null;\n                          Node<K,V> hiHead = null, hiTail = null;\n                          Node<K,V> next;\n                          do {\n                              next = e.next;\n                              if ((e.hash & oldCap) == 0) { \n                                  //判断是否需要移动，因为在计算位置时，e.hash & (oldCap-1)\n                                  //在增加为容量后，新的容量是2的倍数，因此，之后的位置是原来的二进制\n                                  //加 1，原 1111 先 10000 因此，只需要比较最高位的 1 是否影向\n                                  //而oldCap是2的倍数，因此只有一个1其余是0,16 = 0000 1000\n                                  //因此，如果取与不为0，说名根据hsah值计算的位置与原来的位置不一样\n                                  //需要移动，同样，只要是需要移动的，要移动的位置都一样，因为都是同一\n                                  //个高位二进制为 1\n                                  if (loTail == null)\n                                      loHead = e;\n                                  else\n                                      loTail.next = e;\n                                  loTail = e;\n                              }\n                              else {\n                                  if (hiTail == null)\n                                      hiHead = e;\n                                  else\n                                      hiTail.next = e;\n                                  hiTail = e;\n                              }\n                          } while ((e = next) != null);\n                          if (loTail != null) {  //将不需要移动的节点直接放入该数组下\n                              loTail.next = null;\n                              newTab[j] = loHead;\n                          }\n                          if (hiTail != null) { //将需要移动的链表放入新的数组的空间下\n                              hiTail.next = null;\n                              //由于需要移动，因此高位二进制一定是 1，因此用hash值于新数组计算后\n                              //位置是确定的，增加了oldCap的长度，故，这里不用再次计算为位置，直接用\n                              newTab[j + oldCap] = hiHead;\n                          }\n                      }\n                  }\n              }\n          }\n          return newTab;\n      }\n  ```\n\n\n\n### 5、为什么负载因子是0.75？\n\n​     因为是在时间和空间之间，经过大量计算和实验权衡后的一个最优值。在减少哈希冲突的同时，避免频繁的扩容。\n\n### 6、HashMap 是线程安全的吗？\n\n​      不是，可以用并发工具包的SynchroizedMap包装hashMap，或者直接使用CurrentHashMap。\n\n### 7、HashMapJDK8 和 JDK 7的区别\n\n​      数据结构：从数组 + 链表 ==》数组 + 链表 + 红黑树\n\n​      插入方式：头插法 ==》尾插法\n\n​      迁移原理：重新计算hash ==》按照高低位拆分\n\n### 8、HashMap的内存泄漏？\n\n​      若key对象重写了equels()方法，但是没有重写hashCode()方法，可能无法正确定位元素，造成内存占用不能释放。例如：对于放入两个键相同的对象，此时应表现为修改，但是由于没有重写hashCode()方法，导致hash值不同，而判断是先判断hash值，再判断equals()，因此此时表现为插入元素，而当利用键来删除其中的一个元素时，另一个元素则会被留下（因为哈希值不同），造成内存泄漏。\n\n### 9、key 的值可以为null吗？\n\n​      可以，null 键的hash固定为 0，会被放入列表的第一个位置。","source":"_posts/HashMap集合.md","raw":"---\ntitle: HashMap集合\ntags:\n  - HashMap\ndescription: |\n  文章缩略，支持 `Markdown` **文档格式**\npinned: 0\nlang: zh\ncategories:\n  - Java 基础篇\ntype: post\nwordCount: 377\ncharCount: 5024\nimgCount: 0\nvidCount: 0\nwsCount: 0\ncbCount: 2\nreadTime: 约3分钟\nabbrlink: 43ade6e4\ndate: 2025-10-27 22:26:27\n---\n### 1、HashMap 的底层数据结构是什么?\n\n​      在JDK 8 之前，主要通过数组 + 链表的方式实现。在JDK 8之后，主要通过数组 + 链表 + 红黑树的方式实现。核心变量为Node 类型的数组 table 变量。由 transient 修饰，并重写了readObject 和 writeObject 方法实现序列化相关操作。\n\n### 2、HashMap 是如何解决哈希冲突的?\n\n​      由于通过键哈希值的运算来确定元素在table中的位置，当出现不同键的哈希值相同时，会产生哈希冲突，主要通过链地址法来解决。也就是在数组对应的位置形成链表，而对于链表结点的插入采用的是尾插法，防止在多线程模式下出现循环链表的问题。\n\n### 3、HashMap 的 put 方法的过程\n\n- **首先**，是计算hash值，即：通过将键的hash值的低16异或上高16位。\n\n- **其次**，计算该元素在哈希桶中的位置，即：将数组的长度 - 1 & 上二次哈希值作为该元素在数组中的下标。\n\n- **然后**：判断下标位置的元素情况，即：\n\n    - 如果当前位置没有元素，则直接创建node对象并存储hash值，防止二次计算，然后将当前元素储存在当前下标的位置；\n\n    - 如果当前位置有元素，就以hash值、key的引用地址，key的equales方法的比较顺序来判断key是否相同；\n\n        - 如果有一个成立，则表示key值相同，即触发替换效果，将原位置的元素的value值替换为当前元素的value 值。\n\n        - 如果判断 key 不相同，（省略：就先判断是否为树结构，如果是）继续按照之前的比较顺序遍历整个链表。\n\n            - 当发现键相同时，也是执行替换操作。\n\n            - 当遍历到最后一个时，回在最后一个结点的尾部创建一个新的Node结点。（省略：并判断当前位置的链表的长度是否大于8，当大于 8 时，则尝试树形化，在树形化的内部，会判断哈希桶的长度是否大于64，如果不是，则直接扩容，否则进行树形化）\n\n- **最后**：都会检查size是否超过扩容阈值，如果超过，则进行扩容。而put方法的返回值是当发成替换时，返回的是旧值，发生插入时，返回的是原位置的值，也就是null。\n\n- 源码展示：\n\n  ```java\n  /*添加元素源码*/\n  final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) {\n          Node<K,V>[] tab; Node<K,V> p; int n, i;\n          if ((tab = table) == null || (n = tab.length) == 0) //判断是否需要扩容\n              n = (tab = resize()).length; //执行扩容\n          if ((p = tab[i = (n - 1) & hash]) == null)  //判断要插入的位置是否存在元素\n              tab[i] = newNode(hash, key, value, null); //如果不存在，直在该数组的该位置上添加\n          else { //该位置上存在元素，判断该元素的键是否与要插入的元素的键相同\n              Node<K,V> e; K k;\n              //1、先比较hash值，如果hash不相同，则键一定不相同\n              //2、再比较键\n              \t//1、先比较键的地址\n              \t//2、最后在比较键的内容\n              //最后得出，键是否相同\n              if (p.hash == hash \n                  && ((k = p.key) == key || (key != null && key.equals(k))))\n                  e = p; //如果键相同\n              else if (p instanceof TreeNode) //如果键不相同、判断是否为树形结构\n                  e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);//是树结构\n              else {  //如果键不相同、不为树形结构\n                  for (int binCount = 0; ; ++binCount) {\n                      if ((e = p.next) == null) { //判断下一个元素是否为空\n                          p.next = newNode(hash, key, value, null); //为空，尾插法\n                          if (binCount >= TREEIFY_THRESHOLD - 1) // 判断是否需要树形化\n                              treeifyBin(tab, hash); //执行树形化\n                          break;\n                      }\n                      //不为空，判断该位置上的链表的键是否相同，相同直接跳出循环做修改操作\n                      if (e.hash == hash &&\n                          ((k = e.key) == key || (key != null && key.equals(k))))\n                          break; \n                      p = e; //给 p 更新，继续比较\n                  }\n              }\n              if (e != null) { // 键相同、执行修改操作,如果是新增操作，e必为null\n                  V oldValue = e.value; //获取到该位置上的值\n                  if (!onlyIfAbsent || oldValue == null)\n                      e.value = value; //将该位置上的值替换为新的值\n                  afterNodeAccess(e);  \n                  return oldValue; //返回旧值\n              }\n          }\n          ++modCount;\n          if (++size > threshold) //元素个数记录+1，判断是否需要扩容\n              resize();  //执行扩容\n          afterNodeInsertion(evict);\n          return null;\n      }\n  ```\n\n\n\n### 4、HashMap的扩容机制？\n\n- 首先，是当哈希桶没有初始化或者哈希桶的长度为 0 时，进行初始化扩容。\n\n    - 即：设置默认的哈希桶的长度为16，扩容阈值是 12 由 数组长度×负载因子，负载因子默认是0.75。然后创建长度为16的node结点对象并赋值给哈希桶即可。\n- 然后，是当哈希桶中的元素个数大于了扩容阈值时会触发扩容机制。\n    - 首先，确定新数组的长度以及扩容阈值：新数组的长度为原来的**2倍**，扩容阈值也变为原来的**2倍**\n    - 然后，循环遍历原数组中所有非空元素\n        - 如果该元素没有形成链表，则直接用元素的hash值 & 上新数组的长度 - 1，作为在新数组中的位置。（这也就是哈希桶的长度为什么是 2 的幂次方，因为计算元素在哈希桶中的位置非常方便）\n        - 如果改元素的 next 指针不为空，则进行结点的迁移。\n            - 1）对于链表来说\n                - 首先定义高位链表和低位链表。\n                - 然后，循环遍历链表上的所有结点。对于链表上的结点按照哈希值与原数组的长度做 & 运算的结果是否为 0 ，分为地位链表和高位链表，进而重新分配地位链表和高位链表在数组中的位置来使元素分布均匀。具体的过程以高位链表为例：先判断高位链表的尾结点是否为空，如果为空则为头节点赋初始值，反之则为尾结点的next指针赋值，最后都要将当前遍历的结点赋值给尾结点。最后将低位链表插入到新哈希桶中与原下标相同的位置，而高位链表则插入到新哈希桶中原下标 + 原数组长度的位置。\n            - 2）对于红黑树，则是调用树分裂的方法，先将树分为两个链表，对于链表中元素个数小于等于 6 的，直接转换为链表，如果大于6，则进行树形化。\n\n- 源码展示：\n\n  ```java\n  /*扩容源码*/\n  final Node<K,V>[] resize() {\n          Node<K,V>[] oldTab = table; //将数组赋值给临时变量\n          int oldCap = (oldTab == null) ? 0 : oldTab.length; //获取数组的长度\n          int oldThr = threshold; //获取扩容的临界点\n          int newCap, newThr = 0; //定义新的长度和扩容的临界点\n          if (oldCap > 0) { //判断数组长度是否大于 0，更新临界点和数组长度\n              if (oldCap >= MAXIMUM_CAPACITY) { //判断是否超出最大容量\n                  threshold = Integer.MAX_VALUE;\n                  return oldTab; //如果超出了，就不扩容，直接返回\n              }\n              else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                       oldCap >= DEFAULT_INITIAL_CAPACITY) //将新的长度为原长度的 2 倍\n                  newThr = oldThr << 1; // 新的临界点为原来临界点的 2 倍\n          }\n          else if (oldThr > 0) // 初始容量置于阈值，用于应对自定义初始值\n              newCap = oldThr;\n          else {               // 零初始阈值表示使用默认值，用于处理默认情况\n              newCap = DEFAULT_INITIAL_CAPACITY; //默认长度为 16\n              newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n              //临界值为默认长度*加载因子\n          }\n          if (newThr == 0) { //用于应对自定义负载因子\n              float ft = (float)newCap * loadFactor;\n              newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                        (int)ft : Integer.MAX_VALUE);\n          }\n          threshold = newThr; //更新临界值\n          @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n          Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap]; //创建新的数组\n          table = newTab; //将原数组指向该新的长度的数组\n          if (oldTab != null) { //用于应对第一次添加的情况\n              //源码赋值hashMap的逻辑\n              for (int j = 0; j < oldCap; ++j) {\n                  Node<K,V> e;  //创建新的节点\n                  if ((e = oldTab[j]) != null) { //判断旧数组上该位置的节点是否为空\n                      oldTab[j] = null;\n                      if (e.next == null) //如果下一个节点为空，即：该位置上就一个元素\n                          newTab[e.hash & (newCap - 1)] = e; //计算在新数组中的位置并放入\n                      else if (e instanceof TreeNode) //如果下一个有元素，判断是否为树形\n                          ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                      else { // 是链表\n                          Node<K,V> loHead = null, loTail = null;\n                          Node<K,V> hiHead = null, hiTail = null;\n                          Node<K,V> next;\n                          do {\n                              next = e.next;\n                              if ((e.hash & oldCap) == 0) { \n                                  //判断是否需要移动，因为在计算位置时，e.hash & (oldCap-1)\n                                  //在增加为容量后，新的容量是2的倍数，因此，之后的位置是原来的二进制\n                                  //加 1，原 1111 先 10000 因此，只需要比较最高位的 1 是否影向\n                                  //而oldCap是2的倍数，因此只有一个1其余是0,16 = 0000 1000\n                                  //因此，如果取与不为0，说名根据hsah值计算的位置与原来的位置不一样\n                                  //需要移动，同样，只要是需要移动的，要移动的位置都一样，因为都是同一\n                                  //个高位二进制为 1\n                                  if (loTail == null)\n                                      loHead = e;\n                                  else\n                                      loTail.next = e;\n                                  loTail = e;\n                              }\n                              else {\n                                  if (hiTail == null)\n                                      hiHead = e;\n                                  else\n                                      hiTail.next = e;\n                                  hiTail = e;\n                              }\n                          } while ((e = next) != null);\n                          if (loTail != null) {  //将不需要移动的节点直接放入该数组下\n                              loTail.next = null;\n                              newTab[j] = loHead;\n                          }\n                          if (hiTail != null) { //将需要移动的链表放入新的数组的空间下\n                              hiTail.next = null;\n                              //由于需要移动，因此高位二进制一定是 1，因此用hash值于新数组计算后\n                              //位置是确定的，增加了oldCap的长度，故，这里不用再次计算为位置，直接用\n                              newTab[j + oldCap] = hiHead;\n                          }\n                      }\n                  }\n              }\n          }\n          return newTab;\n      }\n  ```\n\n\n\n### 5、为什么负载因子是0.75？\n\n​     因为是在时间和空间之间，经过大量计算和实验权衡后的一个最优值。在减少哈希冲突的同时，避免频繁的扩容。\n\n### 6、HashMap 是线程安全的吗？\n\n​      不是，可以用并发工具包的SynchroizedMap包装hashMap，或者直接使用CurrentHashMap。\n\n### 7、HashMapJDK8 和 JDK 7的区别\n\n​      数据结构：从数组 + 链表 ==》数组 + 链表 + 红黑树\n\n​      插入方式：头插法 ==》尾插法\n\n​      迁移原理：重新计算hash ==》按照高低位拆分\n\n### 8、HashMap的内存泄漏？\n\n​      若key对象重写了equels()方法，但是没有重写hashCode()方法，可能无法正确定位元素，造成内存占用不能释放。例如：对于放入两个键相同的对象，此时应表现为修改，但是由于没有重写hashCode()方法，导致hash值不同，而判断是先判断hash值，再判断equals()，因此此时表现为插入元素，而当利用键来删除其中的一个元素时，另一个元素则会被留下（因为哈希值不同），造成内存泄漏。\n\n### 9、key 的值可以为null吗？\n\n​      可以，null 键的hash固定为 0，会被放入列表的第一个位置。","slug":"HashMap集合","published":1,"updated":"2025-10-27T14:28:11.541Z","comments":1,"layout":"post","photos":[],"_id":"cuidH0iBEePQ64dikmK-KHJeU","content":"<h3 id=\"1、HashMap-的底层数据结构是什么\"><a href=\"#1、HashMap-的底层数据结构是什么\" class=\"headerlink\" title=\"1、HashMap 的底层数据结构是什么?\"></a>1、HashMap 的底层数据结构是什么?</h3><p>​      在JDK 8 之前，主要通过数组 + 链表的方式实现。在JDK 8之后，主要通过数组 + 链表 + 红黑树的方式实现。核心变量为Node 类型的数组 table 变量。由 transient 修饰，并重写了readObject 和 writeObject 方法实现序列化相关操作。</p>\n<h3 id=\"2、HashMap-是如何解决哈希冲突的\"><a href=\"#2、HashMap-是如何解决哈希冲突的\" class=\"headerlink\" title=\"2、HashMap 是如何解决哈希冲突的?\"></a>2、HashMap 是如何解决哈希冲突的?</h3><p>​      由于通过键哈希值的运算来确定元素在table中的位置，当出现不同键的哈希值相同时，会产生哈希冲突，主要通过链地址法来解决。也就是在数组对应的位置形成链表，而对于链表结点的插入采用的是尾插法，防止在多线程模式下出现循环链表的问题。</p>\n<h3 id=\"3、HashMap-的-put-方法的过程\"><a href=\"#3、HashMap-的-put-方法的过程\" class=\"headerlink\" title=\"3、HashMap 的 put 方法的过程\"></a>3、HashMap 的 put 方法的过程</h3><ul>\n<li><p><strong>首先</strong>，是计算hash值，即：通过将键的hash值的低16异或上高16位。</p>\n</li>\n<li><p><strong>其次</strong>，计算该元素在哈希桶中的位置，即：将数组的长度 - 1 &amp; 上二次哈希值作为该元素在数组中的下标。</p>\n</li>\n<li><p><strong>然后</strong>：判断下标位置的元素情况，即：</p>\n<ul>\n<li><p>如果当前位置没有元素，则直接创建node对象并存储hash值，防止二次计算，然后将当前元素储存在当前下标的位置；</p>\n</li>\n<li><p>如果当前位置有元素，就以hash值、key的引用地址，key的equales方法的比较顺序来判断key是否相同；</p>\n<ul>\n<li><p>如果有一个成立，则表示key值相同，即触发替换效果，将原位置的元素的value值替换为当前元素的value 值。</p>\n</li>\n<li><p>如果判断 key 不相同，（省略：就先判断是否为树结构，如果是）继续按照之前的比较顺序遍历整个链表。</p>\n<ul>\n<li><p>当发现键相同时，也是执行替换操作。</p>\n</li>\n<li><p>当遍历到最后一个时，回在最后一个结点的尾部创建一个新的Node结点。（省略：并判断当前位置的链表的长度是否大于8，当大于 8 时，则尝试树形化，在树形化的内部，会判断哈希桶的长度是否大于64，如果不是，则直接扩容，否则进行树形化）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>最后</strong>：都会检查size是否超过扩容阈值，如果超过，则进行扩容。而put方法的返回值是当发成替换时，返回的是旧值，发生插入时，返回的是原位置的值，也就是null。</p>\n</li>\n<li><p>源码展示：</p>\n<pre><code class=\"language-java\">/*添加元素源码*/\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) {\n        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;\n        if ((tab = table) == null || (n = tab.length) == 0) //判断是否需要扩容\n            n = (tab = resize()).length; //执行扩容\n        if ((p = tab[i = (n - 1) &amp; hash]) == null)  //判断要插入的位置是否存在元素\n            tab[i] = newNode(hash, key, value, null); //如果不存在，直在该数组的该位置上添加\n        else { //该位置上存在元素，判断该元素的键是否与要插入的元素的键相同\n            Node&lt;K,V&gt; e; K k;\n            //1、先比较hash值，如果hash不相同，则键一定不相同\n            //2、再比较键\n                //1、先比较键的地址\n                //2、最后在比较键的内容\n            //最后得出，键是否相同\n            if (p.hash == hash \n                &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))\n                e = p; //如果键相同\n            else if (p instanceof TreeNode) //如果键不相同、判断是否为树形结构\n                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);//是树结构\n            else {  //如果键不相同、不为树形结构\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) { //判断下一个元素是否为空\n                        p.next = newNode(hash, key, value, null); //为空，尾插法\n                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // 判断是否需要树形化\n                            treeifyBin(tab, hash); //执行树形化\n                        break;\n                    }\n                    //不为空，判断该位置上的链表的键是否相同，相同直接跳出循环做修改操作\n                    if (e.hash == hash &amp;&amp;\n                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n                        break; \n                    p = e; //给 p 更新，继续比较\n                }\n            }\n            if (e != null) { // 键相同、执行修改操作,如果是新增操作，e必为null\n                V oldValue = e.value; //获取到该位置上的值\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value; //将该位置上的值替换为新的值\n                afterNodeAccess(e);  \n                return oldValue; //返回旧值\n            }\n        }\n        ++modCount;\n        if (++size &gt; threshold) //元素个数记录+1，判断是否需要扩容\n            resize();  //执行扩容\n        afterNodeInsertion(evict);\n        return null;\n    }\n</code></pre>\n</li>\n</ul>\n<h3 id=\"4、HashMap的扩容机制？\"><a href=\"#4、HashMap的扩容机制？\" class=\"headerlink\" title=\"4、HashMap的扩容机制？\"></a>4、HashMap的扩容机制？</h3><ul>\n<li><p>首先，是当哈希桶没有初始化或者哈希桶的长度为 0 时，进行初始化扩容。</p>\n<ul>\n<li>即：设置默认的哈希桶的长度为16，扩容阈值是 12 由 数组长度×负载因子，负载因子默认是0.75。然后创建长度为16的node结点对象并赋值给哈希桶即可。</li>\n</ul>\n</li>\n<li><p>然后，是当哈希桶中的元素个数大于了扩容阈值时会触发扩容机制。</p>\n<ul>\n<li>首先，确定新数组的长度以及扩容阈值：新数组的长度为原来的<strong>2倍</strong>，扩容阈值也变为原来的<strong>2倍</strong></li>\n<li>然后，循环遍历原数组中所有非空元素<ul>\n<li>如果该元素没有形成链表，则直接用元素的hash值 &amp; 上新数组的长度 - 1，作为在新数组中的位置。（这也就是哈希桶的长度为什么是 2 的幂次方，因为计算元素在哈希桶中的位置非常方便）</li>\n<li>如果改元素的 next 指针不为空，则进行结点的迁移。<ul>\n<li>1）对于链表来说<ul>\n<li>首先定义高位链表和低位链表。</li>\n<li>然后，循环遍历链表上的所有结点。对于链表上的结点按照哈希值与原数组的长度做 &amp; 运算的结果是否为 0 ，分为地位链表和高位链表，进而重新分配地位链表和高位链表在数组中的位置来使元素分布均匀。具体的过程以高位链表为例：先判断高位链表的尾结点是否为空，如果为空则为头节点赋初始值，反之则为尾结点的next指针赋值，最后都要将当前遍历的结点赋值给尾结点。最后将低位链表插入到新哈希桶中与原下标相同的位置，而高位链表则插入到新哈希桶中原下标 + 原数组长度的位置。</li>\n</ul>\n</li>\n<li>2）对于红黑树，则是调用树分裂的方法，先将树分为两个链表，对于链表中元素个数小于等于 6 的，直接转换为链表，如果大于6，则进行树形化。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>源码展示：</p>\n<pre><code class=\"language-java\">/*扩容源码*/\nfinal Node&lt;K,V&gt;[] resize() {\n        Node&lt;K,V&gt;[] oldTab = table; //将数组赋值给临时变量\n        int oldCap = (oldTab == null) ? 0 : oldTab.length; //获取数组的长度\n        int oldThr = threshold; //获取扩容的临界点\n        int newCap, newThr = 0; //定义新的长度和扩容的临界点\n        if (oldCap &gt; 0) { //判断数组长度是否大于 0，更新临界点和数组长度\n            if (oldCap &gt;= MAXIMUM_CAPACITY) { //判断是否超出最大容量\n                threshold = Integer.MAX_VALUE;\n                return oldTab; //如果超出了，就不扩容，直接返回\n            }\n            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;\n                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY) //将新的长度为原长度的 2 倍\n                newThr = oldThr &lt;&lt; 1; // 新的临界点为原来临界点的 2 倍\n        }\n        else if (oldThr &gt; 0) // 初始容量置于阈值，用于应对自定义初始值\n            newCap = oldThr;\n        else {               // 零初始阈值表示使用默认值，用于处理默认情况\n            newCap = DEFAULT_INITIAL_CAPACITY; //默认长度为 16\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n            //临界值为默认长度*加载因子\n        }\n        if (newThr == 0) { //用于应对自定义负载因子\n            float ft = (float)newCap * loadFactor;\n            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE);\n        }\n        threshold = newThr; //更新临界值\n        @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})\n        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; //创建新的数组\n        table = newTab; //将原数组指向该新的长度的数组\n        if (oldTab != null) { //用于应对第一次添加的情况\n            //源码赋值hashMap的逻辑\n            for (int j = 0; j &lt; oldCap; ++j) {\n                Node&lt;K,V&gt; e;  //创建新的节点\n                if ((e = oldTab[j]) != null) { //判断旧数组上该位置的节点是否为空\n                    oldTab[j] = null;\n                    if (e.next == null) //如果下一个节点为空，即：该位置上就一个元素\n                        newTab[e.hash &amp; (newCap - 1)] = e; //计算在新数组中的位置并放入\n                    else if (e instanceof TreeNode) //如果下一个有元素，判断是否为树形\n                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);\n                    else { // 是链表\n                        Node&lt;K,V&gt; loHead = null, loTail = null;\n                        Node&lt;K,V&gt; hiHead = null, hiTail = null;\n                        Node&lt;K,V&gt; next;\n                        do {\n                            next = e.next;\n                            if ((e.hash &amp; oldCap) == 0) { \n                                //判断是否需要移动，因为在计算位置时，e.hash &amp; (oldCap-1)\n                                //在增加为容量后，新的容量是2的倍数，因此，之后的位置是原来的二进制\n                                //加 1，原 1111 先 10000 因此，只需要比较最高位的 1 是否影向\n                                //而oldCap是2的倍数，因此只有一个1其余是0,16 = 0000 1000\n                                //因此，如果取与不为0，说名根据hsah值计算的位置与原来的位置不一样\n                                //需要移动，同样，只要是需要移动的，要移动的位置都一样，因为都是同一\n                                //个高位二进制为 1\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            }\n                            else {\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            }\n                        } while ((e = next) != null);\n                        if (loTail != null) {  //将不需要移动的节点直接放入该数组下\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        }\n                        if (hiTail != null) { //将需要移动的链表放入新的数组的空间下\n                            hiTail.next = null;\n                            //由于需要移动，因此高位二进制一定是 1，因此用hash值于新数组计算后\n                            //位置是确定的，增加了oldCap的长度，故，这里不用再次计算为位置，直接用\n                            newTab[j + oldCap] = hiHead;\n                        }\n                    }\n                }\n            }\n        }\n        return newTab;\n    }\n</code></pre>\n</li>\n</ul>\n<h3 id=\"5、为什么负载因子是0-75？\"><a href=\"#5、为什么负载因子是0-75？\" class=\"headerlink\" title=\"5、为什么负载因子是0.75？\"></a>5、为什么负载因子是0.75？</h3><p>​     因为是在时间和空间之间，经过大量计算和实验权衡后的一个最优值。在减少哈希冲突的同时，避免频繁的扩容。</p>\n<h3 id=\"6、HashMap-是线程安全的吗？\"><a href=\"#6、HashMap-是线程安全的吗？\" class=\"headerlink\" title=\"6、HashMap 是线程安全的吗？\"></a>6、HashMap 是线程安全的吗？</h3><p>​      不是，可以用并发工具包的SynchroizedMap包装hashMap，或者直接使用CurrentHashMap。</p>\n<h3 id=\"7、HashMapJDK8-和-JDK-7的区别\"><a href=\"#7、HashMapJDK8-和-JDK-7的区别\" class=\"headerlink\" title=\"7、HashMapJDK8 和 JDK 7的区别\"></a>7、HashMapJDK8 和 JDK 7的区别</h3><p>​      数据结构：从数组 + 链表 &#x3D;&#x3D;》数组 + 链表 + 红黑树</p>\n<p>​      插入方式：头插法 &#x3D;&#x3D;》尾插法</p>\n<p>​      迁移原理：重新计算hash &#x3D;&#x3D;》按照高低位拆分</p>\n<h3 id=\"8、HashMap的内存泄漏？\"><a href=\"#8、HashMap的内存泄漏？\" class=\"headerlink\" title=\"8、HashMap的内存泄漏？\"></a>8、HashMap的内存泄漏？</h3><p>​      若key对象重写了equels()方法，但是没有重写hashCode()方法，可能无法正确定位元素，造成内存占用不能释放。例如：对于放入两个键相同的对象，此时应表现为修改，但是由于没有重写hashCode()方法，导致hash值不同，而判断是先判断hash值，再判断equals()，因此此时表现为插入元素，而当利用键来删除其中的一个元素时，另一个元素则会被留下（因为哈希值不同），造成内存泄漏。</p>\n<h3 id=\"9、key-的值可以为null吗？\"><a href=\"#9、key-的值可以为null吗？\" class=\"headerlink\" title=\"9、key 的值可以为null吗？\"></a>9、key 的值可以为null吗？</h3><p>​      可以，null 键的hash固定为 0，会被放入列表的第一个位置。</p>\n","excerpt":"","more":"<h3 id=\"1、HashMap-的底层数据结构是什么\"><a href=\"#1、HashMap-的底层数据结构是什么\" class=\"headerlink\" title=\"1、HashMap 的底层数据结构是什么?\"></a>1、HashMap 的底层数据结构是什么?</h3><p>​      在JDK 8 之前，主要通过数组 + 链表的方式实现。在JDK 8之后，主要通过数组 + 链表 + 红黑树的方式实现。核心变量为Node 类型的数组 table 变量。由 transient 修饰，并重写了readObject 和 writeObject 方法实现序列化相关操作。</p>\n<h3 id=\"2、HashMap-是如何解决哈希冲突的\"><a href=\"#2、HashMap-是如何解决哈希冲突的\" class=\"headerlink\" title=\"2、HashMap 是如何解决哈希冲突的?\"></a>2、HashMap 是如何解决哈希冲突的?</h3><p>​      由于通过键哈希值的运算来确定元素在table中的位置，当出现不同键的哈希值相同时，会产生哈希冲突，主要通过链地址法来解决。也就是在数组对应的位置形成链表，而对于链表结点的插入采用的是尾插法，防止在多线程模式下出现循环链表的问题。</p>\n<h3 id=\"3、HashMap-的-put-方法的过程\"><a href=\"#3、HashMap-的-put-方法的过程\" class=\"headerlink\" title=\"3、HashMap 的 put 方法的过程\"></a>3、HashMap 的 put 方法的过程</h3><ul>\n<li><p><strong>首先</strong>，是计算hash值，即：通过将键的hash值的低16异或上高16位。</p>\n</li>\n<li><p><strong>其次</strong>，计算该元素在哈希桶中的位置，即：将数组的长度 - 1 &amp; 上二次哈希值作为该元素在数组中的下标。</p>\n</li>\n<li><p><strong>然后</strong>：判断下标位置的元素情况，即：</p>\n<ul>\n<li><p>如果当前位置没有元素，则直接创建node对象并存储hash值，防止二次计算，然后将当前元素储存在当前下标的位置；</p>\n</li>\n<li><p>如果当前位置有元素，就以hash值、key的引用地址，key的equales方法的比较顺序来判断key是否相同；</p>\n<ul>\n<li><p>如果有一个成立，则表示key值相同，即触发替换效果，将原位置的元素的value值替换为当前元素的value 值。</p>\n</li>\n<li><p>如果判断 key 不相同，（省略：就先判断是否为树结构，如果是）继续按照之前的比较顺序遍历整个链表。</p>\n<ul>\n<li><p>当发现键相同时，也是执行替换操作。</p>\n</li>\n<li><p>当遍历到最后一个时，回在最后一个结点的尾部创建一个新的Node结点。（省略：并判断当前位置的链表的长度是否大于8，当大于 8 时，则尝试树形化，在树形化的内部，会判断哈希桶的长度是否大于64，如果不是，则直接扩容，否则进行树形化）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>最后</strong>：都会检查size是否超过扩容阈值，如果超过，则进行扩容。而put方法的返回值是当发成替换时，返回的是旧值，发生插入时，返回的是原位置的值，也就是null。</p>\n</li>\n<li><p>源码展示：</p>\n<pre><code class=\"language-java\">/*添加元素源码*/\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) {\n        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;\n        if ((tab = table) == null || (n = tab.length) == 0) //判断是否需要扩容\n            n = (tab = resize()).length; //执行扩容\n        if ((p = tab[i = (n - 1) &amp; hash]) == null)  //判断要插入的位置是否存在元素\n            tab[i] = newNode(hash, key, value, null); //如果不存在，直在该数组的该位置上添加\n        else { //该位置上存在元素，判断该元素的键是否与要插入的元素的键相同\n            Node&lt;K,V&gt; e; K k;\n            //1、先比较hash值，如果hash不相同，则键一定不相同\n            //2、再比较键\n                //1、先比较键的地址\n                //2、最后在比较键的内容\n            //最后得出，键是否相同\n            if (p.hash == hash \n                &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))\n                e = p; //如果键相同\n            else if (p instanceof TreeNode) //如果键不相同、判断是否为树形结构\n                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);//是树结构\n            else {  //如果键不相同、不为树形结构\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) { //判断下一个元素是否为空\n                        p.next = newNode(hash, key, value, null); //为空，尾插法\n                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // 判断是否需要树形化\n                            treeifyBin(tab, hash); //执行树形化\n                        break;\n                    }\n                    //不为空，判断该位置上的链表的键是否相同，相同直接跳出循环做修改操作\n                    if (e.hash == hash &amp;&amp;\n                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n                        break; \n                    p = e; //给 p 更新，继续比较\n                }\n            }\n            if (e != null) { // 键相同、执行修改操作,如果是新增操作，e必为null\n                V oldValue = e.value; //获取到该位置上的值\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value; //将该位置上的值替换为新的值\n                afterNodeAccess(e);  \n                return oldValue; //返回旧值\n            }\n        }\n        ++modCount;\n        if (++size &gt; threshold) //元素个数记录+1，判断是否需要扩容\n            resize();  //执行扩容\n        afterNodeInsertion(evict);\n        return null;\n    }\n</code></pre>\n</li>\n</ul>\n<h3 id=\"4、HashMap的扩容机制？\"><a href=\"#4、HashMap的扩容机制？\" class=\"headerlink\" title=\"4、HashMap的扩容机制？\"></a>4、HashMap的扩容机制？</h3><ul>\n<li><p>首先，是当哈希桶没有初始化或者哈希桶的长度为 0 时，进行初始化扩容。</p>\n<ul>\n<li>即：设置默认的哈希桶的长度为16，扩容阈值是 12 由 数组长度×负载因子，负载因子默认是0.75。然后创建长度为16的node结点对象并赋值给哈希桶即可。</li>\n</ul>\n</li>\n<li><p>然后，是当哈希桶中的元素个数大于了扩容阈值时会触发扩容机制。</p>\n<ul>\n<li>首先，确定新数组的长度以及扩容阈值：新数组的长度为原来的<strong>2倍</strong>，扩容阈值也变为原来的<strong>2倍</strong></li>\n<li>然后，循环遍历原数组中所有非空元素<ul>\n<li>如果该元素没有形成链表，则直接用元素的hash值 &amp; 上新数组的长度 - 1，作为在新数组中的位置。（这也就是哈希桶的长度为什么是 2 的幂次方，因为计算元素在哈希桶中的位置非常方便）</li>\n<li>如果改元素的 next 指针不为空，则进行结点的迁移。<ul>\n<li>1）对于链表来说<ul>\n<li>首先定义高位链表和低位链表。</li>\n<li>然后，循环遍历链表上的所有结点。对于链表上的结点按照哈希值与原数组的长度做 &amp; 运算的结果是否为 0 ，分为地位链表和高位链表，进而重新分配地位链表和高位链表在数组中的位置来使元素分布均匀。具体的过程以高位链表为例：先判断高位链表的尾结点是否为空，如果为空则为头节点赋初始值，反之则为尾结点的next指针赋值，最后都要将当前遍历的结点赋值给尾结点。最后将低位链表插入到新哈希桶中与原下标相同的位置，而高位链表则插入到新哈希桶中原下标 + 原数组长度的位置。</li>\n</ul>\n</li>\n<li>2）对于红黑树，则是调用树分裂的方法，先将树分为两个链表，对于链表中元素个数小于等于 6 的，直接转换为链表，如果大于6，则进行树形化。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>源码展示：</p>\n<pre><code class=\"language-java\">/*扩容源码*/\nfinal Node&lt;K,V&gt;[] resize() {\n        Node&lt;K,V&gt;[] oldTab = table; //将数组赋值给临时变量\n        int oldCap = (oldTab == null) ? 0 : oldTab.length; //获取数组的长度\n        int oldThr = threshold; //获取扩容的临界点\n        int newCap, newThr = 0; //定义新的长度和扩容的临界点\n        if (oldCap &gt; 0) { //判断数组长度是否大于 0，更新临界点和数组长度\n            if (oldCap &gt;= MAXIMUM_CAPACITY) { //判断是否超出最大容量\n                threshold = Integer.MAX_VALUE;\n                return oldTab; //如果超出了，就不扩容，直接返回\n            }\n            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;\n                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY) //将新的长度为原长度的 2 倍\n                newThr = oldThr &lt;&lt; 1; // 新的临界点为原来临界点的 2 倍\n        }\n        else if (oldThr &gt; 0) // 初始容量置于阈值，用于应对自定义初始值\n            newCap = oldThr;\n        else {               // 零初始阈值表示使用默认值，用于处理默认情况\n            newCap = DEFAULT_INITIAL_CAPACITY; //默认长度为 16\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n            //临界值为默认长度*加载因子\n        }\n        if (newThr == 0) { //用于应对自定义负载因子\n            float ft = (float)newCap * loadFactor;\n            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE);\n        }\n        threshold = newThr; //更新临界值\n        @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})\n        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; //创建新的数组\n        table = newTab; //将原数组指向该新的长度的数组\n        if (oldTab != null) { //用于应对第一次添加的情况\n            //源码赋值hashMap的逻辑\n            for (int j = 0; j &lt; oldCap; ++j) {\n                Node&lt;K,V&gt; e;  //创建新的节点\n                if ((e = oldTab[j]) != null) { //判断旧数组上该位置的节点是否为空\n                    oldTab[j] = null;\n                    if (e.next == null) //如果下一个节点为空，即：该位置上就一个元素\n                        newTab[e.hash &amp; (newCap - 1)] = e; //计算在新数组中的位置并放入\n                    else if (e instanceof TreeNode) //如果下一个有元素，判断是否为树形\n                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);\n                    else { // 是链表\n                        Node&lt;K,V&gt; loHead = null, loTail = null;\n                        Node&lt;K,V&gt; hiHead = null, hiTail = null;\n                        Node&lt;K,V&gt; next;\n                        do {\n                            next = e.next;\n                            if ((e.hash &amp; oldCap) == 0) { \n                                //判断是否需要移动，因为在计算位置时，e.hash &amp; (oldCap-1)\n                                //在增加为容量后，新的容量是2的倍数，因此，之后的位置是原来的二进制\n                                //加 1，原 1111 先 10000 因此，只需要比较最高位的 1 是否影向\n                                //而oldCap是2的倍数，因此只有一个1其余是0,16 = 0000 1000\n                                //因此，如果取与不为0，说名根据hsah值计算的位置与原来的位置不一样\n                                //需要移动，同样，只要是需要移动的，要移动的位置都一样，因为都是同一\n                                //个高位二进制为 1\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            }\n                            else {\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            }\n                        } while ((e = next) != null);\n                        if (loTail != null) {  //将不需要移动的节点直接放入该数组下\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        }\n                        if (hiTail != null) { //将需要移动的链表放入新的数组的空间下\n                            hiTail.next = null;\n                            //由于需要移动，因此高位二进制一定是 1，因此用hash值于新数组计算后\n                            //位置是确定的，增加了oldCap的长度，故，这里不用再次计算为位置，直接用\n                            newTab[j + oldCap] = hiHead;\n                        }\n                    }\n                }\n            }\n        }\n        return newTab;\n    }\n</code></pre>\n</li>\n</ul>\n<h3 id=\"5、为什么负载因子是0-75？\"><a href=\"#5、为什么负载因子是0-75？\" class=\"headerlink\" title=\"5、为什么负载因子是0.75？\"></a>5、为什么负载因子是0.75？</h3><p>​     因为是在时间和空间之间，经过大量计算和实验权衡后的一个最优值。在减少哈希冲突的同时，避免频繁的扩容。</p>\n<h3 id=\"6、HashMap-是线程安全的吗？\"><a href=\"#6、HashMap-是线程安全的吗？\" class=\"headerlink\" title=\"6、HashMap 是线程安全的吗？\"></a>6、HashMap 是线程安全的吗？</h3><p>​      不是，可以用并发工具包的SynchroizedMap包装hashMap，或者直接使用CurrentHashMap。</p>\n<h3 id=\"7、HashMapJDK8-和-JDK-7的区别\"><a href=\"#7、HashMapJDK8-和-JDK-7的区别\" class=\"headerlink\" title=\"7、HashMapJDK8 和 JDK 7的区别\"></a>7、HashMapJDK8 和 JDK 7的区别</h3><p>​      数据结构：从数组 + 链表 &#x3D;&#x3D;》数组 + 链表 + 红黑树</p>\n<p>​      插入方式：头插法 &#x3D;&#x3D;》尾插法</p>\n<p>​      迁移原理：重新计算hash &#x3D;&#x3D;》按照高低位拆分</p>\n<h3 id=\"8、HashMap的内存泄漏？\"><a href=\"#8、HashMap的内存泄漏？\" class=\"headerlink\" title=\"8、HashMap的内存泄漏？\"></a>8、HashMap的内存泄漏？</h3><p>​      若key对象重写了equels()方法，但是没有重写hashCode()方法，可能无法正确定位元素，造成内存占用不能释放。例如：对于放入两个键相同的对象，此时应表现为修改，但是由于没有重写hashCode()方法，导致hash值不同，而判断是先判断hash值，再判断equals()，因此此时表现为插入元素，而当利用键来删除其中的一个元素时，另一个元素则会被留下（因为哈希值不同），造成内存泄漏。</p>\n<h3 id=\"9、key-的值可以为null吗？\"><a href=\"#9、key-的值可以为null吗？\" class=\"headerlink\" title=\"9、key 的值可以为null吗？\"></a>9、key 的值可以为null吗？</h3><p>​      可以，null 键的hash固定为 0，会被放入列表的第一个位置。</p>\n"},{"title":"MySQL索引","description":"文章缩略，支持 `Markdown` **文档格式**\n","pinned":0,"lang":"zh","type":"post","date":"2025-10-28T08:32:34.000Z","_content":"### 1、索引概述：\n\n**索引**是一种有序的数据结构，用于高效的查询数据。（可以举个例子：集合查字典是通过目录查询（索引查询）还是一页一页翻（全表扫描））\n\n**优点：**提高检索效率，降低IO成本。通过索引排序(B+树具有天然的有序性，按索引键值**顺序存储**，当遇到排序时，直接按照链表遍历输出即可，不需要CPU参与排序)，降低CPU的消耗。\n\n**缺点：**索引也会占用存储空间，并且在插入和删除数据时，需要维护索引结构。\n\n### 2、索引数据结构：\n\n#### 0、B+Tree 的结构：\n\n​     ① B+树的结点主要分为两类：\n\n​         1）内部节点：主存储索引键和指向结点的指针，不存储实际数据，每个内部结点包含k个键和k+1个子指针，键用于划分子节点的区间。\n\n​          2）叶子结点：存储完整的键值对，或指向数据的指针，并通过双向链表按**顺序**连接。\n\n​     ② 核心设计：\n\n​          1）数据与索引分离：内部节点存储索引键，子节点存储实际的数据，单个节点可容纳多个值，有效的降低树的高度。\n\n​          2）叶子节点链表化，形成有序的线性结构，显著的提升了范围查询，排序等的效率。\n\n​          3）所有叶子节点位于同一层级，因为所有查询必须到达叶子节点，查询时间稳定为log(n)\n\n#### 1、为什么采用B+树结构：\n\n- **hash表**：使用唯一的key查询value，时间复杂度为 O(1) ，很快，但是没有办法做范围查询，也没办法排序。\n- **二叉排序树**：左节点小于根，右节点大于根，中序遍历就是有序的，可以排序，也可以范围查询，但是在顺序插入时，会退化为链表导致查询性能变的很差。\n- **平衡二叉树**：在插入节点时采用旋转操作，让二叉树保持平衡，左右子树的高度差不大于 1，能避免极端情况下退化为链表，但是由于平衡二叉树追求绝对的平衡，所以在插入，删除数据时，会频繁的左旋右旋保持平衡，在数据库中，频繁的旋转就会带来大量的磁盘IO，降低性能。\n- **红黑树**：也是在插入删除元素时，会通过变色，旋转操作让二叉树保持平衡，但是由于不追求绝对的平衡，只要大致平衡就行了，这样就大大降低了插入，删除时需要的平衡操作，对于数据库来说，就是减少了磁盘的IO，但是红黑二叉树是一种二叉树，一个节点只能由两个子节点，当数据量大的时候，树高就会很高，查询数据时要进行较多的磁盘IO，因此对于少量数据查询效率高，而对于大量数据时，红黑树的查询性能比较低。\n- **B树**，B树多路平衡排序树，一个节点有n个子节点，数据量大的情况下，树高也比较低，但是，B树的节点既存数据，也存索引，因此一个节点能存储的索引比较少，当数据量大的时候，树高就会很高，并且B树做范围查询时，需要回溯树结构，会产生很多的随机IO，查询效率较低。而且B树的查询效率不稳定，对于较低层的结果查询效率快，较高层的结果查询效率慢。\n- **B + 树**，也是多路平衡排序树，而且B+树的非叶子节点只存索引值，不存数据，因此单个节点能存的索引就变多了，树的高度更低，查询性能更好，而且B+树的数据都存在叶子节点，并且数据都有双向链表连接，范围查询时，只需要遍历链表，不用回溯树结构。\n\n### 3、索引分类：\n\n#### 1、在innoDB中储存引擎中可分为两种\n\n**注意：底层结构都是B+Tree，只不过是叶子节点的数据不同**\n\n- 唯一索引（了解）：不可重复\n- 全文索引（了解）：类似于ES的倒排索引\n\n- 聚集索引：将**数据与索引放到一块**存储，索引结构的**叶子节点保存行数据**。必须有，而且**只能有一个**。\n\n    - 聚集索引的选取规则：\n        - 如果存在主键，主键索引就是聚集索引。\n        - 如果不存在主键，将使用第一个唯一索引作为聚集索引。\n        - 如果表中没有主键，或者没有适合的唯一索引，则innoDB会自动生成一个rowid作为隐藏的聚集索引。\n\n- 非聚集索引（二级索引）：将**数据与索引分开存储**，索引结构的**叶子节点关联的时对应的主键**。因此，查询时，会先查到主键索引，再回表查询到具体的数据。\n\n- 查询流程：\n![MySQL索引-01.png](./images/MySQL索引-01.png)\n#### 2、查询二级索引时一定要回表查询吗？\n\n不是。如果只查询id，二级索引树的结点就有id，就不用回表查询了，也就是当一个索引包含所有需要查询的值的时候，就不需要回表查询了，这种**情况**就是**覆盖索引**，而减少回表查询，就是尽可能地做到覆盖索引，如果一个索引列有多个字段，就能增加覆盖索引地概率，这种索引就是**联合索引**，所谓联合索引就是对表中地多个字段创建索引。\n\n### 4、索引语法\n\n```mysql\n-- 创建索引：[唯一索引|全文索引] index 索引名 on 表名 (字段名1,字段2,...)\n-- 索引表的名称一般为：idx_表名_字段名\ncreate [UNIQUE|FULLTEXT] index index_name on table_name (index_col_name,...);\n-- 查看索引\nshow index from table_name\n-- 删除索引\ndrop index index_name on table_name\n```\n\n### 5、SQL性能分析\n\n```mysql\n-- 查看数据库所有语句的执行频次：session表示当前会话的，global表示全局\nshow [session|global] status like 'Com_______';\n-- 慢查日志\n\t-- 查看慢查询日志是否开启\n\tshow variables like 'slow_query_log';\n\t-- 开启MySQL慢日志查询开关\n\tslow_query_log=1\n\t-- 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会被视为慢查询，记录慢查询的日志。\n\tlong_query_time=2\n-- profiling\n\t-- 查看当前数据库是否支持\n\tselect @@have_profiling\n\t-- 是否开启\n\tselect @@profiling\n\t-- 开启\n\tset profiling=1\n\t-- 查看\n\tshow profiles\n-- explain 查看搜索的执行情况\n\texplain select * from user;\n```\n![MySQL索引-02.png](images/MySQL索引-02.png)\n![MySQL索引-03.png](images/MySQL索引-03.png)\n**对type字段的解释：**\n\n- `NULL`：通常是不需要查表，而是直接计算得出\n\n- `system`：表示数据只有一行，是 `const` 的一种特例\n\n- `const`：表示常量级别查询，常见用于 主键、唯一索引的**等值查询**\n\n- `eq_ref`：表示唯一索引扫描，常用于 主键、唯一索引的**等值查询**，通常用于 `join`操作，当条件中的列是唯一索引时才用。\n\n- `ref`：非唯一索引扫描，返回匹配值的所有行\n\n- `range`：范围扫描，表示使用索引的一部分\n\n- `index`：全索引扫描，表示不需要回表查询，直接扫描完后直接返回（**索引储存的字段就是要查询的字段**）\n\n- `all`：全表扫描\n\n\n\n### 6、索引的使用\n\n#### 1、最左前缀法则：\n\n​      如果索引了多列，（联合索引），要遵循最左前缀法则，指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳过了某一列，索引将部分失效（后面的字段索引也失效）\n\n>    基本原理就是：联合索引有多个索引列，因此排序地时候会**根据索引列的顺序**去排序，查找的时候会根据**索引列的顺序从左到右依次匹配**\n>\n>    就是如果一个索引表关联了多个字段，那末，查询时必须包含最左边的字段时，索引才生效，否则，索引不生效。如果关联的是三个字段，如：A B C 那么，在查询时，如果where A=’‘，B= ’‘，C= ’‘ ；索引生效，如果B = ’‘，C=’‘。索引失效，**因为B,C是建立在A的有序的基础上**，不存在A，后面B,C就是乱序的，如果：A=’‘，C=’‘；A索引生效，C索引失效；应为C是建立在B上的，如果 C B A 也走索引，而且全部生效，因为MySQL的优化器会自动把索引列进行重排序。\n\n#### 2、最左前缀法则的应用\n\n- 范围查询：如果使用了> 或 < 的字段，则其后面的索引失效，但是，如果使用的是 >= 或 <= 则不失效。\n\n- 索引运算：如果索引字段进行函数运算，则索引失效\n\n- 字符串不加单引号：字符串不加 ‘ ’ 则索引失效\n\n- 模糊查询：尾部模糊（后面加%）查询走索引，后面模糊（前面加%）不走索引\n- or：or 连接的索引，如果前面有索引，后面没索引，那么索引失效，应为不能同时做索引扫描和全表扫描。解决：给字段建立索引。\n\n- 数据分布：如果Mysql判断，走全表扫描快还是走索引快，那个快用哪个。\n- 覆盖索引：覆盖索引就是只查询二级索引，就能查出来需要的字段，不需要回表查询select 后不要写 * 要写需要的字段\n- 前缀索引：在处理比较长的索引的时候。语法：`create index idx_xxxx on table_name(column(n))`表示我要将字符串的一部分前缀建立索引从而节省索引的空间。通过数据的 字段不重复的记录数 / 总记录数 的值，如果越接近 1 ，就越好。\n\n#### 3、SQL提示\n\n1、`use index(索引名)` ：可以用哪个索引\n\n2、`ignore index(索引名)` ：忽略哪个索引\n\n3、`force index(索引名)` ：必须使用哪个索引\n\n`select * from china_zipcode use index();`\n\n#### 4、为什么不能全部加上索引\n\n索引过多，索引所占用的内存也会增多，并且在增加或删除数据是，需要维护的索引结构就会很多，降低增删改的性能。一般最多不要超过 5 个","source":"_posts/MySQL索引.md","raw":"---\ntitle: MySQL索引\ntags:\n  - MySQL索引\ndescription: |\n  文章缩略，支持 `Markdown` **文档格式**\npinned: 0\nlang: zh\ncategories:\n  - MySQL 篇\ntype: post\ndate: 2025-10-28 16:32:34\n---\n### 1、索引概述：\n\n**索引**是一种有序的数据结构，用于高效的查询数据。（可以举个例子：集合查字典是通过目录查询（索引查询）还是一页一页翻（全表扫描））\n\n**优点：**提高检索效率，降低IO成本。通过索引排序(B+树具有天然的有序性，按索引键值**顺序存储**，当遇到排序时，直接按照链表遍历输出即可，不需要CPU参与排序)，降低CPU的消耗。\n\n**缺点：**索引也会占用存储空间，并且在插入和删除数据时，需要维护索引结构。\n\n### 2、索引数据结构：\n\n#### 0、B+Tree 的结构：\n\n​     ① B+树的结点主要分为两类：\n\n​         1）内部节点：主存储索引键和指向结点的指针，不存储实际数据，每个内部结点包含k个键和k+1个子指针，键用于划分子节点的区间。\n\n​          2）叶子结点：存储完整的键值对，或指向数据的指针，并通过双向链表按**顺序**连接。\n\n​     ② 核心设计：\n\n​          1）数据与索引分离：内部节点存储索引键，子节点存储实际的数据，单个节点可容纳多个值，有效的降低树的高度。\n\n​          2）叶子节点链表化，形成有序的线性结构，显著的提升了范围查询，排序等的效率。\n\n​          3）所有叶子节点位于同一层级，因为所有查询必须到达叶子节点，查询时间稳定为log(n)\n\n#### 1、为什么采用B+树结构：\n\n- **hash表**：使用唯一的key查询value，时间复杂度为 O(1) ，很快，但是没有办法做范围查询，也没办法排序。\n- **二叉排序树**：左节点小于根，右节点大于根，中序遍历就是有序的，可以排序，也可以范围查询，但是在顺序插入时，会退化为链表导致查询性能变的很差。\n- **平衡二叉树**：在插入节点时采用旋转操作，让二叉树保持平衡，左右子树的高度差不大于 1，能避免极端情况下退化为链表，但是由于平衡二叉树追求绝对的平衡，所以在插入，删除数据时，会频繁的左旋右旋保持平衡，在数据库中，频繁的旋转就会带来大量的磁盘IO，降低性能。\n- **红黑树**：也是在插入删除元素时，会通过变色，旋转操作让二叉树保持平衡，但是由于不追求绝对的平衡，只要大致平衡就行了，这样就大大降低了插入，删除时需要的平衡操作，对于数据库来说，就是减少了磁盘的IO，但是红黑二叉树是一种二叉树，一个节点只能由两个子节点，当数据量大的时候，树高就会很高，查询数据时要进行较多的磁盘IO，因此对于少量数据查询效率高，而对于大量数据时，红黑树的查询性能比较低。\n- **B树**，B树多路平衡排序树，一个节点有n个子节点，数据量大的情况下，树高也比较低，但是，B树的节点既存数据，也存索引，因此一个节点能存储的索引比较少，当数据量大的时候，树高就会很高，并且B树做范围查询时，需要回溯树结构，会产生很多的随机IO，查询效率较低。而且B树的查询效率不稳定，对于较低层的结果查询效率快，较高层的结果查询效率慢。\n- **B + 树**，也是多路平衡排序树，而且B+树的非叶子节点只存索引值，不存数据，因此单个节点能存的索引就变多了，树的高度更低，查询性能更好，而且B+树的数据都存在叶子节点，并且数据都有双向链表连接，范围查询时，只需要遍历链表，不用回溯树结构。\n\n### 3、索引分类：\n\n#### 1、在innoDB中储存引擎中可分为两种\n\n**注意：底层结构都是B+Tree，只不过是叶子节点的数据不同**\n\n- 唯一索引（了解）：不可重复\n- 全文索引（了解）：类似于ES的倒排索引\n\n- 聚集索引：将**数据与索引放到一块**存储，索引结构的**叶子节点保存行数据**。必须有，而且**只能有一个**。\n\n    - 聚集索引的选取规则：\n        - 如果存在主键，主键索引就是聚集索引。\n        - 如果不存在主键，将使用第一个唯一索引作为聚集索引。\n        - 如果表中没有主键，或者没有适合的唯一索引，则innoDB会自动生成一个rowid作为隐藏的聚集索引。\n\n- 非聚集索引（二级索引）：将**数据与索引分开存储**，索引结构的**叶子节点关联的时对应的主键**。因此，查询时，会先查到主键索引，再回表查询到具体的数据。\n\n- 查询流程：\n![MySQL索引-01.png](./images/MySQL索引-01.png)\n#### 2、查询二级索引时一定要回表查询吗？\n\n不是。如果只查询id，二级索引树的结点就有id，就不用回表查询了，也就是当一个索引包含所有需要查询的值的时候，就不需要回表查询了，这种**情况**就是**覆盖索引**，而减少回表查询，就是尽可能地做到覆盖索引，如果一个索引列有多个字段，就能增加覆盖索引地概率，这种索引就是**联合索引**，所谓联合索引就是对表中地多个字段创建索引。\n\n### 4、索引语法\n\n```mysql\n-- 创建索引：[唯一索引|全文索引] index 索引名 on 表名 (字段名1,字段2,...)\n-- 索引表的名称一般为：idx_表名_字段名\ncreate [UNIQUE|FULLTEXT] index index_name on table_name (index_col_name,...);\n-- 查看索引\nshow index from table_name\n-- 删除索引\ndrop index index_name on table_name\n```\n\n### 5、SQL性能分析\n\n```mysql\n-- 查看数据库所有语句的执行频次：session表示当前会话的，global表示全局\nshow [session|global] status like 'Com_______';\n-- 慢查日志\n\t-- 查看慢查询日志是否开启\n\tshow variables like 'slow_query_log';\n\t-- 开启MySQL慢日志查询开关\n\tslow_query_log=1\n\t-- 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会被视为慢查询，记录慢查询的日志。\n\tlong_query_time=2\n-- profiling\n\t-- 查看当前数据库是否支持\n\tselect @@have_profiling\n\t-- 是否开启\n\tselect @@profiling\n\t-- 开启\n\tset profiling=1\n\t-- 查看\n\tshow profiles\n-- explain 查看搜索的执行情况\n\texplain select * from user;\n```\n![MySQL索引-02.png](images/MySQL索引-02.png)\n![MySQL索引-03.png](images/MySQL索引-03.png)\n**对type字段的解释：**\n\n- `NULL`：通常是不需要查表，而是直接计算得出\n\n- `system`：表示数据只有一行，是 `const` 的一种特例\n\n- `const`：表示常量级别查询，常见用于 主键、唯一索引的**等值查询**\n\n- `eq_ref`：表示唯一索引扫描，常用于 主键、唯一索引的**等值查询**，通常用于 `join`操作，当条件中的列是唯一索引时才用。\n\n- `ref`：非唯一索引扫描，返回匹配值的所有行\n\n- `range`：范围扫描，表示使用索引的一部分\n\n- `index`：全索引扫描，表示不需要回表查询，直接扫描完后直接返回（**索引储存的字段就是要查询的字段**）\n\n- `all`：全表扫描\n\n\n\n### 6、索引的使用\n\n#### 1、最左前缀法则：\n\n​      如果索引了多列，（联合索引），要遵循最左前缀法则，指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳过了某一列，索引将部分失效（后面的字段索引也失效）\n\n>    基本原理就是：联合索引有多个索引列，因此排序地时候会**根据索引列的顺序**去排序，查找的时候会根据**索引列的顺序从左到右依次匹配**\n>\n>    就是如果一个索引表关联了多个字段，那末，查询时必须包含最左边的字段时，索引才生效，否则，索引不生效。如果关联的是三个字段，如：A B C 那么，在查询时，如果where A=’‘，B= ’‘，C= ’‘ ；索引生效，如果B = ’‘，C=’‘。索引失效，**因为B,C是建立在A的有序的基础上**，不存在A，后面B,C就是乱序的，如果：A=’‘，C=’‘；A索引生效，C索引失效；应为C是建立在B上的，如果 C B A 也走索引，而且全部生效，因为MySQL的优化器会自动把索引列进行重排序。\n\n#### 2、最左前缀法则的应用\n\n- 范围查询：如果使用了> 或 < 的字段，则其后面的索引失效，但是，如果使用的是 >= 或 <= 则不失效。\n\n- 索引运算：如果索引字段进行函数运算，则索引失效\n\n- 字符串不加单引号：字符串不加 ‘ ’ 则索引失效\n\n- 模糊查询：尾部模糊（后面加%）查询走索引，后面模糊（前面加%）不走索引\n- or：or 连接的索引，如果前面有索引，后面没索引，那么索引失效，应为不能同时做索引扫描和全表扫描。解决：给字段建立索引。\n\n- 数据分布：如果Mysql判断，走全表扫描快还是走索引快，那个快用哪个。\n- 覆盖索引：覆盖索引就是只查询二级索引，就能查出来需要的字段，不需要回表查询select 后不要写 * 要写需要的字段\n- 前缀索引：在处理比较长的索引的时候。语法：`create index idx_xxxx on table_name(column(n))`表示我要将字符串的一部分前缀建立索引从而节省索引的空间。通过数据的 字段不重复的记录数 / 总记录数 的值，如果越接近 1 ，就越好。\n\n#### 3、SQL提示\n\n1、`use index(索引名)` ：可以用哪个索引\n\n2、`ignore index(索引名)` ：忽略哪个索引\n\n3、`force index(索引名)` ：必须使用哪个索引\n\n`select * from china_zipcode use index();`\n\n#### 4、为什么不能全部加上索引\n\n索引过多，索引所占用的内存也会增多，并且在增加或删除数据是，需要维护的索引结构就会很多，降低增删改的性能。一般最多不要超过 5 个","slug":"MySQL索引","published":1,"updated":"2025-10-28T08:40:08.800Z","comments":1,"layout":"post","photos":[],"_id":"cuidDTlMFHJZ88JdTAwnFxwUj","content":"<h3 id=\"1、索引概述：\"><a href=\"#1、索引概述：\" class=\"headerlink\" title=\"1、索引概述：\"></a>1、索引概述：</h3><p><strong>索引</strong>是一种有序的数据结构，用于高效的查询数据。（可以举个例子：集合查字典是通过目录查询（索引查询）还是一页一页翻（全表扫描））</p>\n<p><strong>优点：<strong>提高检索效率，降低IO成本。通过索引排序(B+树具有天然的有序性，按索引键值</strong>顺序存储</strong>，当遇到排序时，直接按照链表遍历输出即可，不需要CPU参与排序)，降低CPU的消耗。</p>\n<p>**缺点：**索引也会占用存储空间，并且在插入和删除数据时，需要维护索引结构。</p>\n<h3 id=\"2、索引数据结构：\"><a href=\"#2、索引数据结构：\" class=\"headerlink\" title=\"2、索引数据结构：\"></a>2、索引数据结构：</h3><h4 id=\"0、B-Tree-的结构：\"><a href=\"#0、B-Tree-的结构：\" class=\"headerlink\" title=\"0、B+Tree 的结构：\"></a>0、B+Tree 的结构：</h4><p>​     ① B+树的结点主要分为两类：</p>\n<p>​         1）内部节点：主存储索引键和指向结点的指针，不存储实际数据，每个内部结点包含k个键和k+1个子指针，键用于划分子节点的区间。</p>\n<p>​          2）叶子结点：存储完整的键值对，或指向数据的指针，并通过双向链表按<strong>顺序</strong>连接。</p>\n<p>​     ② 核心设计：</p>\n<p>​          1）数据与索引分离：内部节点存储索引键，子节点存储实际的数据，单个节点可容纳多个值，有效的降低树的高度。</p>\n<p>​          2）叶子节点链表化，形成有序的线性结构，显著的提升了范围查询，排序等的效率。</p>\n<p>​          3）所有叶子节点位于同一层级，因为所有查询必须到达叶子节点，查询时间稳定为log(n)</p>\n<h4 id=\"1、为什么采用B-树结构：\"><a href=\"#1、为什么采用B-树结构：\" class=\"headerlink\" title=\"1、为什么采用B+树结构：\"></a>1、为什么采用B+树结构：</h4><ul>\n<li><strong>hash表</strong>：使用唯一的key查询value，时间复杂度为 O(1) ，很快，但是没有办法做范围查询，也没办法排序。</li>\n<li><strong>二叉排序树</strong>：左节点小于根，右节点大于根，中序遍历就是有序的，可以排序，也可以范围查询，但是在顺序插入时，会退化为链表导致查询性能变的很差。</li>\n<li><strong>平衡二叉树</strong>：在插入节点时采用旋转操作，让二叉树保持平衡，左右子树的高度差不大于 1，能避免极端情况下退化为链表，但是由于平衡二叉树追求绝对的平衡，所以在插入，删除数据时，会频繁的左旋右旋保持平衡，在数据库中，频繁的旋转就会带来大量的磁盘IO，降低性能。</li>\n<li><strong>红黑树</strong>：也是在插入删除元素时，会通过变色，旋转操作让二叉树保持平衡，但是由于不追求绝对的平衡，只要大致平衡就行了，这样就大大降低了插入，删除时需要的平衡操作，对于数据库来说，就是减少了磁盘的IO，但是红黑二叉树是一种二叉树，一个节点只能由两个子节点，当数据量大的时候，树高就会很高，查询数据时要进行较多的磁盘IO，因此对于少量数据查询效率高，而对于大量数据时，红黑树的查询性能比较低。</li>\n<li><strong>B树</strong>，B树多路平衡排序树，一个节点有n个子节点，数据量大的情况下，树高也比较低，但是，B树的节点既存数据，也存索引，因此一个节点能存储的索引比较少，当数据量大的时候，树高就会很高，并且B树做范围查询时，需要回溯树结构，会产生很多的随机IO，查询效率较低。而且B树的查询效率不稳定，对于较低层的结果查询效率快，较高层的结果查询效率慢。</li>\n<li><strong>B + 树</strong>，也是多路平衡排序树，而且B+树的非叶子节点只存索引值，不存数据，因此单个节点能存的索引就变多了，树的高度更低，查询性能更好，而且B+树的数据都存在叶子节点，并且数据都有双向链表连接，范围查询时，只需要遍历链表，不用回溯树结构。</li>\n</ul>\n<h3 id=\"3、索引分类：\"><a href=\"#3、索引分类：\" class=\"headerlink\" title=\"3、索引分类：\"></a>3、索引分类：</h3><h4 id=\"1、在innoDB中储存引擎中可分为两种\"><a href=\"#1、在innoDB中储存引擎中可分为两种\" class=\"headerlink\" title=\"1、在innoDB中储存引擎中可分为两种\"></a>1、在innoDB中储存引擎中可分为两种</h4><p><strong>注意：底层结构都是B+Tree，只不过是叶子节点的数据不同</strong></p>\n<ul>\n<li><p>唯一索引（了解）：不可重复</p>\n</li>\n<li><p>全文索引（了解）：类似于ES的倒排索引</p>\n</li>\n<li><p>聚集索引：将<strong>数据与索引放到一块</strong>存储，索引结构的<strong>叶子节点保存行数据</strong>。必须有，而且<strong>只能有一个</strong>。</p>\n<ul>\n<li>聚集索引的选取规则：<ul>\n<li>如果存在主键，主键索引就是聚集索引。</li>\n<li>如果不存在主键，将使用第一个唯一索引作为聚集索引。</li>\n<li>如果表中没有主键，或者没有适合的唯一索引，则innoDB会自动生成一个rowid作为隐藏的聚集索引。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>非聚集索引（二级索引）：将<strong>数据与索引分开存储</strong>，索引结构的<strong>叶子节点关联的时对应的主键</strong>。因此，查询时，会先查到主键索引，再回表查询到具体的数据。</p>\n</li>\n<li><p>查询流程：<br><img src=\"/./images/MySQL%E7%B4%A2%E5%BC%95-01.png\" alt=\"MySQL索引-01.png\"></p>\n</li>\n</ul>\n<h4 id=\"2、查询二级索引时一定要回表查询吗？\"><a href=\"#2、查询二级索引时一定要回表查询吗？\" class=\"headerlink\" title=\"2、查询二级索引时一定要回表查询吗？\"></a>2、查询二级索引时一定要回表查询吗？</h4><p>不是。如果只查询id，二级索引树的结点就有id，就不用回表查询了，也就是当一个索引包含所有需要查询的值的时候，就不需要回表查询了，这种<strong>情况</strong>就是<strong>覆盖索引</strong>，而减少回表查询，就是尽可能地做到覆盖索引，如果一个索引列有多个字段，就能增加覆盖索引地概率，这种索引就是<strong>联合索引</strong>，所谓联合索引就是对表中地多个字段创建索引。</p>\n<h3 id=\"4、索引语法\"><a href=\"#4、索引语法\" class=\"headerlink\" title=\"4、索引语法\"></a>4、索引语法</h3><pre><code class=\"language-mysql\">-- 创建索引：[唯一索引|全文索引] index 索引名 on 表名 (字段名1,字段2,...)\n-- 索引表的名称一般为：idx_表名_字段名\ncreate [UNIQUE|FULLTEXT] index index_name on table_name (index_col_name,...);\n-- 查看索引\nshow index from table_name\n-- 删除索引\ndrop index index_name on table_name\n</code></pre>\n<h3 id=\"5、SQL性能分析\"><a href=\"#5、SQL性能分析\" class=\"headerlink\" title=\"5、SQL性能分析\"></a>5、SQL性能分析</h3><pre><code class=\"language-mysql\">-- 查看数据库所有语句的执行频次：session表示当前会话的，global表示全局\nshow [session|global] status like &#39;Com_______&#39;;\n-- 慢查日志\n\t-- 查看慢查询日志是否开启\n\tshow variables like &#39;slow_query_log&#39;;\n\t-- 开启MySQL慢日志查询开关\n\tslow_query_log=1\n\t-- 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会被视为慢查询，记录慢查询的日志。\n\tlong_query_time=2\n-- profiling\n\t-- 查看当前数据库是否支持\n\tselect @@have_profiling\n\t-- 是否开启\n\tselect @@profiling\n\t-- 开启\n\tset profiling=1\n\t-- 查看\n\tshow profiles\n-- explain 查看搜索的执行情况\n\texplain select * from user;\n</code></pre>\n<p><img src=\"/images/MySQL%E7%B4%A2%E5%BC%95-02.png\" alt=\"MySQL索引-02.png\"><br><img src=\"/images/MySQL%E7%B4%A2%E5%BC%95-03.png\" alt=\"MySQL索引-03.png\"><br><strong>对type字段的解释：</strong></p>\n<ul>\n<li><p><code>NULL</code>：通常是不需要查表，而是直接计算得出</p>\n</li>\n<li><p><code>system</code>：表示数据只有一行，是 <code>const</code> 的一种特例</p>\n</li>\n<li><p><code>const</code>：表示常量级别查询，常见用于 主键、唯一索引的<strong>等值查询</strong></p>\n</li>\n<li><p><code>eq_ref</code>：表示唯一索引扫描，常用于 主键、唯一索引的<strong>等值查询</strong>，通常用于 <code>join</code>操作，当条件中的列是唯一索引时才用。</p>\n</li>\n<li><p><code>ref</code>：非唯一索引扫描，返回匹配值的所有行</p>\n</li>\n<li><p><code>range</code>：范围扫描，表示使用索引的一部分</p>\n</li>\n<li><p><code>index</code>：全索引扫描，表示不需要回表查询，直接扫描完后直接返回（<strong>索引储存的字段就是要查询的字段</strong>）</p>\n</li>\n<li><p><code>all</code>：全表扫描</p>\n</li>\n</ul>\n<h3 id=\"6、索引的使用\"><a href=\"#6、索引的使用\" class=\"headerlink\" title=\"6、索引的使用\"></a>6、索引的使用</h3><h4 id=\"1、最左前缀法则：\"><a href=\"#1、最左前缀法则：\" class=\"headerlink\" title=\"1、最左前缀法则：\"></a>1、最左前缀法则：</h4><p>​      如果索引了多列，（联合索引），要遵循最左前缀法则，指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳过了某一列，索引将部分失效（后面的字段索引也失效）</p>\n<blockquote>\n<p>   基本原理就是：联合索引有多个索引列，因此排序地时候会<strong>根据索引列的顺序</strong>去排序，查找的时候会根据<strong>索引列的顺序从左到右依次匹配</strong></p>\n<p>   就是如果一个索引表关联了多个字段，那末，查询时必须包含最左边的字段时，索引才生效，否则，索引不生效。如果关联的是三个字段，如：A B C 那么，在查询时，如果where A&#x3D;’‘，B&#x3D; ’‘，C&#x3D; ’‘ ；索引生效，如果B &#x3D; ’‘，C&#x3D;’‘。索引失效，<strong>因为B,C是建立在A的有序的基础上</strong>，不存在A，后面B,C就是乱序的，如果：A&#x3D;’‘，C&#x3D;’‘；A索引生效，C索引失效；应为C是建立在B上的，如果 C B A 也走索引，而且全部生效，因为MySQL的优化器会自动把索引列进行重排序。</p>\n</blockquote>\n<h4 id=\"2、最左前缀法则的应用\"><a href=\"#2、最左前缀法则的应用\" class=\"headerlink\" title=\"2、最左前缀法则的应用\"></a>2、最左前缀法则的应用</h4><ul>\n<li><p>范围查询：如果使用了&gt; 或 &lt; 的字段，则其后面的索引失效，但是，如果使用的是 &gt;&#x3D; 或 &lt;&#x3D; 则不失效。</p>\n</li>\n<li><p>索引运算：如果索引字段进行函数运算，则索引失效</p>\n</li>\n<li><p>字符串不加单引号：字符串不加 ‘ ’ 则索引失效</p>\n</li>\n<li><p>模糊查询：尾部模糊（后面加%）查询走索引，后面模糊（前面加%）不走索引</p>\n</li>\n<li><p>or：or 连接的索引，如果前面有索引，后面没索引，那么索引失效，应为不能同时做索引扫描和全表扫描。解决：给字段建立索引。</p>\n</li>\n<li><p>数据分布：如果Mysql判断，走全表扫描快还是走索引快，那个快用哪个。</p>\n</li>\n<li><p>覆盖索引：覆盖索引就是只查询二级索引，就能查出来需要的字段，不需要回表查询select 后不要写 * 要写需要的字段</p>\n</li>\n<li><p>前缀索引：在处理比较长的索引的时候。语法：<code>create index idx_xxxx on table_name(column(n))</code>表示我要将字符串的一部分前缀建立索引从而节省索引的空间。通过数据的 字段不重复的记录数 &#x2F; 总记录数 的值，如果越接近 1 ，就越好。</p>\n</li>\n</ul>\n<h4 id=\"3、SQL提示\"><a href=\"#3、SQL提示\" class=\"headerlink\" title=\"3、SQL提示\"></a>3、SQL提示</h4><p>1、<code>use index(索引名)</code> ：可以用哪个索引</p>\n<p>2、<code>ignore index(索引名)</code> ：忽略哪个索引</p>\n<p>3、<code>force index(索引名)</code> ：必须使用哪个索引</p>\n<p><code>select * from china_zipcode use index();</code></p>\n<h4 id=\"4、为什么不能全部加上索引\"><a href=\"#4、为什么不能全部加上索引\" class=\"headerlink\" title=\"4、为什么不能全部加上索引\"></a>4、为什么不能全部加上索引</h4><p>索引过多，索引所占用的内存也会增多，并且在增加或删除数据是，需要维护的索引结构就会很多，降低增删改的性能。一般最多不要超过 5 个</p>\n","abbrlink":"43a71ae4","wordCount":129,"charCount":3554,"imgCount":3,"vidCount":0,"wsCount":0,"cbCount":2,"readTime":"约2分钟","excerpt":"","more":"<h3 id=\"1、索引概述：\"><a href=\"#1、索引概述：\" class=\"headerlink\" title=\"1、索引概述：\"></a>1、索引概述：</h3><p><strong>索引</strong>是一种有序的数据结构，用于高效的查询数据。（可以举个例子：集合查字典是通过目录查询（索引查询）还是一页一页翻（全表扫描））</p>\n<p><strong>优点：<strong>提高检索效率，降低IO成本。通过索引排序(B+树具有天然的有序性，按索引键值</strong>顺序存储</strong>，当遇到排序时，直接按照链表遍历输出即可，不需要CPU参与排序)，降低CPU的消耗。</p>\n<p>**缺点：**索引也会占用存储空间，并且在插入和删除数据时，需要维护索引结构。</p>\n<h3 id=\"2、索引数据结构：\"><a href=\"#2、索引数据结构：\" class=\"headerlink\" title=\"2、索引数据结构：\"></a>2、索引数据结构：</h3><h4 id=\"0、B-Tree-的结构：\"><a href=\"#0、B-Tree-的结构：\" class=\"headerlink\" title=\"0、B+Tree 的结构：\"></a>0、B+Tree 的结构：</h4><p>​     ① B+树的结点主要分为两类：</p>\n<p>​         1）内部节点：主存储索引键和指向结点的指针，不存储实际数据，每个内部结点包含k个键和k+1个子指针，键用于划分子节点的区间。</p>\n<p>​          2）叶子结点：存储完整的键值对，或指向数据的指针，并通过双向链表按<strong>顺序</strong>连接。</p>\n<p>​     ② 核心设计：</p>\n<p>​          1）数据与索引分离：内部节点存储索引键，子节点存储实际的数据，单个节点可容纳多个值，有效的降低树的高度。</p>\n<p>​          2）叶子节点链表化，形成有序的线性结构，显著的提升了范围查询，排序等的效率。</p>\n<p>​          3）所有叶子节点位于同一层级，因为所有查询必须到达叶子节点，查询时间稳定为log(n)</p>\n<h4 id=\"1、为什么采用B-树结构：\"><a href=\"#1、为什么采用B-树结构：\" class=\"headerlink\" title=\"1、为什么采用B+树结构：\"></a>1、为什么采用B+树结构：</h4><ul>\n<li><strong>hash表</strong>：使用唯一的key查询value，时间复杂度为 O(1) ，很快，但是没有办法做范围查询，也没办法排序。</li>\n<li><strong>二叉排序树</strong>：左节点小于根，右节点大于根，中序遍历就是有序的，可以排序，也可以范围查询，但是在顺序插入时，会退化为链表导致查询性能变的很差。</li>\n<li><strong>平衡二叉树</strong>：在插入节点时采用旋转操作，让二叉树保持平衡，左右子树的高度差不大于 1，能避免极端情况下退化为链表，但是由于平衡二叉树追求绝对的平衡，所以在插入，删除数据时，会频繁的左旋右旋保持平衡，在数据库中，频繁的旋转就会带来大量的磁盘IO，降低性能。</li>\n<li><strong>红黑树</strong>：也是在插入删除元素时，会通过变色，旋转操作让二叉树保持平衡，但是由于不追求绝对的平衡，只要大致平衡就行了，这样就大大降低了插入，删除时需要的平衡操作，对于数据库来说，就是减少了磁盘的IO，但是红黑二叉树是一种二叉树，一个节点只能由两个子节点，当数据量大的时候，树高就会很高，查询数据时要进行较多的磁盘IO，因此对于少量数据查询效率高，而对于大量数据时，红黑树的查询性能比较低。</li>\n<li><strong>B树</strong>，B树多路平衡排序树，一个节点有n个子节点，数据量大的情况下，树高也比较低，但是，B树的节点既存数据，也存索引，因此一个节点能存储的索引比较少，当数据量大的时候，树高就会很高，并且B树做范围查询时，需要回溯树结构，会产生很多的随机IO，查询效率较低。而且B树的查询效率不稳定，对于较低层的结果查询效率快，较高层的结果查询效率慢。</li>\n<li><strong>B + 树</strong>，也是多路平衡排序树，而且B+树的非叶子节点只存索引值，不存数据，因此单个节点能存的索引就变多了，树的高度更低，查询性能更好，而且B+树的数据都存在叶子节点，并且数据都有双向链表连接，范围查询时，只需要遍历链表，不用回溯树结构。</li>\n</ul>\n<h3 id=\"3、索引分类：\"><a href=\"#3、索引分类：\" class=\"headerlink\" title=\"3、索引分类：\"></a>3、索引分类：</h3><h4 id=\"1、在innoDB中储存引擎中可分为两种\"><a href=\"#1、在innoDB中储存引擎中可分为两种\" class=\"headerlink\" title=\"1、在innoDB中储存引擎中可分为两种\"></a>1、在innoDB中储存引擎中可分为两种</h4><p><strong>注意：底层结构都是B+Tree，只不过是叶子节点的数据不同</strong></p>\n<ul>\n<li><p>唯一索引（了解）：不可重复</p>\n</li>\n<li><p>全文索引（了解）：类似于ES的倒排索引</p>\n</li>\n<li><p>聚集索引：将<strong>数据与索引放到一块</strong>存储，索引结构的<strong>叶子节点保存行数据</strong>。必须有，而且<strong>只能有一个</strong>。</p>\n<ul>\n<li>聚集索引的选取规则：<ul>\n<li>如果存在主键，主键索引就是聚集索引。</li>\n<li>如果不存在主键，将使用第一个唯一索引作为聚集索引。</li>\n<li>如果表中没有主键，或者没有适合的唯一索引，则innoDB会自动生成一个rowid作为隐藏的聚集索引。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>非聚集索引（二级索引）：将<strong>数据与索引分开存储</strong>，索引结构的<strong>叶子节点关联的时对应的主键</strong>。因此，查询时，会先查到主键索引，再回表查询到具体的数据。</p>\n</li>\n<li><p>查询流程：<br><img src=\"/./images/MySQL%E7%B4%A2%E5%BC%95-01.png\" alt=\"MySQL索引-01.png\"></p>\n</li>\n</ul>\n<h4 id=\"2、查询二级索引时一定要回表查询吗？\"><a href=\"#2、查询二级索引时一定要回表查询吗？\" class=\"headerlink\" title=\"2、查询二级索引时一定要回表查询吗？\"></a>2、查询二级索引时一定要回表查询吗？</h4><p>不是。如果只查询id，二级索引树的结点就有id，就不用回表查询了，也就是当一个索引包含所有需要查询的值的时候，就不需要回表查询了，这种<strong>情况</strong>就是<strong>覆盖索引</strong>，而减少回表查询，就是尽可能地做到覆盖索引，如果一个索引列有多个字段，就能增加覆盖索引地概率，这种索引就是<strong>联合索引</strong>，所谓联合索引就是对表中地多个字段创建索引。</p>\n<h3 id=\"4、索引语法\"><a href=\"#4、索引语法\" class=\"headerlink\" title=\"4、索引语法\"></a>4、索引语法</h3><pre><code class=\"language-mysql\">-- 创建索引：[唯一索引|全文索引] index 索引名 on 表名 (字段名1,字段2,...)\n-- 索引表的名称一般为：idx_表名_字段名\ncreate [UNIQUE|FULLTEXT] index index_name on table_name (index_col_name,...);\n-- 查看索引\nshow index from table_name\n-- 删除索引\ndrop index index_name on table_name\n</code></pre>\n<h3 id=\"5、SQL性能分析\"><a href=\"#5、SQL性能分析\" class=\"headerlink\" title=\"5、SQL性能分析\"></a>5、SQL性能分析</h3><pre><code class=\"language-mysql\">-- 查看数据库所有语句的执行频次：session表示当前会话的，global表示全局\nshow [session|global] status like &#39;Com_______&#39;;\n-- 慢查日志\n\t-- 查看慢查询日志是否开启\n\tshow variables like &#39;slow_query_log&#39;;\n\t-- 开启MySQL慢日志查询开关\n\tslow_query_log=1\n\t-- 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会被视为慢查询，记录慢查询的日志。\n\tlong_query_time=2\n-- profiling\n\t-- 查看当前数据库是否支持\n\tselect @@have_profiling\n\t-- 是否开启\n\tselect @@profiling\n\t-- 开启\n\tset profiling=1\n\t-- 查看\n\tshow profiles\n-- explain 查看搜索的执行情况\n\texplain select * from user;\n</code></pre>\n<p><img src=\"/images/MySQL%E7%B4%A2%E5%BC%95-02.png\" alt=\"MySQL索引-02.png\"><br><img src=\"/images/MySQL%E7%B4%A2%E5%BC%95-03.png\" alt=\"MySQL索引-03.png\"><br><strong>对type字段的解释：</strong></p>\n<ul>\n<li><p><code>NULL</code>：通常是不需要查表，而是直接计算得出</p>\n</li>\n<li><p><code>system</code>：表示数据只有一行，是 <code>const</code> 的一种特例</p>\n</li>\n<li><p><code>const</code>：表示常量级别查询，常见用于 主键、唯一索引的<strong>等值查询</strong></p>\n</li>\n<li><p><code>eq_ref</code>：表示唯一索引扫描，常用于 主键、唯一索引的<strong>等值查询</strong>，通常用于 <code>join</code>操作，当条件中的列是唯一索引时才用。</p>\n</li>\n<li><p><code>ref</code>：非唯一索引扫描，返回匹配值的所有行</p>\n</li>\n<li><p><code>range</code>：范围扫描，表示使用索引的一部分</p>\n</li>\n<li><p><code>index</code>：全索引扫描，表示不需要回表查询，直接扫描完后直接返回（<strong>索引储存的字段就是要查询的字段</strong>）</p>\n</li>\n<li><p><code>all</code>：全表扫描</p>\n</li>\n</ul>\n<h3 id=\"6、索引的使用\"><a href=\"#6、索引的使用\" class=\"headerlink\" title=\"6、索引的使用\"></a>6、索引的使用</h3><h4 id=\"1、最左前缀法则：\"><a href=\"#1、最左前缀法则：\" class=\"headerlink\" title=\"1、最左前缀法则：\"></a>1、最左前缀法则：</h4><p>​      如果索引了多列，（联合索引），要遵循最左前缀法则，指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳过了某一列，索引将部分失效（后面的字段索引也失效）</p>\n<blockquote>\n<p>   基本原理就是：联合索引有多个索引列，因此排序地时候会<strong>根据索引列的顺序</strong>去排序，查找的时候会根据<strong>索引列的顺序从左到右依次匹配</strong></p>\n<p>   就是如果一个索引表关联了多个字段，那末，查询时必须包含最左边的字段时，索引才生效，否则，索引不生效。如果关联的是三个字段，如：A B C 那么，在查询时，如果where A&#x3D;’‘，B&#x3D; ’‘，C&#x3D; ’‘ ；索引生效，如果B &#x3D; ’‘，C&#x3D;’‘。索引失效，<strong>因为B,C是建立在A的有序的基础上</strong>，不存在A，后面B,C就是乱序的，如果：A&#x3D;’‘，C&#x3D;’‘；A索引生效，C索引失效；应为C是建立在B上的，如果 C B A 也走索引，而且全部生效，因为MySQL的优化器会自动把索引列进行重排序。</p>\n</blockquote>\n<h4 id=\"2、最左前缀法则的应用\"><a href=\"#2、最左前缀法则的应用\" class=\"headerlink\" title=\"2、最左前缀法则的应用\"></a>2、最左前缀法则的应用</h4><ul>\n<li><p>范围查询：如果使用了&gt; 或 &lt; 的字段，则其后面的索引失效，但是，如果使用的是 &gt;&#x3D; 或 &lt;&#x3D; 则不失效。</p>\n</li>\n<li><p>索引运算：如果索引字段进行函数运算，则索引失效</p>\n</li>\n<li><p>字符串不加单引号：字符串不加 ‘ ’ 则索引失效</p>\n</li>\n<li><p>模糊查询：尾部模糊（后面加%）查询走索引，后面模糊（前面加%）不走索引</p>\n</li>\n<li><p>or：or 连接的索引，如果前面有索引，后面没索引，那么索引失效，应为不能同时做索引扫描和全表扫描。解决：给字段建立索引。</p>\n</li>\n<li><p>数据分布：如果Mysql判断，走全表扫描快还是走索引快，那个快用哪个。</p>\n</li>\n<li><p>覆盖索引：覆盖索引就是只查询二级索引，就能查出来需要的字段，不需要回表查询select 后不要写 * 要写需要的字段</p>\n</li>\n<li><p>前缀索引：在处理比较长的索引的时候。语法：<code>create index idx_xxxx on table_name(column(n))</code>表示我要将字符串的一部分前缀建立索引从而节省索引的空间。通过数据的 字段不重复的记录数 &#x2F; 总记录数 的值，如果越接近 1 ，就越好。</p>\n</li>\n</ul>\n<h4 id=\"3、SQL提示\"><a href=\"#3、SQL提示\" class=\"headerlink\" title=\"3、SQL提示\"></a>3、SQL提示</h4><p>1、<code>use index(索引名)</code> ：可以用哪个索引</p>\n<p>2、<code>ignore index(索引名)</code> ：忽略哪个索引</p>\n<p>3、<code>force index(索引名)</code> ：必须使用哪个索引</p>\n<p><code>select * from china_zipcode use index();</code></p>\n<h4 id=\"4、为什么不能全部加上索引\"><a href=\"#4、为什么不能全部加上索引\" class=\"headerlink\" title=\"4、为什么不能全部加上索引\"></a>4、为什么不能全部加上索引</h4><p>索引过多，索引所占用的内存也会增多，并且在增加或删除数据是，需要维护的索引结构就会很多，降低增删改的性能。一般最多不要超过 5 个</p>\n"},{"title":"MySQL锁","description":"文章缩略，支持 `Markdown` **文档格式**\n","pinned":0,"lang":"zh","type":"post","date":"2025-10-28T08:40:31.000Z","_content":"### 1、锁的分类\n\n- 全局锁：锁住整个数据库，也就是锁住数据库中所有的表。\n- 表级锁：锁住整张表。\n- 行级锁：锁住单独的一行数据。\n\n\n\n### 2、全局锁\n\n#### 2.1 全局锁的分类和作用\n\n​\t\tMySQL全局锁是针对整个数据库的锁。最常用的全局锁是读锁和写锁。\n\n- 读锁（共享锁）：它阻止其他用户更新数据，但允许他们读取数据。\n- 写锁（排他锁）：它阻止其他用户读取和更新数据。\n\n#### 2.2 全局锁的用法\n\n- `FLUSH TABLES WITH READ/WRITE LOCK(FTWRL)`：用来锁住整个数据库\n- `UNLOCK TABLES` ：进行解锁\n\n#### 2.3 全局锁的使用场景\n\n- **备份全库**：使用全局锁可以确保在备份过程中，数据库的所有表都保持一致的状态。\n- **整体数据迁移**：将整个数据库从一个服务器迁移到另一个服务器，需要阻止任何写操作，以确保所有的数据都被正确地迁移到新的服务器。\n- **全库只读**：在某些情况下，可能希望将整个数据库设置为只读模式。\n\n\n\n### 3、表级锁\n\n#### 3.1 表级锁的分类\n\n- 表锁\n\n- 元数据锁\n\n- 意向锁\n\n  > ​\t\t这里可能会疑惑为什么有表锁、意向锁、元数据锁会**处于同一层级**，不应该是表锁包含元数据锁和意向锁吗，这里其实陷入了一个误区，其实，表锁、意向锁、元数据锁 都属于 表**级**锁，而表**级**锁当然包括了表锁，同时，元数据锁和意向锁也都属于表**级**锁，同样，行锁和行**级**锁也是同样的道理，后面就不赘述了。\n\n#### 3.2 表锁\n\n##### 3.2.1 表锁的概念和分类\n\n​\t\t表锁是**最基础的表级锁**，直接对整个表进行锁定，分为**读锁和写锁**，二者遵循 “读共享、写独占” 原则。\n\n- **读锁（Shared Lock，简称 S 锁）**：事务加读锁后，自身和其他事务只能读表，不能修改表数据。多个事务可同时对同一表加读锁，互不阻塞。\n- **写锁（Exclusive Lock，简称 X 锁）**：事务加写锁后，只有自身能读写表数据，其他事务无法加读锁或写锁，也不能查询或者修改数据，会被阻塞直到当前事务的写锁释放。\n\n##### 3.2.2 表锁的用法\n\n- 加锁：`lock tables 表名... read/write`\n- 解锁：`unlock tables 或者 客户端连接断开`\n\n##### 3.2.3 与MyISAM 存储引擎的关联\n\n​\t\t由于MyISAM 引擎不支持行锁，所有操作都依赖表锁，且默认会在`select`时隐式加读锁、`insert/update/delete`时隐式加写锁并自动释放。\n\n#### 3.3 元数据锁\n\n##### 3.3.1 元数据锁的概念和分类\n\n​\t\t**元数据锁（Metadata Lock，简称 MDL）`MDL` 不锁定数据本身，而是**保护表的元数据（如表结构、字段类型、索引信息等），避免 “表结构修改” 与 “数据读写” 同时进行导致的不一致。\n\n- **共享 MDL 锁（Shared MDL）**：事务执行查询（如`SELECT`）时自动加共享 `MDL` 锁，多个事务可同时加，互不影响。\n- **排他 MDL 锁（Exclusive MDL）**：事务执行表结构修改（如`ALTER TABLE`、`DROP COLUMN`）时自动加排他 MDL锁，加锁期间会阻塞所有其他事务的共享 `MDL` 锁请求。\n\n#### 3.4 意向锁\n\n##### 3.4.1 意向锁的概念和分类\n\n​\t\t意向锁是 “中间层锁”，作用是**快速判断表内是否存在行级锁**，避免表锁与行锁的冲突检查需要遍历所有行，提升效率。它仅标识 “意向”，不直接阻止数据读写。\n\n- **意向共享锁（Intention Shared Lock，简称 IS 锁）**：事务计划对表中某些行加读锁（行级 `S` 锁）前，会先对表加 `IS` 锁。\n- **意向排他锁（Intention Exclusive Lock，简称 IX 锁）**：事务计划对表中某些行加写锁（行级 `X` 锁）前，会先对表加 `IX` 锁。\n\n##### 3.4.2 意向锁的执行过程\n\n​\t\t**原来**：当执行根据 `id` 更新数据库表中的某一行数据时，会在这一行加上行锁，但是当另一个客户端需要加表锁的时候，会逐行检查是否有行锁的存在。效率极低。\n\n​\t\t**现在**(有了意向锁后)：当加行锁的时候，**同时会给这张表加上意向锁**，当另一个客户端需要加表锁的时候，就会先去检查这个意向锁**是否与自己要获取的锁兼容**，如果兼容，获取锁成功，如果不兼容，获取锁失败。\n\n\n\n### 4、行级锁\n\n#### 4.1 行级锁的分类\n\n- 行锁\n- 间隙锁\n- 临键锁\n\n#### 4.2 行锁\n\n##### 4.2.1 行锁的概念和分类\n\n​\t\t行锁是最基础的行级锁，**直接锁定表中某一行记录**，仅对锁定的行生效，不影响其他行。\n\n- 共享锁（`S` 锁）：事务对某行加 `S` 锁后，自身可读该行，其他事务可加 `S` 锁（共享读），但不能加 `X` 锁（阻塞写）。\n- 排他锁（`X` 锁）：事务对某行加 `X` 锁后，自身可读写该行，其他事务既不能加 `S` 锁也不能加 `X` 锁（读写都阻塞）。\n\n##### 4.2.2 行锁的特点\n\n​\t\t仅锁定具体行，粒度最细，并发影响最小，但加锁 / 释放锁开销略高于表锁。行锁必须**基于索引生效**，若查询未使用索引（进行的是全表扫描），InnoDB 会退化为表锁（意向锁 + 表锁）。\n\n#### 4.3 间隙锁\n\n##### 4.3.1 间隙锁的概念\n\n​\t\t间隙锁是**锁定索引记录之间的 “间隙”**，不锁定具体行，仅防止其他事务在间隙中插入新记录，解决 “幻读” 问题（RR 隔离级别下生效）。\n\n##### 4.3.2 什么是间隙\n\n​\t\t指索引值之间的空白区间。例如，表中某索引列存在值`10、20、30`，则间隙包括：`(-∞, 10)`、`(10, 20)`、`(20, 30)`、`(30, +∞)`。\n\n##### 4.3.3 间隙锁的作用\n\n​\t\t阻止在间隙中插入新行。例如，事务 A 对`(10, 20)`加间隙锁后，其他事务无法插入`15`（属于该间隙），但可以修改已存在的`10、20`（如果没被行锁锁定）。\n\n##### 4.3.4 间隙锁的触发场景\n\n​\t\t在 RR 隔离级别下，使用非唯一索引或范围查询（如`WHERE id > 10 AND id < 20`）时，InnoDB 会对匹配不到行的范围加间隙锁。\n\n> 注意：间隙锁之间不冲突（多个事务可同时对同一间隙加间隙锁）。\n\n#### 4.4 临键锁\n\n##### 4.4.1 临键锁的概念\n\n​\t\t临键锁是**行锁与间隙锁的组合**，是 InnoDB 在 RR 隔离级别下默认的行级锁类型，既锁定具体行，也锁定该行前面的间隙。\n\n##### 4.4.2 临键锁的作用\n\n​\t\t临键锁主要用来防止两种冲突\n\n- 其他事务修改锁定的行（行锁的作用）。\n- 其他事务在锁定的间隙中插入新行（间隙锁的作用）。\n\n##### 4.4.3 临键锁的触发场景\n\n​\t\t在 RR 隔离级别下，使用**非唯一索引进行等值查询或范围查询**时，若命中行，InnoDB 会对该行加行锁，同时对该行左侧的间隙加间隙锁，**组合为临键锁**。","source":"_posts/MySQL锁.md","raw":"---\ntitle: MySQL锁\ntags:\n  - MySQL锁\ndescription: |\n  文章缩略，支持 `Markdown` **文档格式**\npinned: 0\nlang: zh\ncategories:\n  - MySQL 篇\ntype: post\ndate: 2025-10-28 16:40:31\n---\n### 1、锁的分类\n\n- 全局锁：锁住整个数据库，也就是锁住数据库中所有的表。\n- 表级锁：锁住整张表。\n- 行级锁：锁住单独的一行数据。\n\n\n\n### 2、全局锁\n\n#### 2.1 全局锁的分类和作用\n\n​\t\tMySQL全局锁是针对整个数据库的锁。最常用的全局锁是读锁和写锁。\n\n- 读锁（共享锁）：它阻止其他用户更新数据，但允许他们读取数据。\n- 写锁（排他锁）：它阻止其他用户读取和更新数据。\n\n#### 2.2 全局锁的用法\n\n- `FLUSH TABLES WITH READ/WRITE LOCK(FTWRL)`：用来锁住整个数据库\n- `UNLOCK TABLES` ：进行解锁\n\n#### 2.3 全局锁的使用场景\n\n- **备份全库**：使用全局锁可以确保在备份过程中，数据库的所有表都保持一致的状态。\n- **整体数据迁移**：将整个数据库从一个服务器迁移到另一个服务器，需要阻止任何写操作，以确保所有的数据都被正确地迁移到新的服务器。\n- **全库只读**：在某些情况下，可能希望将整个数据库设置为只读模式。\n\n\n\n### 3、表级锁\n\n#### 3.1 表级锁的分类\n\n- 表锁\n\n- 元数据锁\n\n- 意向锁\n\n  > ​\t\t这里可能会疑惑为什么有表锁、意向锁、元数据锁会**处于同一层级**，不应该是表锁包含元数据锁和意向锁吗，这里其实陷入了一个误区，其实，表锁、意向锁、元数据锁 都属于 表**级**锁，而表**级**锁当然包括了表锁，同时，元数据锁和意向锁也都属于表**级**锁，同样，行锁和行**级**锁也是同样的道理，后面就不赘述了。\n\n#### 3.2 表锁\n\n##### 3.2.1 表锁的概念和分类\n\n​\t\t表锁是**最基础的表级锁**，直接对整个表进行锁定，分为**读锁和写锁**，二者遵循 “读共享、写独占” 原则。\n\n- **读锁（Shared Lock，简称 S 锁）**：事务加读锁后，自身和其他事务只能读表，不能修改表数据。多个事务可同时对同一表加读锁，互不阻塞。\n- **写锁（Exclusive Lock，简称 X 锁）**：事务加写锁后，只有自身能读写表数据，其他事务无法加读锁或写锁，也不能查询或者修改数据，会被阻塞直到当前事务的写锁释放。\n\n##### 3.2.2 表锁的用法\n\n- 加锁：`lock tables 表名... read/write`\n- 解锁：`unlock tables 或者 客户端连接断开`\n\n##### 3.2.3 与MyISAM 存储引擎的关联\n\n​\t\t由于MyISAM 引擎不支持行锁，所有操作都依赖表锁，且默认会在`select`时隐式加读锁、`insert/update/delete`时隐式加写锁并自动释放。\n\n#### 3.3 元数据锁\n\n##### 3.3.1 元数据锁的概念和分类\n\n​\t\t**元数据锁（Metadata Lock，简称 MDL）`MDL` 不锁定数据本身，而是**保护表的元数据（如表结构、字段类型、索引信息等），避免 “表结构修改” 与 “数据读写” 同时进行导致的不一致。\n\n- **共享 MDL 锁（Shared MDL）**：事务执行查询（如`SELECT`）时自动加共享 `MDL` 锁，多个事务可同时加，互不影响。\n- **排他 MDL 锁（Exclusive MDL）**：事务执行表结构修改（如`ALTER TABLE`、`DROP COLUMN`）时自动加排他 MDL锁，加锁期间会阻塞所有其他事务的共享 `MDL` 锁请求。\n\n#### 3.4 意向锁\n\n##### 3.4.1 意向锁的概念和分类\n\n​\t\t意向锁是 “中间层锁”，作用是**快速判断表内是否存在行级锁**，避免表锁与行锁的冲突检查需要遍历所有行，提升效率。它仅标识 “意向”，不直接阻止数据读写。\n\n- **意向共享锁（Intention Shared Lock，简称 IS 锁）**：事务计划对表中某些行加读锁（行级 `S` 锁）前，会先对表加 `IS` 锁。\n- **意向排他锁（Intention Exclusive Lock，简称 IX 锁）**：事务计划对表中某些行加写锁（行级 `X` 锁）前，会先对表加 `IX` 锁。\n\n##### 3.4.2 意向锁的执行过程\n\n​\t\t**原来**：当执行根据 `id` 更新数据库表中的某一行数据时，会在这一行加上行锁，但是当另一个客户端需要加表锁的时候，会逐行检查是否有行锁的存在。效率极低。\n\n​\t\t**现在**(有了意向锁后)：当加行锁的时候，**同时会给这张表加上意向锁**，当另一个客户端需要加表锁的时候，就会先去检查这个意向锁**是否与自己要获取的锁兼容**，如果兼容，获取锁成功，如果不兼容，获取锁失败。\n\n\n\n### 4、行级锁\n\n#### 4.1 行级锁的分类\n\n- 行锁\n- 间隙锁\n- 临键锁\n\n#### 4.2 行锁\n\n##### 4.2.1 行锁的概念和分类\n\n​\t\t行锁是最基础的行级锁，**直接锁定表中某一行记录**，仅对锁定的行生效，不影响其他行。\n\n- 共享锁（`S` 锁）：事务对某行加 `S` 锁后，自身可读该行，其他事务可加 `S` 锁（共享读），但不能加 `X` 锁（阻塞写）。\n- 排他锁（`X` 锁）：事务对某行加 `X` 锁后，自身可读写该行，其他事务既不能加 `S` 锁也不能加 `X` 锁（读写都阻塞）。\n\n##### 4.2.2 行锁的特点\n\n​\t\t仅锁定具体行，粒度最细，并发影响最小，但加锁 / 释放锁开销略高于表锁。行锁必须**基于索引生效**，若查询未使用索引（进行的是全表扫描），InnoDB 会退化为表锁（意向锁 + 表锁）。\n\n#### 4.3 间隙锁\n\n##### 4.3.1 间隙锁的概念\n\n​\t\t间隙锁是**锁定索引记录之间的 “间隙”**，不锁定具体行，仅防止其他事务在间隙中插入新记录，解决 “幻读” 问题（RR 隔离级别下生效）。\n\n##### 4.3.2 什么是间隙\n\n​\t\t指索引值之间的空白区间。例如，表中某索引列存在值`10、20、30`，则间隙包括：`(-∞, 10)`、`(10, 20)`、`(20, 30)`、`(30, +∞)`。\n\n##### 4.3.3 间隙锁的作用\n\n​\t\t阻止在间隙中插入新行。例如，事务 A 对`(10, 20)`加间隙锁后，其他事务无法插入`15`（属于该间隙），但可以修改已存在的`10、20`（如果没被行锁锁定）。\n\n##### 4.3.4 间隙锁的触发场景\n\n​\t\t在 RR 隔离级别下，使用非唯一索引或范围查询（如`WHERE id > 10 AND id < 20`）时，InnoDB 会对匹配不到行的范围加间隙锁。\n\n> 注意：间隙锁之间不冲突（多个事务可同时对同一间隙加间隙锁）。\n\n#### 4.4 临键锁\n\n##### 4.4.1 临键锁的概念\n\n​\t\t临键锁是**行锁与间隙锁的组合**，是 InnoDB 在 RR 隔离级别下默认的行级锁类型，既锁定具体行，也锁定该行前面的间隙。\n\n##### 4.4.2 临键锁的作用\n\n​\t\t临键锁主要用来防止两种冲突\n\n- 其他事务修改锁定的行（行锁的作用）。\n- 其他事务在锁定的间隙中插入新行（间隙锁的作用）。\n\n##### 4.4.3 临键锁的触发场景\n\n​\t\t在 RR 隔离级别下，使用**非唯一索引进行等值查询或范围查询**时，若命中行，InnoDB 会对该行加行锁，同时对该行左侧的间隙加间隙锁，**组合为临键锁**。","slug":"MySQL锁","published":1,"updated":"2025-10-28T08:41:25.179Z","comments":1,"layout":"post","photos":[],"_id":"cuideTUH-6OeOauddoTblxfp2","content":"<h3 id=\"1、锁的分类\"><a href=\"#1、锁的分类\" class=\"headerlink\" title=\"1、锁的分类\"></a>1、锁的分类</h3><ul>\n<li>全局锁：锁住整个数据库，也就是锁住数据库中所有的表。</li>\n<li>表级锁：锁住整张表。</li>\n<li>行级锁：锁住单独的一行数据。</li>\n</ul>\n<h3 id=\"2、全局锁\"><a href=\"#2、全局锁\" class=\"headerlink\" title=\"2、全局锁\"></a>2、全局锁</h3><h4 id=\"2-1-全局锁的分类和作用\"><a href=\"#2-1-全局锁的分类和作用\" class=\"headerlink\" title=\"2.1 全局锁的分类和作用\"></a>2.1 全局锁的分类和作用</h4><p>​\t\tMySQL全局锁是针对整个数据库的锁。最常用的全局锁是读锁和写锁。</p>\n<ul>\n<li>读锁（共享锁）：它阻止其他用户更新数据，但允许他们读取数据。</li>\n<li>写锁（排他锁）：它阻止其他用户读取和更新数据。</li>\n</ul>\n<h4 id=\"2-2-全局锁的用法\"><a href=\"#2-2-全局锁的用法\" class=\"headerlink\" title=\"2.2 全局锁的用法\"></a>2.2 全局锁的用法</h4><ul>\n<li><code>FLUSH TABLES WITH READ/WRITE LOCK(FTWRL)</code>：用来锁住整个数据库</li>\n<li><code>UNLOCK TABLES</code> ：进行解锁</li>\n</ul>\n<h4 id=\"2-3-全局锁的使用场景\"><a href=\"#2-3-全局锁的使用场景\" class=\"headerlink\" title=\"2.3 全局锁的使用场景\"></a>2.3 全局锁的使用场景</h4><ul>\n<li><strong>备份全库</strong>：使用全局锁可以确保在备份过程中，数据库的所有表都保持一致的状态。</li>\n<li><strong>整体数据迁移</strong>：将整个数据库从一个服务器迁移到另一个服务器，需要阻止任何写操作，以确保所有的数据都被正确地迁移到新的服务器。</li>\n<li><strong>全库只读</strong>：在某些情况下，可能希望将整个数据库设置为只读模式。</li>\n</ul>\n<h3 id=\"3、表级锁\"><a href=\"#3、表级锁\" class=\"headerlink\" title=\"3、表级锁\"></a>3、表级锁</h3><h4 id=\"3-1-表级锁的分类\"><a href=\"#3-1-表级锁的分类\" class=\"headerlink\" title=\"3.1 表级锁的分类\"></a>3.1 表级锁的分类</h4><ul>\n<li><p>表锁</p>\n</li>\n<li><p>元数据锁</p>\n</li>\n<li><p>意向锁</p>\n<blockquote>\n<p>​        这里可能会疑惑为什么有表锁、意向锁、元数据锁会<strong>处于同一层级</strong>，不应该是表锁包含元数据锁和意向锁吗，这里其实陷入了一个误区，其实，表锁、意向锁、元数据锁 都属于 表<strong>级</strong>锁，而表<strong>级</strong>锁当然包括了表锁，同时，元数据锁和意向锁也都属于表<strong>级</strong>锁，同样，行锁和行<strong>级</strong>锁也是同样的道理，后面就不赘述了。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"3-2-表锁\"><a href=\"#3-2-表锁\" class=\"headerlink\" title=\"3.2 表锁\"></a>3.2 表锁</h4><h5 id=\"3-2-1-表锁的概念和分类\"><a href=\"#3-2-1-表锁的概念和分类\" class=\"headerlink\" title=\"3.2.1 表锁的概念和分类\"></a>3.2.1 表锁的概念和分类</h5><p>​\t\t表锁是<strong>最基础的表级锁</strong>，直接对整个表进行锁定，分为<strong>读锁和写锁</strong>，二者遵循 “读共享、写独占” 原则。</p>\n<ul>\n<li><strong>读锁（Shared Lock，简称 S 锁）</strong>：事务加读锁后，自身和其他事务只能读表，不能修改表数据。多个事务可同时对同一表加读锁，互不阻塞。</li>\n<li><strong>写锁（Exclusive Lock，简称 X 锁）</strong>：事务加写锁后，只有自身能读写表数据，其他事务无法加读锁或写锁，也不能查询或者修改数据，会被阻塞直到当前事务的写锁释放。</li>\n</ul>\n<h5 id=\"3-2-2-表锁的用法\"><a href=\"#3-2-2-表锁的用法\" class=\"headerlink\" title=\"3.2.2 表锁的用法\"></a>3.2.2 表锁的用法</h5><ul>\n<li>加锁：<code>lock tables 表名... read/write</code></li>\n<li>解锁：<code>unlock tables 或者 客户端连接断开</code></li>\n</ul>\n<h5 id=\"3-2-3-与MyISAM-存储引擎的关联\"><a href=\"#3-2-3-与MyISAM-存储引擎的关联\" class=\"headerlink\" title=\"3.2.3 与MyISAM 存储引擎的关联\"></a>3.2.3 与MyISAM 存储引擎的关联</h5><p>​\t\t由于MyISAM 引擎不支持行锁，所有操作都依赖表锁，且默认会在<code>select</code>时隐式加读锁、<code>insert/update/delete</code>时隐式加写锁并自动释放。</p>\n<h4 id=\"3-3-元数据锁\"><a href=\"#3-3-元数据锁\" class=\"headerlink\" title=\"3.3 元数据锁\"></a>3.3 元数据锁</h4><h5 id=\"3-3-1-元数据锁的概念和分类\"><a href=\"#3-3-1-元数据锁的概念和分类\" class=\"headerlink\" title=\"3.3.1 元数据锁的概念和分类\"></a>3.3.1 元数据锁的概念和分类</h5><p>​\t\t<strong>元数据锁（Metadata Lock，简称 MDL）<code>MDL</code> 不锁定数据本身，而是</strong>保护表的元数据（如表结构、字段类型、索引信息等），避免 “表结构修改” 与 “数据读写” 同时进行导致的不一致。</p>\n<ul>\n<li><strong>共享 MDL 锁（Shared MDL）</strong>：事务执行查询（如<code>SELECT</code>）时自动加共享 <code>MDL</code> 锁，多个事务可同时加，互不影响。</li>\n<li><strong>排他 MDL 锁（Exclusive MDL）</strong>：事务执行表结构修改（如<code>ALTER TABLE</code>、<code>DROP COLUMN</code>）时自动加排他 MDL锁，加锁期间会阻塞所有其他事务的共享 <code>MDL</code> 锁请求。</li>\n</ul>\n<h4 id=\"3-4-意向锁\"><a href=\"#3-4-意向锁\" class=\"headerlink\" title=\"3.4 意向锁\"></a>3.4 意向锁</h4><h5 id=\"3-4-1-意向锁的概念和分类\"><a href=\"#3-4-1-意向锁的概念和分类\" class=\"headerlink\" title=\"3.4.1 意向锁的概念和分类\"></a>3.4.1 意向锁的概念和分类</h5><p>​\t\t意向锁是 “中间层锁”，作用是<strong>快速判断表内是否存在行级锁</strong>，避免表锁与行锁的冲突检查需要遍历所有行，提升效率。它仅标识 “意向”，不直接阻止数据读写。</p>\n<ul>\n<li><strong>意向共享锁（Intention Shared Lock，简称 IS 锁）</strong>：事务计划对表中某些行加读锁（行级 <code>S</code> 锁）前，会先对表加 <code>IS</code> 锁。</li>\n<li><strong>意向排他锁（Intention Exclusive Lock，简称 IX 锁）</strong>：事务计划对表中某些行加写锁（行级 <code>X</code> 锁）前，会先对表加 <code>IX</code> 锁。</li>\n</ul>\n<h5 id=\"3-4-2-意向锁的执行过程\"><a href=\"#3-4-2-意向锁的执行过程\" class=\"headerlink\" title=\"3.4.2 意向锁的执行过程\"></a>3.4.2 意向锁的执行过程</h5><p>​\t\t<strong>原来</strong>：当执行根据 <code>id</code> 更新数据库表中的某一行数据时，会在这一行加上行锁，但是当另一个客户端需要加表锁的时候，会逐行检查是否有行锁的存在。效率极低。</p>\n<p>​\t\t<strong>现在</strong>(有了意向锁后)：当加行锁的时候，<strong>同时会给这张表加上意向锁</strong>，当另一个客户端需要加表锁的时候，就会先去检查这个意向锁<strong>是否与自己要获取的锁兼容</strong>，如果兼容，获取锁成功，如果不兼容，获取锁失败。</p>\n<h3 id=\"4、行级锁\"><a href=\"#4、行级锁\" class=\"headerlink\" title=\"4、行级锁\"></a>4、行级锁</h3><h4 id=\"4-1-行级锁的分类\"><a href=\"#4-1-行级锁的分类\" class=\"headerlink\" title=\"4.1 行级锁的分类\"></a>4.1 行级锁的分类</h4><ul>\n<li>行锁</li>\n<li>间隙锁</li>\n<li>临键锁</li>\n</ul>\n<h4 id=\"4-2-行锁\"><a href=\"#4-2-行锁\" class=\"headerlink\" title=\"4.2 行锁\"></a>4.2 行锁</h4><h5 id=\"4-2-1-行锁的概念和分类\"><a href=\"#4-2-1-行锁的概念和分类\" class=\"headerlink\" title=\"4.2.1 行锁的概念和分类\"></a>4.2.1 行锁的概念和分类</h5><p>​\t\t行锁是最基础的行级锁，<strong>直接锁定表中某一行记录</strong>，仅对锁定的行生效，不影响其他行。</p>\n<ul>\n<li>共享锁（<code>S</code> 锁）：事务对某行加 <code>S</code> 锁后，自身可读该行，其他事务可加 <code>S</code> 锁（共享读），但不能加 <code>X</code> 锁（阻塞写）。</li>\n<li>排他锁（<code>X</code> 锁）：事务对某行加 <code>X</code> 锁后，自身可读写该行，其他事务既不能加 <code>S</code> 锁也不能加 <code>X</code> 锁（读写都阻塞）。</li>\n</ul>\n<h5 id=\"4-2-2-行锁的特点\"><a href=\"#4-2-2-行锁的特点\" class=\"headerlink\" title=\"4.2.2 行锁的特点\"></a>4.2.2 行锁的特点</h5><p>​\t\t仅锁定具体行，粒度最细，并发影响最小，但加锁 &#x2F; 释放锁开销略高于表锁。行锁必须<strong>基于索引生效</strong>，若查询未使用索引（进行的是全表扫描），InnoDB 会退化为表锁（意向锁 + 表锁）。</p>\n<h4 id=\"4-3-间隙锁\"><a href=\"#4-3-间隙锁\" class=\"headerlink\" title=\"4.3 间隙锁\"></a>4.3 间隙锁</h4><h5 id=\"4-3-1-间隙锁的概念\"><a href=\"#4-3-1-间隙锁的概念\" class=\"headerlink\" title=\"4.3.1 间隙锁的概念\"></a>4.3.1 间隙锁的概念</h5><p>​\t\t间隙锁是<strong>锁定索引记录之间的 “间隙”</strong>，不锁定具体行，仅防止其他事务在间隙中插入新记录，解决 “幻读” 问题（RR 隔离级别下生效）。</p>\n<h5 id=\"4-3-2-什么是间隙\"><a href=\"#4-3-2-什么是间隙\" class=\"headerlink\" title=\"4.3.2 什么是间隙\"></a>4.3.2 什么是间隙</h5><p>​\t\t指索引值之间的空白区间。例如，表中某索引列存在值<code>10、20、30</code>，则间隙包括：<code>(-∞, 10)</code>、<code>(10, 20)</code>、<code>(20, 30)</code>、<code>(30, +∞)</code>。</p>\n<h5 id=\"4-3-3-间隙锁的作用\"><a href=\"#4-3-3-间隙锁的作用\" class=\"headerlink\" title=\"4.3.3 间隙锁的作用\"></a>4.3.3 间隙锁的作用</h5><p>​\t\t阻止在间隙中插入新行。例如，事务 A 对<code>(10, 20)</code>加间隙锁后，其他事务无法插入<code>15</code>（属于该间隙），但可以修改已存在的<code>10、20</code>（如果没被行锁锁定）。</p>\n<h5 id=\"4-3-4-间隙锁的触发场景\"><a href=\"#4-3-4-间隙锁的触发场景\" class=\"headerlink\" title=\"4.3.4 间隙锁的触发场景\"></a>4.3.4 间隙锁的触发场景</h5><p>​\t\t在 RR 隔离级别下，使用非唯一索引或范围查询（如<code>WHERE id &gt; 10 AND id &lt; 20</code>）时，InnoDB 会对匹配不到行的范围加间隙锁。</p>\n<blockquote>\n<p>注意：间隙锁之间不冲突（多个事务可同时对同一间隙加间隙锁）。</p>\n</blockquote>\n<h4 id=\"4-4-临键锁\"><a href=\"#4-4-临键锁\" class=\"headerlink\" title=\"4.4 临键锁\"></a>4.4 临键锁</h4><h5 id=\"4-4-1-临键锁的概念\"><a href=\"#4-4-1-临键锁的概念\" class=\"headerlink\" title=\"4.4.1 临键锁的概念\"></a>4.4.1 临键锁的概念</h5><p>​\t\t临键锁是<strong>行锁与间隙锁的组合</strong>，是 InnoDB 在 RR 隔离级别下默认的行级锁类型，既锁定具体行，也锁定该行前面的间隙。</p>\n<h5 id=\"4-4-2-临键锁的作用\"><a href=\"#4-4-2-临键锁的作用\" class=\"headerlink\" title=\"4.4.2 临键锁的作用\"></a>4.4.2 临键锁的作用</h5><p>​\t\t临键锁主要用来防止两种冲突</p>\n<ul>\n<li>其他事务修改锁定的行（行锁的作用）。</li>\n<li>其他事务在锁定的间隙中插入新行（间隙锁的作用）。</li>\n</ul>\n<h5 id=\"4-4-3-临键锁的触发场景\"><a href=\"#4-4-3-临键锁的触发场景\" class=\"headerlink\" title=\"4.4.3 临键锁的触发场景\"></a>4.4.3 临键锁的触发场景</h5><p>​\t\t在 RR 隔离级别下，使用<strong>非唯一索引进行等值查询或范围查询</strong>时，若命中行，InnoDB 会对该行加行锁，同时对该行左侧的间隙加间隙锁，<strong>组合为临键锁</strong>。</p>\n","abbrlink":"d940f18d","wordCount":107,"charCount":2507,"imgCount":0,"vidCount":0,"wsCount":0,"cbCount":0,"readTime":"约46秒","excerpt":"","more":"<h3 id=\"1、锁的分类\"><a href=\"#1、锁的分类\" class=\"headerlink\" title=\"1、锁的分类\"></a>1、锁的分类</h3><ul>\n<li>全局锁：锁住整个数据库，也就是锁住数据库中所有的表。</li>\n<li>表级锁：锁住整张表。</li>\n<li>行级锁：锁住单独的一行数据。</li>\n</ul>\n<h3 id=\"2、全局锁\"><a href=\"#2、全局锁\" class=\"headerlink\" title=\"2、全局锁\"></a>2、全局锁</h3><h4 id=\"2-1-全局锁的分类和作用\"><a href=\"#2-1-全局锁的分类和作用\" class=\"headerlink\" title=\"2.1 全局锁的分类和作用\"></a>2.1 全局锁的分类和作用</h4><p>​\t\tMySQL全局锁是针对整个数据库的锁。最常用的全局锁是读锁和写锁。</p>\n<ul>\n<li>读锁（共享锁）：它阻止其他用户更新数据，但允许他们读取数据。</li>\n<li>写锁（排他锁）：它阻止其他用户读取和更新数据。</li>\n</ul>\n<h4 id=\"2-2-全局锁的用法\"><a href=\"#2-2-全局锁的用法\" class=\"headerlink\" title=\"2.2 全局锁的用法\"></a>2.2 全局锁的用法</h4><ul>\n<li><code>FLUSH TABLES WITH READ/WRITE LOCK(FTWRL)</code>：用来锁住整个数据库</li>\n<li><code>UNLOCK TABLES</code> ：进行解锁</li>\n</ul>\n<h4 id=\"2-3-全局锁的使用场景\"><a href=\"#2-3-全局锁的使用场景\" class=\"headerlink\" title=\"2.3 全局锁的使用场景\"></a>2.3 全局锁的使用场景</h4><ul>\n<li><strong>备份全库</strong>：使用全局锁可以确保在备份过程中，数据库的所有表都保持一致的状态。</li>\n<li><strong>整体数据迁移</strong>：将整个数据库从一个服务器迁移到另一个服务器，需要阻止任何写操作，以确保所有的数据都被正确地迁移到新的服务器。</li>\n<li><strong>全库只读</strong>：在某些情况下，可能希望将整个数据库设置为只读模式。</li>\n</ul>\n<h3 id=\"3、表级锁\"><a href=\"#3、表级锁\" class=\"headerlink\" title=\"3、表级锁\"></a>3、表级锁</h3><h4 id=\"3-1-表级锁的分类\"><a href=\"#3-1-表级锁的分类\" class=\"headerlink\" title=\"3.1 表级锁的分类\"></a>3.1 表级锁的分类</h4><ul>\n<li><p>表锁</p>\n</li>\n<li><p>元数据锁</p>\n</li>\n<li><p>意向锁</p>\n<blockquote>\n<p>​        这里可能会疑惑为什么有表锁、意向锁、元数据锁会<strong>处于同一层级</strong>，不应该是表锁包含元数据锁和意向锁吗，这里其实陷入了一个误区，其实，表锁、意向锁、元数据锁 都属于 表<strong>级</strong>锁，而表<strong>级</strong>锁当然包括了表锁，同时，元数据锁和意向锁也都属于表<strong>级</strong>锁，同样，行锁和行<strong>级</strong>锁也是同样的道理，后面就不赘述了。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"3-2-表锁\"><a href=\"#3-2-表锁\" class=\"headerlink\" title=\"3.2 表锁\"></a>3.2 表锁</h4><h5 id=\"3-2-1-表锁的概念和分类\"><a href=\"#3-2-1-表锁的概念和分类\" class=\"headerlink\" title=\"3.2.1 表锁的概念和分类\"></a>3.2.1 表锁的概念和分类</h5><p>​\t\t表锁是<strong>最基础的表级锁</strong>，直接对整个表进行锁定，分为<strong>读锁和写锁</strong>，二者遵循 “读共享、写独占” 原则。</p>\n<ul>\n<li><strong>读锁（Shared Lock，简称 S 锁）</strong>：事务加读锁后，自身和其他事务只能读表，不能修改表数据。多个事务可同时对同一表加读锁，互不阻塞。</li>\n<li><strong>写锁（Exclusive Lock，简称 X 锁）</strong>：事务加写锁后，只有自身能读写表数据，其他事务无法加读锁或写锁，也不能查询或者修改数据，会被阻塞直到当前事务的写锁释放。</li>\n</ul>\n<h5 id=\"3-2-2-表锁的用法\"><a href=\"#3-2-2-表锁的用法\" class=\"headerlink\" title=\"3.2.2 表锁的用法\"></a>3.2.2 表锁的用法</h5><ul>\n<li>加锁：<code>lock tables 表名... read/write</code></li>\n<li>解锁：<code>unlock tables 或者 客户端连接断开</code></li>\n</ul>\n<h5 id=\"3-2-3-与MyISAM-存储引擎的关联\"><a href=\"#3-2-3-与MyISAM-存储引擎的关联\" class=\"headerlink\" title=\"3.2.3 与MyISAM 存储引擎的关联\"></a>3.2.3 与MyISAM 存储引擎的关联</h5><p>​\t\t由于MyISAM 引擎不支持行锁，所有操作都依赖表锁，且默认会在<code>select</code>时隐式加读锁、<code>insert/update/delete</code>时隐式加写锁并自动释放。</p>\n<h4 id=\"3-3-元数据锁\"><a href=\"#3-3-元数据锁\" class=\"headerlink\" title=\"3.3 元数据锁\"></a>3.3 元数据锁</h4><h5 id=\"3-3-1-元数据锁的概念和分类\"><a href=\"#3-3-1-元数据锁的概念和分类\" class=\"headerlink\" title=\"3.3.1 元数据锁的概念和分类\"></a>3.3.1 元数据锁的概念和分类</h5><p>​\t\t<strong>元数据锁（Metadata Lock，简称 MDL）<code>MDL</code> 不锁定数据本身，而是</strong>保护表的元数据（如表结构、字段类型、索引信息等），避免 “表结构修改” 与 “数据读写” 同时进行导致的不一致。</p>\n<ul>\n<li><strong>共享 MDL 锁（Shared MDL）</strong>：事务执行查询（如<code>SELECT</code>）时自动加共享 <code>MDL</code> 锁，多个事务可同时加，互不影响。</li>\n<li><strong>排他 MDL 锁（Exclusive MDL）</strong>：事务执行表结构修改（如<code>ALTER TABLE</code>、<code>DROP COLUMN</code>）时自动加排他 MDL锁，加锁期间会阻塞所有其他事务的共享 <code>MDL</code> 锁请求。</li>\n</ul>\n<h4 id=\"3-4-意向锁\"><a href=\"#3-4-意向锁\" class=\"headerlink\" title=\"3.4 意向锁\"></a>3.4 意向锁</h4><h5 id=\"3-4-1-意向锁的概念和分类\"><a href=\"#3-4-1-意向锁的概念和分类\" class=\"headerlink\" title=\"3.4.1 意向锁的概念和分类\"></a>3.4.1 意向锁的概念和分类</h5><p>​\t\t意向锁是 “中间层锁”，作用是<strong>快速判断表内是否存在行级锁</strong>，避免表锁与行锁的冲突检查需要遍历所有行，提升效率。它仅标识 “意向”，不直接阻止数据读写。</p>\n<ul>\n<li><strong>意向共享锁（Intention Shared Lock，简称 IS 锁）</strong>：事务计划对表中某些行加读锁（行级 <code>S</code> 锁）前，会先对表加 <code>IS</code> 锁。</li>\n<li><strong>意向排他锁（Intention Exclusive Lock，简称 IX 锁）</strong>：事务计划对表中某些行加写锁（行级 <code>X</code> 锁）前，会先对表加 <code>IX</code> 锁。</li>\n</ul>\n<h5 id=\"3-4-2-意向锁的执行过程\"><a href=\"#3-4-2-意向锁的执行过程\" class=\"headerlink\" title=\"3.4.2 意向锁的执行过程\"></a>3.4.2 意向锁的执行过程</h5><p>​\t\t<strong>原来</strong>：当执行根据 <code>id</code> 更新数据库表中的某一行数据时，会在这一行加上行锁，但是当另一个客户端需要加表锁的时候，会逐行检查是否有行锁的存在。效率极低。</p>\n<p>​\t\t<strong>现在</strong>(有了意向锁后)：当加行锁的时候，<strong>同时会给这张表加上意向锁</strong>，当另一个客户端需要加表锁的时候，就会先去检查这个意向锁<strong>是否与自己要获取的锁兼容</strong>，如果兼容，获取锁成功，如果不兼容，获取锁失败。</p>\n<h3 id=\"4、行级锁\"><a href=\"#4、行级锁\" class=\"headerlink\" title=\"4、行级锁\"></a>4、行级锁</h3><h4 id=\"4-1-行级锁的分类\"><a href=\"#4-1-行级锁的分类\" class=\"headerlink\" title=\"4.1 行级锁的分类\"></a>4.1 行级锁的分类</h4><ul>\n<li>行锁</li>\n<li>间隙锁</li>\n<li>临键锁</li>\n</ul>\n<h4 id=\"4-2-行锁\"><a href=\"#4-2-行锁\" class=\"headerlink\" title=\"4.2 行锁\"></a>4.2 行锁</h4><h5 id=\"4-2-1-行锁的概念和分类\"><a href=\"#4-2-1-行锁的概念和分类\" class=\"headerlink\" title=\"4.2.1 行锁的概念和分类\"></a>4.2.1 行锁的概念和分类</h5><p>​\t\t行锁是最基础的行级锁，<strong>直接锁定表中某一行记录</strong>，仅对锁定的行生效，不影响其他行。</p>\n<ul>\n<li>共享锁（<code>S</code> 锁）：事务对某行加 <code>S</code> 锁后，自身可读该行，其他事务可加 <code>S</code> 锁（共享读），但不能加 <code>X</code> 锁（阻塞写）。</li>\n<li>排他锁（<code>X</code> 锁）：事务对某行加 <code>X</code> 锁后，自身可读写该行，其他事务既不能加 <code>S</code> 锁也不能加 <code>X</code> 锁（读写都阻塞）。</li>\n</ul>\n<h5 id=\"4-2-2-行锁的特点\"><a href=\"#4-2-2-行锁的特点\" class=\"headerlink\" title=\"4.2.2 行锁的特点\"></a>4.2.2 行锁的特点</h5><p>​\t\t仅锁定具体行，粒度最细，并发影响最小，但加锁 &#x2F; 释放锁开销略高于表锁。行锁必须<strong>基于索引生效</strong>，若查询未使用索引（进行的是全表扫描），InnoDB 会退化为表锁（意向锁 + 表锁）。</p>\n<h4 id=\"4-3-间隙锁\"><a href=\"#4-3-间隙锁\" class=\"headerlink\" title=\"4.3 间隙锁\"></a>4.3 间隙锁</h4><h5 id=\"4-3-1-间隙锁的概念\"><a href=\"#4-3-1-间隙锁的概念\" class=\"headerlink\" title=\"4.3.1 间隙锁的概念\"></a>4.3.1 间隙锁的概念</h5><p>​\t\t间隙锁是<strong>锁定索引记录之间的 “间隙”</strong>，不锁定具体行，仅防止其他事务在间隙中插入新记录，解决 “幻读” 问题（RR 隔离级别下生效）。</p>\n<h5 id=\"4-3-2-什么是间隙\"><a href=\"#4-3-2-什么是间隙\" class=\"headerlink\" title=\"4.3.2 什么是间隙\"></a>4.3.2 什么是间隙</h5><p>​\t\t指索引值之间的空白区间。例如，表中某索引列存在值<code>10、20、30</code>，则间隙包括：<code>(-∞, 10)</code>、<code>(10, 20)</code>、<code>(20, 30)</code>、<code>(30, +∞)</code>。</p>\n<h5 id=\"4-3-3-间隙锁的作用\"><a href=\"#4-3-3-间隙锁的作用\" class=\"headerlink\" title=\"4.3.3 间隙锁的作用\"></a>4.3.3 间隙锁的作用</h5><p>​\t\t阻止在间隙中插入新行。例如，事务 A 对<code>(10, 20)</code>加间隙锁后，其他事务无法插入<code>15</code>（属于该间隙），但可以修改已存在的<code>10、20</code>（如果没被行锁锁定）。</p>\n<h5 id=\"4-3-4-间隙锁的触发场景\"><a href=\"#4-3-4-间隙锁的触发场景\" class=\"headerlink\" title=\"4.3.4 间隙锁的触发场景\"></a>4.3.4 间隙锁的触发场景</h5><p>​\t\t在 RR 隔离级别下，使用非唯一索引或范围查询（如<code>WHERE id &gt; 10 AND id &lt; 20</code>）时，InnoDB 会对匹配不到行的范围加间隙锁。</p>\n<blockquote>\n<p>注意：间隙锁之间不冲突（多个事务可同时对同一间隙加间隙锁）。</p>\n</blockquote>\n<h4 id=\"4-4-临键锁\"><a href=\"#4-4-临键锁\" class=\"headerlink\" title=\"4.4 临键锁\"></a>4.4 临键锁</h4><h5 id=\"4-4-1-临键锁的概念\"><a href=\"#4-4-1-临键锁的概念\" class=\"headerlink\" title=\"4.4.1 临键锁的概念\"></a>4.4.1 临键锁的概念</h5><p>​\t\t临键锁是<strong>行锁与间隙锁的组合</strong>，是 InnoDB 在 RR 隔离级别下默认的行级锁类型，既锁定具体行，也锁定该行前面的间隙。</p>\n<h5 id=\"4-4-2-临键锁的作用\"><a href=\"#4-4-2-临键锁的作用\" class=\"headerlink\" title=\"4.4.2 临键锁的作用\"></a>4.4.2 临键锁的作用</h5><p>​\t\t临键锁主要用来防止两种冲突</p>\n<ul>\n<li>其他事务修改锁定的行（行锁的作用）。</li>\n<li>其他事务在锁定的间隙中插入新行（间隙锁的作用）。</li>\n</ul>\n<h5 id=\"4-4-3-临键锁的触发场景\"><a href=\"#4-4-3-临键锁的触发场景\" class=\"headerlink\" title=\"4.4.3 临键锁的触发场景\"></a>4.4.3 临键锁的触发场景</h5><p>​\t\t在 RR 隔离级别下，使用<strong>非唯一索引进行等值查询或范围查询</strong>时，若命中行，InnoDB 会对该行加行锁，同时对该行左侧的间隙加间隙锁，<strong>组合为临键锁</strong>。</p>\n"},{"title":"操作系统知识点","description":"文章缩略，支持 `Markdown` **文档格式**\n","pinned":0,"lang":"zh","type":"post","date":"2025-10-28T08:46:23.000Z","_content":"## 一、操作系统基础\n\n### 1、什么是操作系统\n\n​    操作系统（Operating System 简称 OS）本质上是一个运行在计算机上的软件程序，用于管理计算机硬件和软件资源。例如，运行在电脑上的所有应用程序都是通过操作系统来调用系统内存以及磁盘等硬件。\n\n\n\n### 2、操作系统的内核\n\n​    操作系统的内核时操作系统的核心部分，负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。内核时连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。\n\n\n\n### 3、用户态和系统态\n\n- 用户态：用户态运行的进程可以直接读取用户程序的数据\n- 系统态：可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制，包括内存、CPU 指令等\n\n\n\n### 4、系统调用\n\n​    运行的程序基本都是运行在用户态，如果需要调用操作系统提供的系统态级别的子功能，就需要切换到系统态来调用。也就是说，运行的用户程序中，凡是与系统态级别的资源有关的操作（如 文件管理，进程控制，内存管理等），都必须通过系统调用方式向操作系统提出服务，并由操作系统代为完成。\n\n​    系统调用大致分为一下几类：\n\n- 设备管理。完成设备的请求或释放，设备启动等功能。\n- 文件管理。完成文件的读、写、创建、删除等功能。\n- 进程管理。完成进程的创建、撤销、阻塞、唤醒等功能。\n- 进程通信。完成进程之间的消息传递或信号传递等。\n- 内存管理。完成内存的分配、回收、获取作业占用内存大小以及地址等。\n\n## 二、进程和线程\n\n### 1、进程和线程的区别\n\n- **进程**：操作系统进行**资源分配的基本单位**（如内存、CPU 时间片、文件句柄等），可理解为 “一个正在运行的程序实例”（例如打开的 Chrome 浏览器、一个 Java 程序），是一个独立的 “资源容器”。\n- **线程**：操作系统进行**任务调度的基本单位**，是进程内的 “最小执行单元”（例如 Chrome 的一个标签页渲染线程、Java 程序的`main`线程），必须依赖进程存在，无法独立运行。\n\n​    从 JVM 的角度看，一个进程可以有多个线程，多个线程共享进程的**堆**和**方法区**，但是每个线程都有自己的**程序计数器**、**虚拟机栈**、**本地方法栈**。线程是进程划分成的更小的运行单元，一个进程在其执行的过程中可以产生多个线程。线程和进程最大的不同在于，进程之间是相互独立的，而线程之间不一定，因为同一个进程中的线程极有可能相互影响。线程执行开销小，但是不利于资源的管理和保护，而进程正相反。\n\n\n\n### 2、进程有哪几种状态\n\n- **创建状态** ：进程正被创建。\n    - 引起进程创建原因：用户登录、作业调度、提供服务、应用请求 都会引起进程的创建。\n- **就绪状态** ：进程已处于准备运行状态，即 进程获得了除处理器以外的一切所需的资源，一旦得到处理器资源，即可运行。\n- **运行状态** ：进程正在处理器上运行。\n- **阻塞状态** ：进程正在等待某一事件而暂停运行，即使处理器处于空闲状态，该进程也不能运行，是进程主动提出\n    - 原因：向操作系统请求共享资源失败、等待某种操作的完成、新数据尚未、等待IO操作的结束。\n- **终止状态** ：进程终止运行。\n    - 原因：正常结束、异常结束、外界干预。\n\n补充：\n\n- **进程的挂起** ：当系统中出现引起进程挂起的事件时，OS 会利用挂起原语将指定的进程挂起，如果进程时就绪状态，则改为静止就绪状态，如果是阻塞状态，则改为静止阻塞，如果运行状态，则将其转向调度程序重新调度。\n- **进程的激活** ：当系统中出现激活进程的事件后，OS 会利用原语将指定的进程激活。\n\n\n\n### 3、进程间的通信方式\n\n- **管道通信**\n    - 匿名管道：用于父进程和子进程之间的通信。\n    - 有名管道：用于任意两个进程之间的通信。\n- **信号**：信号是一种比较复杂的通信方式，用于通知接收进程有某种事件发生。\n- **消息队列**：消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道不同的是消息队列存放在内核中，只有在内核重启或者显示地删除一个消息队列时，该消息才会被真正的删除。消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按照消息的类型读取。**消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。**\n- **信号量** ：信号量是一个计数器，常被作为一种**锁机制**，用于多进程对共享数据的访问，信号量主要作为进程间以及同一进程内不同线程间的同步手段。\n- **共享内存** ：共享内存可以使运行在同一台机器上的进程间的**通信最快**。使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存种数据的更新，这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。\n- **套接字** ：此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持TCP/IP的网络通信的基本操作单元，可以看作是不同主机之间的进程进行双向通信的端点，简单来说就是通信双方的一种约定，用套接字的相关函数来完成通信过程。\n\n\n\n### 4、线程间的同步方式\n\n​    线程同步是两个或多个共享资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步方式。\n\n- **互斥量** ：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。例如：Java 中的synchronized 关键字和各种Lock都是这种机制。\n\n- **信号量** ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。\n\n- **事件** ：通过通知操作（挂起和唤醒）的方式来保持多线程同步，还可以方便的实现多线程优先级得比较操作。\n\n\n\n### 5、进程的调度\n\n​    进程调度的任务主要有三，① 保存CPU现场信息 ② 按照某种算法选取进程 ③ 把 CPU 分配给该进程\n\n​    进程调度算法一般有四种：\n\n- **先到先服务** ： 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某种事件而被阻塞放弃占用CPU资源时再重新调度。\n\n- **短作业优先** ：从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某种事件而被阻塞放弃占用CPU资源时再重新调度。\n    - 缺点：必须预先知道作业的运行时间，但是这个时间很难估计准确，如果偏短，系统可能会提前终止进程。\n    - 缺点：对长作业非常不利，周转时间会明显增长。\n    - 缺点：完全没有考虑作业的紧迫程度。\n\n- **时间片轮转** ：时间片轮转调度是一种古老，最简单，最公平且使用最广的调度算法，每个进程被分配一个时间段，称作它的时间片，也就是该进程允许运行的时间。\n\n- **多级反馈队列** ：**短进程优先** 仅照顾了短进程，而忽略了长进程。而多级返回调度算法既能使高优先级的作业得到响应，又能响应短作业进程迅速完成，因此是被公认的最好的调度算法，UNIX 采用的就是这种调度算法。\n    - 机制：① 设置多个就绪队列\n    - 机制：② 每个队列都采用先来先服务调度算法\n    - 机制：③ 按队列优先级调度\n\n- **优先级调度** ：为每个进程分配优先级，首先执行具有高优先级的进程，以此类推，具有相同优先级的进程以先进先出的顺序执行。可以根据内存要求，时间要求或者任何其他资源的要求来确定优先级。\n\n\n\n### 6、什么是死锁\n\n​    死锁描述的是这样一种情况，多个进程/线程同时被阻塞，他们中的一个或全部都在等待某个资源被释放，但他们都会因为不能不能获得自己的资源去继续运行而无法释放自己当下占有的资源，并且一直处于这样的僵持状态，而形成死锁。\n\n\n\n### 7、产生死锁的四个必要条件\n\n- **互斥条件** ：资源必须处于非共享模式，即：一次只有一个进程可以使用。如果另一个进程申请该资源，那么必须等待直到该资源被释放为止。\n- **请求和保持条件** ：一个进程至少占有了一个资源，并等待另一个资源，而该资源被其它线程所占有。\n- **不可抢占条件** ： 资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。\n- **循环等待条件** ：一组进程`{P0,P1,...,Pn}` `P0` 等待的资源被 `P1`占有，`P1` 等待的资源被`P2` 占有，最后 `Pn` 等待的资源被`P1` 占有，形成循环等待的情况。\n\n> 这四个条件是产生死锁的 **必要条件** ，也就是说只要系统发生死锁，这些条件必然成立，而只要让上述条件之一不满足，就不会产生死锁。\n\n\n\n### 8、解决死锁的方法\n\n#### 1、死锁的预防\n\n​\t\t**预防死锁** ：是采用某种策略，**限制并发进程对资源的请求**，从而使得死锁的必要条件在系统执行的任何时间都不满足。\n\n​\t\t只要破坏四个必要条件中的一个就能够预防死锁的发生。\n\n​    \t破坏第一个条件 **互斥条件** ：使得资源可以同时被访问，这种是最简单的方法，磁盘可以用这种方法管理，但是系统中的很多资源 **往往是不能被同时访问的** ，所以这种做法在大多数场合是行不通的。\n\n​    \t破坏第三个条件 **不可抢占条件** ：也就是说，可以采用 **剥夺式调度算法** ，但是，这种调度算法实现起来比较复杂，并且一个资源在被使用一段时间后被抢占，可能导致进程前一段时间的工作失效，还可能因为反复申请和释放资源导致进程的执行被无限期的推迟，既增加了系统开销，也降低了吞吐量。\n\n​    \t所以，一般比较实用的预防死锁的方法是，通过破坏第二个条件和第四个条件。\n\n1. **静态分配策略**\n\n​    静态分配策略就是指一个进程必须在执行前就申请到它所需要的全部资源，否则直到它所要的资源得到满足后才开始运行。进程要么占有所有资源开始运行，要么不占有资源，不会出现一些资源等待一些资源的情况。\n\n​    静态分配策略逻辑简单，实现也很容易，但这种策略 **严重地降低了资源利用率**，因为在每个进程所占有的资源中，有一些资源是在比较靠后的执行时间里才用的，甚至有些资源是在额外的情况下才使用的，这样就可能造成一个进程占有了一些 **几乎不用的资源而是使用其他需要该资源的进程产生等待** 的情况。\n\n1. **2、层次分配策略**\n\n​    层次分配策略破坏了产生死锁的第四个条件，在层次分配策略下，所有的资源被分成了多个层次，一个进程得到某一次的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源，这种策略，是不能可能出现循环等待链的，因为那样的话，就出现了已经申请了较高层的资源，反而去申请了较低层的资源，不符合层次分配策略。\n\n#### 2、避免死锁\n\n​\t\t**避免死锁** ：是系统在分配资源时，根据资源的使用情况**提前做出预测**，从而**避免死锁的发生**\n\n​\t\t死锁的避免的角度是允许系统中**同时存在四个必要条件**，只要掌握并发进程中与每个进程有关的资源动态申请情况，做出 **明智合理的选择**，仍可以避免死锁，因为四大条件仅仅是产生死锁的必要条件。\n\n​    可以将系统分为 **安全状态** 和 **不安全状态** ，每当为申请者分配资源前，先检测系统状态，如果把系统资源分配给申请者会产生死锁，则拒绝分配，否则接受申请，并为它分配资源。\n\n> 安全状态，如果操作系统能够保证所有进程在有限时间内得到需要的全部资源，否则是不安全状态\n\n​    \t避免死锁的算法是，**银行家算法** ，也就是：当一个线程申请使用资源时，**银行家算法** 通过 **试探** 分配给该进程资源，然后通过 **安全性算法** 分析分配后系统是否处于安全状态，若处于不安全状态，则试探分配作废，让该进程继续等待，若能够进入安全状态，则就**真的分配资源给该进程**\n\n#### 3、死锁的检测\n\n​\t\t**检测死锁** ：是指系统设有**专门的机构**，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。\n\n​\t\t这种方法对资源的分配不加以限制，也不采取死锁避免的措施，但系统会**定时地运行一个 “死锁检测” 的程序**，判断系统内是否出现死锁，如果检测到系统发生了死锁，再采取措施去解除它。\n\n​\t\t可以利用 **进程-资源分配图** 是否又环路来检测死锁，但是，有环路不一定死锁。\n\n\n\n#### 4、死锁的解除\n\n​\t\t**解除死锁** ：是与检测相配套的一种措施，用于**将进程从死锁状态下解脱出来**\n\n​\t\t当死锁检测程序检测到存在死锁发生时，应设法让其解除，让系统从死锁中恢复过来。\n\n- **立即结束所有进程的执行，重新启动操作系统**，方法简单，但是之前的工作全部作废，损失很大。\n- **撤销涉及死锁的所有进程，解除死锁后继续运行**，彻底打破死锁的循环等待条件，付出的代价也较大，例如一个进程计算了很长时间，由于被撤销，部分结果也被消除，重新执行就要再次计算。\n- **逐个撤销涉及死锁的进程，回收资源直到死锁解除**\n- **抢占资源**，从涉及死锁的一个或几个进程中抢占资源，再把夺到的资源分配出去，知道死锁解除。\n\n## 三、操作系统内存管理基础\n\n### 1、内存管理介绍\n\n​\t\t操作系统的内存管理主要负责内存的分配和回收，另外地址转换也就是将逻辑地址转换为相应的物理地址等功能也是操作系统内存管理的事情。\n\n\n\n### 2、内存管理机制与方式\n\n​\t\t简单的分为 **连续分配管理方式** 和 **非连续分配管理方式** 这两种。连续分配管理方式是指为一个用户程序分配一段连续的内存空间，常见的如 **块式管理**。同样的，非连续分配管理方式，允许一个程序使用的内存分布在离散或者说不相邻的内存空间中，常见的有 **页式管理** 、 **段式管理**、**段页式管理**。\n\n1. **块式管理**：远古时代的计算机操作系统的内存管理方式。将内存分为几个固定大小的块，每个块只包含一个进程。如果程序需要内存的话，操作系统就分配给它一个块，如果程序运行只需要很小的空间的话，分配的这个块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。\n\n2. **页式管理**：把主存分为大小相等且固定的一页一页的形式，页比较小，相比于块式管理，划分粒度更小，提高了内存的利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。\n\n   地址转化：\n\n   `逻辑地址 = 页号（Page Number） + 页内偏移（Offset）`\n\n   `物理地址 = 页框号（Frame Number） + 页内偏移（Offset）`\n\n3. **段式管理**：页式管理虽然提高了内存利用率，但是页式管理中的页并无任何实际的意义。段式管理把主存分为一段一段的，段是有实际的意义的，每个段顶一了一组逻辑信息，例如，有主程序段、子程序段、数据段、栈段等。段式管理通过段表对应的逻辑地址和物理地址。\n\n   地址转换：\n\n   `逻辑地址 = 段号（Segment Number） + 段内偏移（Offset）`\n\n   `物理地址 = 段基址（Base Address） + 段内偏移（Offset）`\n\n4. **段页式管理**：段页式管理机制结合了段式管理和页式管理的优点。简单来说，段页式管理机制就是把主存先分成若干个段，每个段又分成若干个页，也就是说 **段页式管理机制** 中段与段之间以及段的内部之间都是离散的。\n\n> 总的来说：页是物理单位，段是逻辑单位。分页可以有效的提高内存的利用率，分段可以更好的满足用户的需求。\n\n\n\n### 3、块表和多级页表\n\n1. 快表和多级页表，这两个内容解决了页表管理中很重要的两个问题。\n\n    1. 虚拟地址到物理地址的转换要快。\n    2. 解决当虚拟地址空间大的时候，页表也会很大的问题。\n\n2. **快表**\n\n   ​    为了提高虚拟机地址到物理地址的转换速度，操作系统在 **页表方案** 基础之上引入了 **快表** 来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器，其中的内容是页表的一部分或者全部内容。作为页表的 cache ，他的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时，CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。\n\n   ​    使用快表之后的地址转换流程是这样的：\n\n    1. 根据虚拟地址中的页号查快表。\n    2. 如果该页在快表中，直接从快表中读取相应的物理地址。\n    3. 如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中。\n    4. 当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。\n\n3. **多级页表**\n\n   ​    引入多级页表的目的主要是为了避免把全部页表一直放在内存中占用过多的空间，特别是那些根本不需要的页表就不要保留在内存中。\n\n   ​    多级页表属于时间换空间的经典场景。\n\n### 4、分页机制和分段机制的共同点和区别\n\n- **共同点**：\n- 分页机制和分段机制都是为了提高内存利用率，减少内存碎片化。\n\n- 页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。\n\n- **区别**：\n\n    - 页的大小是固定的，由操作系统决定，而段的大小不固定，取决于我们当前运行的程序。\n    - 分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。\n\n### 5、逻辑(虚拟)地址和物理地址\n\n- **逻辑(虚拟)地址**\n    - 由 CPU 在执行程序时生成的地址，是**进程 “看到” 的内存地址**，不直接对应物理内存硬件的实际位置。\n    - 进程独立性：每个进程有自己独立的逻辑地址空间，进程 A 的 0x1000 地址和进程 B 的 0x1000 地址毫无关联，避免进程间内存干扰。\n    - 非直接访问：逻辑地址无法直接用于访问物理内存，必须先转换为物理地址。\n- **物理地址**\n    - 计算机物理内存（如内存条）硬件本身的真实地址，是**内存芯片引脚能直接识别的地址**，对应内存单元的实际物理位置。\n    - 硬件唯一性：物理地址由内存硬件决定，整个系统中每个物理地址唯一，直接对应硬件单元。\n    - 直接访问性：只有物理地址能被内存控制器识别，用于读取 / 写入内存数据。\n\n### 6、CPU 寻址\n\n- **CPU 寻址**\n    - 现代处理器使用的是一种称为 **虚拟寻址** 的寻址方式，也就是 CPU 将虚拟地址翻译为物理地址，而完成这个转换工作的是 CPU 中包含的一个被称为 **内存管理单元（MMU）** 的硬件。\n    - 具体过程：**地址拆分**、**页表查询**、**地址拼接**、**内存访问**。\n\n### 7、为什么需要虚拟地址空间\n\n​\t\t先从没有虚拟地址空间的时候说起，没有虚拟地址空间的时候，**程序直接访问和操作的都是物理内存**。但是这样存在很大的问题。\n\n​\t\t1、用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易破坏系统，造成操作系统的崩溃。\n\n​\t\t2、想要同时运行多个程序特别困难，比如想同时运行一个微信和一个QQ音乐，微信运行时，为 1xxx 的地址赋值\n\n​\t\t\t\t后，QQ音乐也同样给内存 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖之前的值，导致微信程序的崩溃。\n\n​\t\t通过虚拟地址访问内存有以下优势：\n\n- 程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。\n- 程序可以使用一系列虚拟地址来访问大于可用物理地址内存的内存缓冲区，也就是当物理内存不够使用时，内存管理器会将物理内存页（通常大小 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。\n- 不同进程使用的虚拟地址彼此之间隔离。一个进程中的代码无法更改正在由另一个进程或操作系统使用的物理内存。\n\n## 四、虚拟内存\n\n### 1、什么是虚拟内存\n\n​\t\t在我们平时使用的电脑特别是 Windows 系统十分常见。很多时候，我们使用了很多占内存的软件，这些软件占用的内存可能已将远远超出了我们电脑本身具有的物理内存。这正是因为 **虚拟内存** 的存在，通过虚拟内存可以让程序拥有超过系统物理内存大小的可以用内存空间。另外，**虚拟内存为每个进程提供了一个一致的，私有的地址空间，他让每个进程产生了一种自己在独享主存的错觉**。这样更加有效的管理内存并减少出错。虚拟内存的重要意义在于：**它定义了一个连续的虚拟孔吉纳，并且把内存扩展到硬盘空间。**\n\n### 2、局部性原理\n\n​\t\t局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。也就是说，在某个较短的时间段内，程序执行局限于某一小部分，程序访问的存储空间也局限于某个区域。\n\n- **时间局部性**：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久之后该数据可能再次被访问。产生时间局部性的经典原因，是由于在程序中存在着大量的循环操作。\n- **空间局部性**：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量，数组，表等形式簇集储存的。\n\n### 3、虚拟存储器\n\n​    所谓的虚拟存储器，是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩展的一种存储器。\n\n\n\n​    一般具有三大特征：\n\n- **多次性**：是指一个作业中的程序和数据无需在作业运行时一次性的调入内存，而是被被允许分成多次调入内存允许。\n-  **对换性**：是指一个作业中的程序和数据无需在作业运行时一直常驻内存，而是允许他们在作业运行时换入和唤出\n- **虚拟性**：是指能够从逻辑上扩大容量，使用户看到的内存容量远大于实际内存容量。\n\n\n\n### 4、虚拟内存的技术实现\n\n​    **虚拟内存技术的实现，需要建立在离散分配内存管理方式的基础上。**虚拟内存的实现有一下三种方式：\n\n- **请求分页存储管理**：建立在分页系统之上，增加了请求分页功能和页面置换功能所形成的页式虚拟存储系统。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储器系统中，在作业开始运行之前，仅装入当前要执行的部分页面即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入主存，同时操作系统也可以将暂时不使用的页面置换到外存中。\n\n- **请求分段存储器管理**：建立在分段系统之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可；在执行过程中，可以使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已经满了，而又需装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。\n\n- **请求段页式存储管理**：\n\n  > 请求分页和分页存储系统的不同\n  >\n  > 请求分页存储管理建立在分页管理之上，根本区别就是是否将程序全部地址空间都装入主存。\n\n\n\n### 5、页面置换算法\n\n​    地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断。\n\n​    当发生缺页中断时，如果当前内存中没有空闲的页面，操作系统就必须在内存中选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法，我们可以把页面置换算法看成是淘汰页面的规则。\n\n- **OPT 页面置换算法（最佳页面置换算法）**：最佳页面置换算法所选择的被淘汰的页面将是以后永不使用的，或者是在很长在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。但是由于人们目前无法预知进程内存下的若干页面中那个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。\n- **FIFO 页面置换算法（先进先出页面置换算法）**：总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。\n- **LRU 页面置换算法（最近最久未使用页面置换算法）**：LRU 算法赋予每一个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当淘汰一个页面时，选择现有页面中 T 最大的，即最近最久未使用的页面予以淘汰。\n- **LFU 页面置换算法 （最少使用页面置换算法）**：该置换算法选择在之前时期使用最少的页面作为淘汰页。","source":"_posts/操作系统知识点.md","raw":"---\ntitle: 操作系统知识点\ntags:\n  - 操作系统\ndescription: |\n  文章缩略，支持 `Markdown` **文档格式**\npinned: 0\nlang: zh\ncategories:\n  - 操作系统\ntype: post\ndate: 2025-10-28 16:46:23\n---\n## 一、操作系统基础\n\n### 1、什么是操作系统\n\n​    操作系统（Operating System 简称 OS）本质上是一个运行在计算机上的软件程序，用于管理计算机硬件和软件资源。例如，运行在电脑上的所有应用程序都是通过操作系统来调用系统内存以及磁盘等硬件。\n\n\n\n### 2、操作系统的内核\n\n​    操作系统的内核时操作系统的核心部分，负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。内核时连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。\n\n\n\n### 3、用户态和系统态\n\n- 用户态：用户态运行的进程可以直接读取用户程序的数据\n- 系统态：可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制，包括内存、CPU 指令等\n\n\n\n### 4、系统调用\n\n​    运行的程序基本都是运行在用户态，如果需要调用操作系统提供的系统态级别的子功能，就需要切换到系统态来调用。也就是说，运行的用户程序中，凡是与系统态级别的资源有关的操作（如 文件管理，进程控制，内存管理等），都必须通过系统调用方式向操作系统提出服务，并由操作系统代为完成。\n\n​    系统调用大致分为一下几类：\n\n- 设备管理。完成设备的请求或释放，设备启动等功能。\n- 文件管理。完成文件的读、写、创建、删除等功能。\n- 进程管理。完成进程的创建、撤销、阻塞、唤醒等功能。\n- 进程通信。完成进程之间的消息传递或信号传递等。\n- 内存管理。完成内存的分配、回收、获取作业占用内存大小以及地址等。\n\n## 二、进程和线程\n\n### 1、进程和线程的区别\n\n- **进程**：操作系统进行**资源分配的基本单位**（如内存、CPU 时间片、文件句柄等），可理解为 “一个正在运行的程序实例”（例如打开的 Chrome 浏览器、一个 Java 程序），是一个独立的 “资源容器”。\n- **线程**：操作系统进行**任务调度的基本单位**，是进程内的 “最小执行单元”（例如 Chrome 的一个标签页渲染线程、Java 程序的`main`线程），必须依赖进程存在，无法独立运行。\n\n​    从 JVM 的角度看，一个进程可以有多个线程，多个线程共享进程的**堆**和**方法区**，但是每个线程都有自己的**程序计数器**、**虚拟机栈**、**本地方法栈**。线程是进程划分成的更小的运行单元，一个进程在其执行的过程中可以产生多个线程。线程和进程最大的不同在于，进程之间是相互独立的，而线程之间不一定，因为同一个进程中的线程极有可能相互影响。线程执行开销小，但是不利于资源的管理和保护，而进程正相反。\n\n\n\n### 2、进程有哪几种状态\n\n- **创建状态** ：进程正被创建。\n    - 引起进程创建原因：用户登录、作业调度、提供服务、应用请求 都会引起进程的创建。\n- **就绪状态** ：进程已处于准备运行状态，即 进程获得了除处理器以外的一切所需的资源，一旦得到处理器资源，即可运行。\n- **运行状态** ：进程正在处理器上运行。\n- **阻塞状态** ：进程正在等待某一事件而暂停运行，即使处理器处于空闲状态，该进程也不能运行，是进程主动提出\n    - 原因：向操作系统请求共享资源失败、等待某种操作的完成、新数据尚未、等待IO操作的结束。\n- **终止状态** ：进程终止运行。\n    - 原因：正常结束、异常结束、外界干预。\n\n补充：\n\n- **进程的挂起** ：当系统中出现引起进程挂起的事件时，OS 会利用挂起原语将指定的进程挂起，如果进程时就绪状态，则改为静止就绪状态，如果是阻塞状态，则改为静止阻塞，如果运行状态，则将其转向调度程序重新调度。\n- **进程的激活** ：当系统中出现激活进程的事件后，OS 会利用原语将指定的进程激活。\n\n\n\n### 3、进程间的通信方式\n\n- **管道通信**\n    - 匿名管道：用于父进程和子进程之间的通信。\n    - 有名管道：用于任意两个进程之间的通信。\n- **信号**：信号是一种比较复杂的通信方式，用于通知接收进程有某种事件发生。\n- **消息队列**：消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道不同的是消息队列存放在内核中，只有在内核重启或者显示地删除一个消息队列时，该消息才会被真正的删除。消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按照消息的类型读取。**消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。**\n- **信号量** ：信号量是一个计数器，常被作为一种**锁机制**，用于多进程对共享数据的访问，信号量主要作为进程间以及同一进程内不同线程间的同步手段。\n- **共享内存** ：共享内存可以使运行在同一台机器上的进程间的**通信最快**。使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存种数据的更新，这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。\n- **套接字** ：此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持TCP/IP的网络通信的基本操作单元，可以看作是不同主机之间的进程进行双向通信的端点，简单来说就是通信双方的一种约定，用套接字的相关函数来完成通信过程。\n\n\n\n### 4、线程间的同步方式\n\n​    线程同步是两个或多个共享资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步方式。\n\n- **互斥量** ：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。例如：Java 中的synchronized 关键字和各种Lock都是这种机制。\n\n- **信号量** ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。\n\n- **事件** ：通过通知操作（挂起和唤醒）的方式来保持多线程同步，还可以方便的实现多线程优先级得比较操作。\n\n\n\n### 5、进程的调度\n\n​    进程调度的任务主要有三，① 保存CPU现场信息 ② 按照某种算法选取进程 ③ 把 CPU 分配给该进程\n\n​    进程调度算法一般有四种：\n\n- **先到先服务** ： 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某种事件而被阻塞放弃占用CPU资源时再重新调度。\n\n- **短作业优先** ：从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某种事件而被阻塞放弃占用CPU资源时再重新调度。\n    - 缺点：必须预先知道作业的运行时间，但是这个时间很难估计准确，如果偏短，系统可能会提前终止进程。\n    - 缺点：对长作业非常不利，周转时间会明显增长。\n    - 缺点：完全没有考虑作业的紧迫程度。\n\n- **时间片轮转** ：时间片轮转调度是一种古老，最简单，最公平且使用最广的调度算法，每个进程被分配一个时间段，称作它的时间片，也就是该进程允许运行的时间。\n\n- **多级反馈队列** ：**短进程优先** 仅照顾了短进程，而忽略了长进程。而多级返回调度算法既能使高优先级的作业得到响应，又能响应短作业进程迅速完成，因此是被公认的最好的调度算法，UNIX 采用的就是这种调度算法。\n    - 机制：① 设置多个就绪队列\n    - 机制：② 每个队列都采用先来先服务调度算法\n    - 机制：③ 按队列优先级调度\n\n- **优先级调度** ：为每个进程分配优先级，首先执行具有高优先级的进程，以此类推，具有相同优先级的进程以先进先出的顺序执行。可以根据内存要求，时间要求或者任何其他资源的要求来确定优先级。\n\n\n\n### 6、什么是死锁\n\n​    死锁描述的是这样一种情况，多个进程/线程同时被阻塞，他们中的一个或全部都在等待某个资源被释放，但他们都会因为不能不能获得自己的资源去继续运行而无法释放自己当下占有的资源，并且一直处于这样的僵持状态，而形成死锁。\n\n\n\n### 7、产生死锁的四个必要条件\n\n- **互斥条件** ：资源必须处于非共享模式，即：一次只有一个进程可以使用。如果另一个进程申请该资源，那么必须等待直到该资源被释放为止。\n- **请求和保持条件** ：一个进程至少占有了一个资源，并等待另一个资源，而该资源被其它线程所占有。\n- **不可抢占条件** ： 资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。\n- **循环等待条件** ：一组进程`{P0,P1,...,Pn}` `P0` 等待的资源被 `P1`占有，`P1` 等待的资源被`P2` 占有，最后 `Pn` 等待的资源被`P1` 占有，形成循环等待的情况。\n\n> 这四个条件是产生死锁的 **必要条件** ，也就是说只要系统发生死锁，这些条件必然成立，而只要让上述条件之一不满足，就不会产生死锁。\n\n\n\n### 8、解决死锁的方法\n\n#### 1、死锁的预防\n\n​\t\t**预防死锁** ：是采用某种策略，**限制并发进程对资源的请求**，从而使得死锁的必要条件在系统执行的任何时间都不满足。\n\n​\t\t只要破坏四个必要条件中的一个就能够预防死锁的发生。\n\n​    \t破坏第一个条件 **互斥条件** ：使得资源可以同时被访问，这种是最简单的方法，磁盘可以用这种方法管理，但是系统中的很多资源 **往往是不能被同时访问的** ，所以这种做法在大多数场合是行不通的。\n\n​    \t破坏第三个条件 **不可抢占条件** ：也就是说，可以采用 **剥夺式调度算法** ，但是，这种调度算法实现起来比较复杂，并且一个资源在被使用一段时间后被抢占，可能导致进程前一段时间的工作失效，还可能因为反复申请和释放资源导致进程的执行被无限期的推迟，既增加了系统开销，也降低了吞吐量。\n\n​    \t所以，一般比较实用的预防死锁的方法是，通过破坏第二个条件和第四个条件。\n\n1. **静态分配策略**\n\n​    静态分配策略就是指一个进程必须在执行前就申请到它所需要的全部资源，否则直到它所要的资源得到满足后才开始运行。进程要么占有所有资源开始运行，要么不占有资源，不会出现一些资源等待一些资源的情况。\n\n​    静态分配策略逻辑简单，实现也很容易，但这种策略 **严重地降低了资源利用率**，因为在每个进程所占有的资源中，有一些资源是在比较靠后的执行时间里才用的，甚至有些资源是在额外的情况下才使用的，这样就可能造成一个进程占有了一些 **几乎不用的资源而是使用其他需要该资源的进程产生等待** 的情况。\n\n1. **2、层次分配策略**\n\n​    层次分配策略破坏了产生死锁的第四个条件，在层次分配策略下，所有的资源被分成了多个层次，一个进程得到某一次的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源，这种策略，是不能可能出现循环等待链的，因为那样的话，就出现了已经申请了较高层的资源，反而去申请了较低层的资源，不符合层次分配策略。\n\n#### 2、避免死锁\n\n​\t\t**避免死锁** ：是系统在分配资源时，根据资源的使用情况**提前做出预测**，从而**避免死锁的发生**\n\n​\t\t死锁的避免的角度是允许系统中**同时存在四个必要条件**，只要掌握并发进程中与每个进程有关的资源动态申请情况，做出 **明智合理的选择**，仍可以避免死锁，因为四大条件仅仅是产生死锁的必要条件。\n\n​    可以将系统分为 **安全状态** 和 **不安全状态** ，每当为申请者分配资源前，先检测系统状态，如果把系统资源分配给申请者会产生死锁，则拒绝分配，否则接受申请，并为它分配资源。\n\n> 安全状态，如果操作系统能够保证所有进程在有限时间内得到需要的全部资源，否则是不安全状态\n\n​    \t避免死锁的算法是，**银行家算法** ，也就是：当一个线程申请使用资源时，**银行家算法** 通过 **试探** 分配给该进程资源，然后通过 **安全性算法** 分析分配后系统是否处于安全状态，若处于不安全状态，则试探分配作废，让该进程继续等待，若能够进入安全状态，则就**真的分配资源给该进程**\n\n#### 3、死锁的检测\n\n​\t\t**检测死锁** ：是指系统设有**专门的机构**，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。\n\n​\t\t这种方法对资源的分配不加以限制，也不采取死锁避免的措施，但系统会**定时地运行一个 “死锁检测” 的程序**，判断系统内是否出现死锁，如果检测到系统发生了死锁，再采取措施去解除它。\n\n​\t\t可以利用 **进程-资源分配图** 是否又环路来检测死锁，但是，有环路不一定死锁。\n\n\n\n#### 4、死锁的解除\n\n​\t\t**解除死锁** ：是与检测相配套的一种措施，用于**将进程从死锁状态下解脱出来**\n\n​\t\t当死锁检测程序检测到存在死锁发生时，应设法让其解除，让系统从死锁中恢复过来。\n\n- **立即结束所有进程的执行，重新启动操作系统**，方法简单，但是之前的工作全部作废，损失很大。\n- **撤销涉及死锁的所有进程，解除死锁后继续运行**，彻底打破死锁的循环等待条件，付出的代价也较大，例如一个进程计算了很长时间，由于被撤销，部分结果也被消除，重新执行就要再次计算。\n- **逐个撤销涉及死锁的进程，回收资源直到死锁解除**\n- **抢占资源**，从涉及死锁的一个或几个进程中抢占资源，再把夺到的资源分配出去，知道死锁解除。\n\n## 三、操作系统内存管理基础\n\n### 1、内存管理介绍\n\n​\t\t操作系统的内存管理主要负责内存的分配和回收，另外地址转换也就是将逻辑地址转换为相应的物理地址等功能也是操作系统内存管理的事情。\n\n\n\n### 2、内存管理机制与方式\n\n​\t\t简单的分为 **连续分配管理方式** 和 **非连续分配管理方式** 这两种。连续分配管理方式是指为一个用户程序分配一段连续的内存空间，常见的如 **块式管理**。同样的，非连续分配管理方式，允许一个程序使用的内存分布在离散或者说不相邻的内存空间中，常见的有 **页式管理** 、 **段式管理**、**段页式管理**。\n\n1. **块式管理**：远古时代的计算机操作系统的内存管理方式。将内存分为几个固定大小的块，每个块只包含一个进程。如果程序需要内存的话，操作系统就分配给它一个块，如果程序运行只需要很小的空间的话，分配的这个块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。\n\n2. **页式管理**：把主存分为大小相等且固定的一页一页的形式，页比较小，相比于块式管理，划分粒度更小，提高了内存的利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。\n\n   地址转化：\n\n   `逻辑地址 = 页号（Page Number） + 页内偏移（Offset）`\n\n   `物理地址 = 页框号（Frame Number） + 页内偏移（Offset）`\n\n3. **段式管理**：页式管理虽然提高了内存利用率，但是页式管理中的页并无任何实际的意义。段式管理把主存分为一段一段的，段是有实际的意义的，每个段顶一了一组逻辑信息，例如，有主程序段、子程序段、数据段、栈段等。段式管理通过段表对应的逻辑地址和物理地址。\n\n   地址转换：\n\n   `逻辑地址 = 段号（Segment Number） + 段内偏移（Offset）`\n\n   `物理地址 = 段基址（Base Address） + 段内偏移（Offset）`\n\n4. **段页式管理**：段页式管理机制结合了段式管理和页式管理的优点。简单来说，段页式管理机制就是把主存先分成若干个段，每个段又分成若干个页，也就是说 **段页式管理机制** 中段与段之间以及段的内部之间都是离散的。\n\n> 总的来说：页是物理单位，段是逻辑单位。分页可以有效的提高内存的利用率，分段可以更好的满足用户的需求。\n\n\n\n### 3、块表和多级页表\n\n1. 快表和多级页表，这两个内容解决了页表管理中很重要的两个问题。\n\n    1. 虚拟地址到物理地址的转换要快。\n    2. 解决当虚拟地址空间大的时候，页表也会很大的问题。\n\n2. **快表**\n\n   ​    为了提高虚拟机地址到物理地址的转换速度，操作系统在 **页表方案** 基础之上引入了 **快表** 来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器，其中的内容是页表的一部分或者全部内容。作为页表的 cache ，他的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时，CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。\n\n   ​    使用快表之后的地址转换流程是这样的：\n\n    1. 根据虚拟地址中的页号查快表。\n    2. 如果该页在快表中，直接从快表中读取相应的物理地址。\n    3. 如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中。\n    4. 当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。\n\n3. **多级页表**\n\n   ​    引入多级页表的目的主要是为了避免把全部页表一直放在内存中占用过多的空间，特别是那些根本不需要的页表就不要保留在内存中。\n\n   ​    多级页表属于时间换空间的经典场景。\n\n### 4、分页机制和分段机制的共同点和区别\n\n- **共同点**：\n- 分页机制和分段机制都是为了提高内存利用率，减少内存碎片化。\n\n- 页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。\n\n- **区别**：\n\n    - 页的大小是固定的，由操作系统决定，而段的大小不固定，取决于我们当前运行的程序。\n    - 分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。\n\n### 5、逻辑(虚拟)地址和物理地址\n\n- **逻辑(虚拟)地址**\n    - 由 CPU 在执行程序时生成的地址，是**进程 “看到” 的内存地址**，不直接对应物理内存硬件的实际位置。\n    - 进程独立性：每个进程有自己独立的逻辑地址空间，进程 A 的 0x1000 地址和进程 B 的 0x1000 地址毫无关联，避免进程间内存干扰。\n    - 非直接访问：逻辑地址无法直接用于访问物理内存，必须先转换为物理地址。\n- **物理地址**\n    - 计算机物理内存（如内存条）硬件本身的真实地址，是**内存芯片引脚能直接识别的地址**，对应内存单元的实际物理位置。\n    - 硬件唯一性：物理地址由内存硬件决定，整个系统中每个物理地址唯一，直接对应硬件单元。\n    - 直接访问性：只有物理地址能被内存控制器识别，用于读取 / 写入内存数据。\n\n### 6、CPU 寻址\n\n- **CPU 寻址**\n    - 现代处理器使用的是一种称为 **虚拟寻址** 的寻址方式，也就是 CPU 将虚拟地址翻译为物理地址，而完成这个转换工作的是 CPU 中包含的一个被称为 **内存管理单元（MMU）** 的硬件。\n    - 具体过程：**地址拆分**、**页表查询**、**地址拼接**、**内存访问**。\n\n### 7、为什么需要虚拟地址空间\n\n​\t\t先从没有虚拟地址空间的时候说起，没有虚拟地址空间的时候，**程序直接访问和操作的都是物理内存**。但是这样存在很大的问题。\n\n​\t\t1、用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易破坏系统，造成操作系统的崩溃。\n\n​\t\t2、想要同时运行多个程序特别困难，比如想同时运行一个微信和一个QQ音乐，微信运行时，为 1xxx 的地址赋值\n\n​\t\t\t\t后，QQ音乐也同样给内存 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖之前的值，导致微信程序的崩溃。\n\n​\t\t通过虚拟地址访问内存有以下优势：\n\n- 程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。\n- 程序可以使用一系列虚拟地址来访问大于可用物理地址内存的内存缓冲区，也就是当物理内存不够使用时，内存管理器会将物理内存页（通常大小 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。\n- 不同进程使用的虚拟地址彼此之间隔离。一个进程中的代码无法更改正在由另一个进程或操作系统使用的物理内存。\n\n## 四、虚拟内存\n\n### 1、什么是虚拟内存\n\n​\t\t在我们平时使用的电脑特别是 Windows 系统十分常见。很多时候，我们使用了很多占内存的软件，这些软件占用的内存可能已将远远超出了我们电脑本身具有的物理内存。这正是因为 **虚拟内存** 的存在，通过虚拟内存可以让程序拥有超过系统物理内存大小的可以用内存空间。另外，**虚拟内存为每个进程提供了一个一致的，私有的地址空间，他让每个进程产生了一种自己在独享主存的错觉**。这样更加有效的管理内存并减少出错。虚拟内存的重要意义在于：**它定义了一个连续的虚拟孔吉纳，并且把内存扩展到硬盘空间。**\n\n### 2、局部性原理\n\n​\t\t局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。也就是说，在某个较短的时间段内，程序执行局限于某一小部分，程序访问的存储空间也局限于某个区域。\n\n- **时间局部性**：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久之后该数据可能再次被访问。产生时间局部性的经典原因，是由于在程序中存在着大量的循环操作。\n- **空间局部性**：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量，数组，表等形式簇集储存的。\n\n### 3、虚拟存储器\n\n​    所谓的虚拟存储器，是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩展的一种存储器。\n\n\n\n​    一般具有三大特征：\n\n- **多次性**：是指一个作业中的程序和数据无需在作业运行时一次性的调入内存，而是被被允许分成多次调入内存允许。\n-  **对换性**：是指一个作业中的程序和数据无需在作业运行时一直常驻内存，而是允许他们在作业运行时换入和唤出\n- **虚拟性**：是指能够从逻辑上扩大容量，使用户看到的内存容量远大于实际内存容量。\n\n\n\n### 4、虚拟内存的技术实现\n\n​    **虚拟内存技术的实现，需要建立在离散分配内存管理方式的基础上。**虚拟内存的实现有一下三种方式：\n\n- **请求分页存储管理**：建立在分页系统之上，增加了请求分页功能和页面置换功能所形成的页式虚拟存储系统。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储器系统中，在作业开始运行之前，仅装入当前要执行的部分页面即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入主存，同时操作系统也可以将暂时不使用的页面置换到外存中。\n\n- **请求分段存储器管理**：建立在分段系统之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可；在执行过程中，可以使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已经满了，而又需装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。\n\n- **请求段页式存储管理**：\n\n  > 请求分页和分页存储系统的不同\n  >\n  > 请求分页存储管理建立在分页管理之上，根本区别就是是否将程序全部地址空间都装入主存。\n\n\n\n### 5、页面置换算法\n\n​    地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断。\n\n​    当发生缺页中断时，如果当前内存中没有空闲的页面，操作系统就必须在内存中选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法，我们可以把页面置换算法看成是淘汰页面的规则。\n\n- **OPT 页面置换算法（最佳页面置换算法）**：最佳页面置换算法所选择的被淘汰的页面将是以后永不使用的，或者是在很长在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。但是由于人们目前无法预知进程内存下的若干页面中那个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。\n- **FIFO 页面置换算法（先进先出页面置换算法）**：总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。\n- **LRU 页面置换算法（最近最久未使用页面置换算法）**：LRU 算法赋予每一个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当淘汰一个页面时，选择现有页面中 T 最大的，即最近最久未使用的页面予以淘汰。\n- **LFU 页面置换算法 （最少使用页面置换算法）**：该置换算法选择在之前时期使用最少的页面作为淘汰页。","slug":"操作系统知识点","published":1,"updated":"2025-10-28T08:47:10.670Z","comments":1,"layout":"post","photos":[],"_id":"cuidXhJRxv5O8qMIj2VNh3y6O","content":"<h2 id=\"一、操作系统基础\"><a href=\"#一、操作系统基础\" class=\"headerlink\" title=\"一、操作系统基础\"></a>一、操作系统基础</h2><h3 id=\"1、什么是操作系统\"><a href=\"#1、什么是操作系统\" class=\"headerlink\" title=\"1、什么是操作系统\"></a>1、什么是操作系统</h3><p>​    操作系统（Operating System 简称 OS）本质上是一个运行在计算机上的软件程序，用于管理计算机硬件和软件资源。例如，运行在电脑上的所有应用程序都是通过操作系统来调用系统内存以及磁盘等硬件。</p>\n<h3 id=\"2、操作系统的内核\"><a href=\"#2、操作系统的内核\" class=\"headerlink\" title=\"2、操作系统的内核\"></a>2、操作系统的内核</h3><p>​    操作系统的内核时操作系统的核心部分，负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。内核时连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。</p>\n<h3 id=\"3、用户态和系统态\"><a href=\"#3、用户态和系统态\" class=\"headerlink\" title=\"3、用户态和系统态\"></a>3、用户态和系统态</h3><ul>\n<li>用户态：用户态运行的进程可以直接读取用户程序的数据</li>\n<li>系统态：可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制，包括内存、CPU 指令等</li>\n</ul>\n<h3 id=\"4、系统调用\"><a href=\"#4、系统调用\" class=\"headerlink\" title=\"4、系统调用\"></a>4、系统调用</h3><p>​    运行的程序基本都是运行在用户态，如果需要调用操作系统提供的系统态级别的子功能，就需要切换到系统态来调用。也就是说，运行的用户程序中，凡是与系统态级别的资源有关的操作（如 文件管理，进程控制，内存管理等），都必须通过系统调用方式向操作系统提出服务，并由操作系统代为完成。</p>\n<p>​    系统调用大致分为一下几类：</p>\n<ul>\n<li>设备管理。完成设备的请求或释放，设备启动等功能。</li>\n<li>文件管理。完成文件的读、写、创建、删除等功能。</li>\n<li>进程管理。完成进程的创建、撤销、阻塞、唤醒等功能。</li>\n<li>进程通信。完成进程之间的消息传递或信号传递等。</li>\n<li>内存管理。完成内存的分配、回收、获取作业占用内存大小以及地址等。</li>\n</ul>\n<h2 id=\"二、进程和线程\"><a href=\"#二、进程和线程\" class=\"headerlink\" title=\"二、进程和线程\"></a>二、进程和线程</h2><h3 id=\"1、进程和线程的区别\"><a href=\"#1、进程和线程的区别\" class=\"headerlink\" title=\"1、进程和线程的区别\"></a>1、进程和线程的区别</h3><ul>\n<li><strong>进程</strong>：操作系统进行<strong>资源分配的基本单位</strong>（如内存、CPU 时间片、文件句柄等），可理解为 “一个正在运行的程序实例”（例如打开的 Chrome 浏览器、一个 Java 程序），是一个独立的 “资源容器”。</li>\n<li><strong>线程</strong>：操作系统进行<strong>任务调度的基本单位</strong>，是进程内的 “最小执行单元”（例如 Chrome 的一个标签页渲染线程、Java 程序的<code>main</code>线程），必须依赖进程存在，无法独立运行。</li>\n</ul>\n<p>​    从 JVM 的角度看，一个进程可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>，但是每个线程都有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>、<strong>本地方法栈</strong>。线程是进程划分成的更小的运行单元，一个进程在其执行的过程中可以产生多个线程。线程和进程最大的不同在于，进程之间是相互独立的，而线程之间不一定，因为同一个进程中的线程极有可能相互影响。线程执行开销小，但是不利于资源的管理和保护，而进程正相反。</p>\n<h3 id=\"2、进程有哪几种状态\"><a href=\"#2、进程有哪几种状态\" class=\"headerlink\" title=\"2、进程有哪几种状态\"></a>2、进程有哪几种状态</h3><ul>\n<li><strong>创建状态</strong> ：进程正被创建。<ul>\n<li>引起进程创建原因：用户登录、作业调度、提供服务、应用请求 都会引起进程的创建。</li>\n</ul>\n</li>\n<li><strong>就绪状态</strong> ：进程已处于准备运行状态，即 进程获得了除处理器以外的一切所需的资源，一旦得到处理器资源，即可运行。</li>\n<li><strong>运行状态</strong> ：进程正在处理器上运行。</li>\n<li><strong>阻塞状态</strong> ：进程正在等待某一事件而暂停运行，即使处理器处于空闲状态，该进程也不能运行，是进程主动提出<ul>\n<li>原因：向操作系统请求共享资源失败、等待某种操作的完成、新数据尚未、等待IO操作的结束。</li>\n</ul>\n</li>\n<li><strong>终止状态</strong> ：进程终止运行。<ul>\n<li>原因：正常结束、异常结束、外界干预。</li>\n</ul>\n</li>\n</ul>\n<p>补充：</p>\n<ul>\n<li><strong>进程的挂起</strong> ：当系统中出现引起进程挂起的事件时，OS 会利用挂起原语将指定的进程挂起，如果进程时就绪状态，则改为静止就绪状态，如果是阻塞状态，则改为静止阻塞，如果运行状态，则将其转向调度程序重新调度。</li>\n<li><strong>进程的激活</strong> ：当系统中出现激活进程的事件后，OS 会利用原语将指定的进程激活。</li>\n</ul>\n<h3 id=\"3、进程间的通信方式\"><a href=\"#3、进程间的通信方式\" class=\"headerlink\" title=\"3、进程间的通信方式\"></a>3、进程间的通信方式</h3><ul>\n<li><strong>管道通信</strong><ul>\n<li>匿名管道：用于父进程和子进程之间的通信。</li>\n<li>有名管道：用于任意两个进程之间的通信。</li>\n</ul>\n</li>\n<li><strong>信号</strong>：信号是一种比较复杂的通信方式，用于通知接收进程有某种事件发生。</li>\n<li><strong>消息队列</strong>：消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道不同的是消息队列存放在内核中，只有在内核重启或者显示地删除一个消息队列时，该消息才会被真正的删除。消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按照消息的类型读取。<strong>消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</strong></li>\n<li><strong>信号量</strong> ：信号量是一个计数器，常被作为一种<strong>锁机制</strong>，用于多进程对共享数据的访问，信号量主要作为进程间以及同一进程内不同线程间的同步手段。</li>\n<li><strong>共享内存</strong> ：共享内存可以使运行在同一台机器上的进程间的<strong>通信最快</strong>。使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存种数据的更新，这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。</li>\n<li><strong>套接字</strong> ：此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持TCP&#x2F;IP的网络通信的基本操作单元，可以看作是不同主机之间的进程进行双向通信的端点，简单来说就是通信双方的一种约定，用套接字的相关函数来完成通信过程。</li>\n</ul>\n<h3 id=\"4、线程间的同步方式\"><a href=\"#4、线程间的同步方式\" class=\"headerlink\" title=\"4、线程间的同步方式\"></a>4、线程间的同步方式</h3><p>​    线程同步是两个或多个共享资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步方式。</p>\n<ul>\n<li><p><strong>互斥量</strong> ：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。例如：Java 中的synchronized 关键字和各种Lock都是这种机制。</p>\n</li>\n<li><p><strong>信号量</strong> ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</p>\n</li>\n<li><p><strong>事件</strong> ：通过通知操作（挂起和唤醒）的方式来保持多线程同步，还可以方便的实现多线程优先级得比较操作。</p>\n</li>\n</ul>\n<h3 id=\"5、进程的调度\"><a href=\"#5、进程的调度\" class=\"headerlink\" title=\"5、进程的调度\"></a>5、进程的调度</h3><p>​    进程调度的任务主要有三，① 保存CPU现场信息 ② 按照某种算法选取进程 ③ 把 CPU 分配给该进程</p>\n<p>​    进程调度算法一般有四种：</p>\n<ul>\n<li><p><strong>先到先服务</strong> ： 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某种事件而被阻塞放弃占用CPU资源时再重新调度。</p>\n</li>\n<li><p><strong>短作业优先</strong> ：从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某种事件而被阻塞放弃占用CPU资源时再重新调度。</p>\n<ul>\n<li>缺点：必须预先知道作业的运行时间，但是这个时间很难估计准确，如果偏短，系统可能会提前终止进程。</li>\n<li>缺点：对长作业非常不利，周转时间会明显增长。</li>\n<li>缺点：完全没有考虑作业的紧迫程度。</li>\n</ul>\n</li>\n<li><p><strong>时间片轮转</strong> ：时间片轮转调度是一种古老，最简单，最公平且使用最广的调度算法，每个进程被分配一个时间段，称作它的时间片，也就是该进程允许运行的时间。</p>\n</li>\n<li><p><strong>多级反馈队列</strong> ：<strong>短进程优先</strong> 仅照顾了短进程，而忽略了长进程。而多级返回调度算法既能使高优先级的作业得到响应，又能响应短作业进程迅速完成，因此是被公认的最好的调度算法，UNIX 采用的就是这种调度算法。</p>\n<ul>\n<li>机制：① 设置多个就绪队列</li>\n<li>机制：② 每个队列都采用先来先服务调度算法</li>\n<li>机制：③ 按队列优先级调度</li>\n</ul>\n</li>\n<li><p><strong>优先级调度</strong> ：为每个进程分配优先级，首先执行具有高优先级的进程，以此类推，具有相同优先级的进程以先进先出的顺序执行。可以根据内存要求，时间要求或者任何其他资源的要求来确定优先级。</p>\n</li>\n</ul>\n<h3 id=\"6、什么是死锁\"><a href=\"#6、什么是死锁\" class=\"headerlink\" title=\"6、什么是死锁\"></a>6、什么是死锁</h3><p>​    死锁描述的是这样一种情况，多个进程&#x2F;线程同时被阻塞，他们中的一个或全部都在等待某个资源被释放，但他们都会因为不能不能获得自己的资源去继续运行而无法释放自己当下占有的资源，并且一直处于这样的僵持状态，而形成死锁。</p>\n<h3 id=\"7、产生死锁的四个必要条件\"><a href=\"#7、产生死锁的四个必要条件\" class=\"headerlink\" title=\"7、产生死锁的四个必要条件\"></a>7、产生死锁的四个必要条件</h3><ul>\n<li><strong>互斥条件</strong> ：资源必须处于非共享模式，即：一次只有一个进程可以使用。如果另一个进程申请该资源，那么必须等待直到该资源被释放为止。</li>\n<li><strong>请求和保持条件</strong> ：一个进程至少占有了一个资源，并等待另一个资源，而该资源被其它线程所占有。</li>\n<li><strong>不可抢占条件</strong> ： 资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。</li>\n<li><strong>循环等待条件</strong> ：一组进程<code>{P0,P1,...,Pn}</code> <code>P0</code> 等待的资源被 <code>P1</code>占有，<code>P1</code> 等待的资源被<code>P2</code> 占有，最后 <code>Pn</code> 等待的资源被<code>P1</code> 占有，形成循环等待的情况。</li>\n</ul>\n<blockquote>\n<p>这四个条件是产生死锁的 <strong>必要条件</strong> ，也就是说只要系统发生死锁，这些条件必然成立，而只要让上述条件之一不满足，就不会产生死锁。</p>\n</blockquote>\n<h3 id=\"8、解决死锁的方法\"><a href=\"#8、解决死锁的方法\" class=\"headerlink\" title=\"8、解决死锁的方法\"></a>8、解决死锁的方法</h3><h4 id=\"1、死锁的预防\"><a href=\"#1、死锁的预防\" class=\"headerlink\" title=\"1、死锁的预防\"></a>1、死锁的预防</h4><p>​\t\t<strong>预防死锁</strong> ：是采用某种策略，<strong>限制并发进程对资源的请求</strong>，从而使得死锁的必要条件在系统执行的任何时间都不满足。</p>\n<p>​\t\t只要破坏四个必要条件中的一个就能够预防死锁的发生。</p>\n<p>​    \t破坏第一个条件 <strong>互斥条件</strong> ：使得资源可以同时被访问，这种是最简单的方法，磁盘可以用这种方法管理，但是系统中的很多资源 <strong>往往是不能被同时访问的</strong> ，所以这种做法在大多数场合是行不通的。</p>\n<p>​    \t破坏第三个条件 <strong>不可抢占条件</strong> ：也就是说，可以采用 <strong>剥夺式调度算法</strong> ，但是，这种调度算法实现起来比较复杂，并且一个资源在被使用一段时间后被抢占，可能导致进程前一段时间的工作失效，还可能因为反复申请和释放资源导致进程的执行被无限期的推迟，既增加了系统开销，也降低了吞吐量。</p>\n<p>​    \t所以，一般比较实用的预防死锁的方法是，通过破坏第二个条件和第四个条件。</p>\n<ol>\n<li><strong>静态分配策略</strong></li>\n</ol>\n<p>​    静态分配策略就是指一个进程必须在执行前就申请到它所需要的全部资源，否则直到它所要的资源得到满足后才开始运行。进程要么占有所有资源开始运行，要么不占有资源，不会出现一些资源等待一些资源的情况。</p>\n<p>​    静态分配策略逻辑简单，实现也很容易，但这种策略 <strong>严重地降低了资源利用率</strong>，因为在每个进程所占有的资源中，有一些资源是在比较靠后的执行时间里才用的，甚至有些资源是在额外的情况下才使用的，这样就可能造成一个进程占有了一些 <strong>几乎不用的资源而是使用其他需要该资源的进程产生等待</strong> 的情况。</p>\n<ol>\n<li><strong>2、层次分配策略</strong></li>\n</ol>\n<p>​    层次分配策略破坏了产生死锁的第四个条件，在层次分配策略下，所有的资源被分成了多个层次，一个进程得到某一次的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源，这种策略，是不能可能出现循环等待链的，因为那样的话，就出现了已经申请了较高层的资源，反而去申请了较低层的资源，不符合层次分配策略。</p>\n<h4 id=\"2、避免死锁\"><a href=\"#2、避免死锁\" class=\"headerlink\" title=\"2、避免死锁\"></a>2、避免死锁</h4><p>​\t\t<strong>避免死锁</strong> ：是系统在分配资源时，根据资源的使用情况<strong>提前做出预测</strong>，从而<strong>避免死锁的发生</strong></p>\n<p>​\t\t死锁的避免的角度是允许系统中<strong>同时存在四个必要条件</strong>，只要掌握并发进程中与每个进程有关的资源动态申请情况，做出 <strong>明智合理的选择</strong>，仍可以避免死锁，因为四大条件仅仅是产生死锁的必要条件。</p>\n<p>​    可以将系统分为 <strong>安全状态</strong> 和 <strong>不安全状态</strong> ，每当为申请者分配资源前，先检测系统状态，如果把系统资源分配给申请者会产生死锁，则拒绝分配，否则接受申请，并为它分配资源。</p>\n<blockquote>\n<p>安全状态，如果操作系统能够保证所有进程在有限时间内得到需要的全部资源，否则是不安全状态</p>\n</blockquote>\n<p>​    \t避免死锁的算法是，<strong>银行家算法</strong> ，也就是：当一个线程申请使用资源时，<strong>银行家算法</strong> 通过 <strong>试探</strong> 分配给该进程资源，然后通过 <strong>安全性算法</strong> 分析分配后系统是否处于安全状态，若处于不安全状态，则试探分配作废，让该进程继续等待，若能够进入安全状态，则就<strong>真的分配资源给该进程</strong></p>\n<h4 id=\"3、死锁的检测\"><a href=\"#3、死锁的检测\" class=\"headerlink\" title=\"3、死锁的检测\"></a>3、死锁的检测</h4><p>​\t\t<strong>检测死锁</strong> ：是指系统设有<strong>专门的机构</strong>，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。</p>\n<p>​\t\t这种方法对资源的分配不加以限制，也不采取死锁避免的措施，但系统会<strong>定时地运行一个 “死锁检测” 的程序</strong>，判断系统内是否出现死锁，如果检测到系统发生了死锁，再采取措施去解除它。</p>\n<p>​\t\t可以利用 <strong>进程-资源分配图</strong> 是否又环路来检测死锁，但是，有环路不一定死锁。</p>\n<h4 id=\"4、死锁的解除\"><a href=\"#4、死锁的解除\" class=\"headerlink\" title=\"4、死锁的解除\"></a>4、死锁的解除</h4><p>​\t\t<strong>解除死锁</strong> ：是与检测相配套的一种措施，用于<strong>将进程从死锁状态下解脱出来</strong></p>\n<p>​\t\t当死锁检测程序检测到存在死锁发生时，应设法让其解除，让系统从死锁中恢复过来。</p>\n<ul>\n<li><strong>立即结束所有进程的执行，重新启动操作系统</strong>，方法简单，但是之前的工作全部作废，损失很大。</li>\n<li><strong>撤销涉及死锁的所有进程，解除死锁后继续运行</strong>，彻底打破死锁的循环等待条件，付出的代价也较大，例如一个进程计算了很长时间，由于被撤销，部分结果也被消除，重新执行就要再次计算。</li>\n<li><strong>逐个撤销涉及死锁的进程，回收资源直到死锁解除</strong></li>\n<li><strong>抢占资源</strong>，从涉及死锁的一个或几个进程中抢占资源，再把夺到的资源分配出去，知道死锁解除。</li>\n</ul>\n<h2 id=\"三、操作系统内存管理基础\"><a href=\"#三、操作系统内存管理基础\" class=\"headerlink\" title=\"三、操作系统内存管理基础\"></a>三、操作系统内存管理基础</h2><h3 id=\"1、内存管理介绍\"><a href=\"#1、内存管理介绍\" class=\"headerlink\" title=\"1、内存管理介绍\"></a>1、内存管理介绍</h3><p>​\t\t操作系统的内存管理主要负责内存的分配和回收，另外地址转换也就是将逻辑地址转换为相应的物理地址等功能也是操作系统内存管理的事情。</p>\n<h3 id=\"2、内存管理机制与方式\"><a href=\"#2、内存管理机制与方式\" class=\"headerlink\" title=\"2、内存管理机制与方式\"></a>2、内存管理机制与方式</h3><p>​\t\t简单的分为 <strong>连续分配管理方式</strong> 和 <strong>非连续分配管理方式</strong> 这两种。连续分配管理方式是指为一个用户程序分配一段连续的内存空间，常见的如 <strong>块式管理</strong>。同样的，非连续分配管理方式，允许一个程序使用的内存分布在离散或者说不相邻的内存空间中，常见的有 <strong>页式管理</strong> 、 <strong>段式管理</strong>、<strong>段页式管理</strong>。</p>\n<ol>\n<li><p><strong>块式管理</strong>：远古时代的计算机操作系统的内存管理方式。将内存分为几个固定大小的块，每个块只包含一个进程。如果程序需要内存的话，操作系统就分配给它一个块，如果程序运行只需要很小的空间的话，分配的这个块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。</p>\n</li>\n<li><p><strong>页式管理</strong>：把主存分为大小相等且固定的一页一页的形式，页比较小，相比于块式管理，划分粒度更小，提高了内存的利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。</p>\n<p>地址转化：</p>\n<p><code>逻辑地址 = 页号（Page Number） + 页内偏移（Offset）</code></p>\n<p><code>物理地址 = 页框号（Frame Number） + 页内偏移（Offset）</code></p>\n</li>\n<li><p><strong>段式管理</strong>：页式管理虽然提高了内存利用率，但是页式管理中的页并无任何实际的意义。段式管理把主存分为一段一段的，段是有实际的意义的，每个段顶一了一组逻辑信息，例如，有主程序段、子程序段、数据段、栈段等。段式管理通过段表对应的逻辑地址和物理地址。</p>\n<p>地址转换：</p>\n<p><code>逻辑地址 = 段号（Segment Number） + 段内偏移（Offset）</code></p>\n<p><code>物理地址 = 段基址（Base Address） + 段内偏移（Offset）</code></p>\n</li>\n<li><p><strong>段页式管理</strong>：段页式管理机制结合了段式管理和页式管理的优点。简单来说，段页式管理机制就是把主存先分成若干个段，每个段又分成若干个页，也就是说 <strong>段页式管理机制</strong> 中段与段之间以及段的内部之间都是离散的。</p>\n</li>\n</ol>\n<blockquote>\n<p>总的来说：页是物理单位，段是逻辑单位。分页可以有效的提高内存的利用率，分段可以更好的满足用户的需求。</p>\n</blockquote>\n<h3 id=\"3、块表和多级页表\"><a href=\"#3、块表和多级页表\" class=\"headerlink\" title=\"3、块表和多级页表\"></a>3、块表和多级页表</h3><ol>\n<li><p>快表和多级页表，这两个内容解决了页表管理中很重要的两个问题。</p>\n<ol>\n<li>虚拟地址到物理地址的转换要快。</li>\n<li>解决当虚拟地址空间大的时候，页表也会很大的问题。</li>\n</ol>\n</li>\n<li><p><strong>快表</strong></p>\n<p>​    为了提高虚拟机地址到物理地址的转换速度，操作系统在 <strong>页表方案</strong> 基础之上引入了 <strong>快表</strong> 来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器，其中的内容是页表的一部分或者全部内容。作为页表的 cache ，他的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时，CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。</p>\n<p>​    使用快表之后的地址转换流程是这样的：</p>\n<ol>\n<li>根据虚拟地址中的页号查快表。</li>\n<li>如果该页在快表中，直接从快表中读取相应的物理地址。</li>\n<li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中。</li>\n<li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</li>\n</ol>\n</li>\n<li><p><strong>多级页表</strong></p>\n<p>​    引入多级页表的目的主要是为了避免把全部页表一直放在内存中占用过多的空间，特别是那些根本不需要的页表就不要保留在内存中。</p>\n<p>​    多级页表属于时间换空间的经典场景。</p>\n</li>\n</ol>\n<h3 id=\"4、分页机制和分段机制的共同点和区别\"><a href=\"#4、分页机制和分段机制的共同点和区别\" class=\"headerlink\" title=\"4、分页机制和分段机制的共同点和区别\"></a>4、分页机制和分段机制的共同点和区别</h3><ul>\n<li><p><strong>共同点</strong>：</p>\n</li>\n<li><p>分页机制和分段机制都是为了提高内存利用率，减少内存碎片化。</p>\n</li>\n<li><p>页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。</p>\n</li>\n<li><p><strong>区别</strong>：</p>\n<ul>\n<li>页的大小是固定的，由操作系统决定，而段的大小不固定，取决于我们当前运行的程序。</li>\n<li>分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5、逻辑-虚拟-地址和物理地址\"><a href=\"#5、逻辑-虚拟-地址和物理地址\" class=\"headerlink\" title=\"5、逻辑(虚拟)地址和物理地址\"></a>5、逻辑(虚拟)地址和物理地址</h3><ul>\n<li><strong>逻辑(虚拟)地址</strong><ul>\n<li>由 CPU 在执行程序时生成的地址，是<strong>进程 “看到” 的内存地址</strong>，不直接对应物理内存硬件的实际位置。</li>\n<li>进程独立性：每个进程有自己独立的逻辑地址空间，进程 A 的 0x1000 地址和进程 B 的 0x1000 地址毫无关联，避免进程间内存干扰。</li>\n<li>非直接访问：逻辑地址无法直接用于访问物理内存，必须先转换为物理地址。</li>\n</ul>\n</li>\n<li><strong>物理地址</strong><ul>\n<li>计算机物理内存（如内存条）硬件本身的真实地址，是<strong>内存芯片引脚能直接识别的地址</strong>，对应内存单元的实际物理位置。</li>\n<li>硬件唯一性：物理地址由内存硬件决定，整个系统中每个物理地址唯一，直接对应硬件单元。</li>\n<li>直接访问性：只有物理地址能被内存控制器识别，用于读取 &#x2F; 写入内存数据。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6、CPU-寻址\"><a href=\"#6、CPU-寻址\" class=\"headerlink\" title=\"6、CPU 寻址\"></a>6、CPU 寻址</h3><ul>\n<li><strong>CPU 寻址</strong><ul>\n<li>现代处理器使用的是一种称为 <strong>虚拟寻址</strong> 的寻址方式，也就是 CPU 将虚拟地址翻译为物理地址，而完成这个转换工作的是 CPU 中包含的一个被称为 <strong>内存管理单元（MMU）</strong> 的硬件。</li>\n<li>具体过程：<strong>地址拆分</strong>、<strong>页表查询</strong>、<strong>地址拼接</strong>、<strong>内存访问</strong>。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"7、为什么需要虚拟地址空间\"><a href=\"#7、为什么需要虚拟地址空间\" class=\"headerlink\" title=\"7、为什么需要虚拟地址空间\"></a>7、为什么需要虚拟地址空间</h3><p>​\t\t先从没有虚拟地址空间的时候说起，没有虚拟地址空间的时候，<strong>程序直接访问和操作的都是物理内存</strong>。但是这样存在很大的问题。</p>\n<p>​\t\t1、用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易破坏系统，造成操作系统的崩溃。</p>\n<p>​\t\t2、想要同时运行多个程序特别困难，比如想同时运行一个微信和一个QQ音乐，微信运行时，为 1xxx 的地址赋值</p>\n<p>​\t\t\t\t后，QQ音乐也同样给内存 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖之前的值，导致微信程序的崩溃。</p>\n<p>​\t\t通过虚拟地址访问内存有以下优势：</p>\n<ul>\n<li>程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。</li>\n<li>程序可以使用一系列虚拟地址来访问大于可用物理地址内存的内存缓冲区，也就是当物理内存不够使用时，内存管理器会将物理内存页（通常大小 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。</li>\n<li>不同进程使用的虚拟地址彼此之间隔离。一个进程中的代码无法更改正在由另一个进程或操作系统使用的物理内存。</li>\n</ul>\n<h2 id=\"四、虚拟内存\"><a href=\"#四、虚拟内存\" class=\"headerlink\" title=\"四、虚拟内存\"></a>四、虚拟内存</h2><h3 id=\"1、什么是虚拟内存\"><a href=\"#1、什么是虚拟内存\" class=\"headerlink\" title=\"1、什么是虚拟内存\"></a>1、什么是虚拟内存</h3><p>​\t\t在我们平时使用的电脑特别是 Windows 系统十分常见。很多时候，我们使用了很多占内存的软件，这些软件占用的内存可能已将远远超出了我们电脑本身具有的物理内存。这正是因为 <strong>虚拟内存</strong> 的存在，通过虚拟内存可以让程序拥有超过系统物理内存大小的可以用内存空间。另外，<strong>虚拟内存为每个进程提供了一个一致的，私有的地址空间，他让每个进程产生了一种自己在独享主存的错觉</strong>。这样更加有效的管理内存并减少出错。虚拟内存的重要意义在于：<strong>它定义了一个连续的虚拟孔吉纳，并且把内存扩展到硬盘空间。</strong></p>\n<h3 id=\"2、局部性原理\"><a href=\"#2、局部性原理\" class=\"headerlink\" title=\"2、局部性原理\"></a>2、局部性原理</h3><p>​\t\t局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。也就是说，在某个较短的时间段内，程序执行局限于某一小部分，程序访问的存储空间也局限于某个区域。</p>\n<ul>\n<li><strong>时间局部性</strong>：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久之后该数据可能再次被访问。产生时间局部性的经典原因，是由于在程序中存在着大量的循环操作。</li>\n<li><strong>空间局部性</strong>：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量，数组，表等形式簇集储存的。</li>\n</ul>\n<h3 id=\"3、虚拟存储器\"><a href=\"#3、虚拟存储器\" class=\"headerlink\" title=\"3、虚拟存储器\"></a>3、虚拟存储器</h3><p>​    所谓的虚拟存储器，是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩展的一种存储器。</p>\n<p>​    一般具有三大特征：</p>\n<ul>\n<li><strong>多次性</strong>：是指一个作业中的程序和数据无需在作业运行时一次性的调入内存，而是被被允许分成多次调入内存允许。</li>\n<li><strong>对换性</strong>：是指一个作业中的程序和数据无需在作业运行时一直常驻内存，而是允许他们在作业运行时换入和唤出</li>\n<li><strong>虚拟性</strong>：是指能够从逻辑上扩大容量，使用户看到的内存容量远大于实际内存容量。</li>\n</ul>\n<h3 id=\"4、虚拟内存的技术实现\"><a href=\"#4、虚拟内存的技术实现\" class=\"headerlink\" title=\"4、虚拟内存的技术实现\"></a>4、虚拟内存的技术实现</h3><p>​    **虚拟内存技术的实现，需要建立在离散分配内存管理方式的基础上。**虚拟内存的实现有一下三种方式：</p>\n<ul>\n<li><p><strong>请求分页存储管理</strong>：建立在分页系统之上，增加了请求分页功能和页面置换功能所形成的页式虚拟存储系统。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储器系统中，在作业开始运行之前，仅装入当前要执行的部分页面即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入主存，同时操作系统也可以将暂时不使用的页面置换到外存中。</p>\n</li>\n<li><p><strong>请求分段存储器管理</strong>：建立在分段系统之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可；在执行过程中，可以使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已经满了，而又需装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。</p>\n</li>\n<li><p><strong>请求段页式存储管理</strong>：</p>\n<blockquote>\n<p>请求分页和分页存储系统的不同</p>\n<p>请求分页存储管理建立在分页管理之上，根本区别就是是否将程序全部地址空间都装入主存。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"5、页面置换算法\"><a href=\"#5、页面置换算法\" class=\"headerlink\" title=\"5、页面置换算法\"></a>5、页面置换算法</h3><p>​    地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断。</p>\n<p>​    当发生缺页中断时，如果当前内存中没有空闲的页面，操作系统就必须在内存中选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法，我们可以把页面置换算法看成是淘汰页面的规则。</p>\n<ul>\n<li><strong>OPT 页面置换算法（最佳页面置换算法）</strong>：最佳页面置换算法所选择的被淘汰的页面将是以后永不使用的，或者是在很长在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。但是由于人们目前无法预知进程内存下的若干页面中那个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。</li>\n<li><strong>FIFO 页面置换算法（先进先出页面置换算法）</strong>：总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。</li>\n<li><strong>LRU 页面置换算法（最近最久未使用页面置换算法）</strong>：LRU 算法赋予每一个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当淘汰一个页面时，选择现有页面中 T 最大的，即最近最久未使用的页面予以淘汰。</li>\n<li><strong>LFU 页面置换算法 （最少使用页面置换算法）</strong>：该置换算法选择在之前时期使用最少的页面作为淘汰页。</li>\n</ul>\n","abbrlink":"38059bce","wordCount":112,"charCount":8915,"imgCount":0,"vidCount":0,"wsCount":0,"cbCount":0,"readTime":"约48秒","excerpt":"","more":"<h2 id=\"一、操作系统基础\"><a href=\"#一、操作系统基础\" class=\"headerlink\" title=\"一、操作系统基础\"></a>一、操作系统基础</h2><h3 id=\"1、什么是操作系统\"><a href=\"#1、什么是操作系统\" class=\"headerlink\" title=\"1、什么是操作系统\"></a>1、什么是操作系统</h3><p>​    操作系统（Operating System 简称 OS）本质上是一个运行在计算机上的软件程序，用于管理计算机硬件和软件资源。例如，运行在电脑上的所有应用程序都是通过操作系统来调用系统内存以及磁盘等硬件。</p>\n<h3 id=\"2、操作系统的内核\"><a href=\"#2、操作系统的内核\" class=\"headerlink\" title=\"2、操作系统的内核\"></a>2、操作系统的内核</h3><p>​    操作系统的内核时操作系统的核心部分，负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。内核时连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。</p>\n<h3 id=\"3、用户态和系统态\"><a href=\"#3、用户态和系统态\" class=\"headerlink\" title=\"3、用户态和系统态\"></a>3、用户态和系统态</h3><ul>\n<li>用户态：用户态运行的进程可以直接读取用户程序的数据</li>\n<li>系统态：可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制，包括内存、CPU 指令等</li>\n</ul>\n<h3 id=\"4、系统调用\"><a href=\"#4、系统调用\" class=\"headerlink\" title=\"4、系统调用\"></a>4、系统调用</h3><p>​    运行的程序基本都是运行在用户态，如果需要调用操作系统提供的系统态级别的子功能，就需要切换到系统态来调用。也就是说，运行的用户程序中，凡是与系统态级别的资源有关的操作（如 文件管理，进程控制，内存管理等），都必须通过系统调用方式向操作系统提出服务，并由操作系统代为完成。</p>\n<p>​    系统调用大致分为一下几类：</p>\n<ul>\n<li>设备管理。完成设备的请求或释放，设备启动等功能。</li>\n<li>文件管理。完成文件的读、写、创建、删除等功能。</li>\n<li>进程管理。完成进程的创建、撤销、阻塞、唤醒等功能。</li>\n<li>进程通信。完成进程之间的消息传递或信号传递等。</li>\n<li>内存管理。完成内存的分配、回收、获取作业占用内存大小以及地址等。</li>\n</ul>\n<h2 id=\"二、进程和线程\"><a href=\"#二、进程和线程\" class=\"headerlink\" title=\"二、进程和线程\"></a>二、进程和线程</h2><h3 id=\"1、进程和线程的区别\"><a href=\"#1、进程和线程的区别\" class=\"headerlink\" title=\"1、进程和线程的区别\"></a>1、进程和线程的区别</h3><ul>\n<li><strong>进程</strong>：操作系统进行<strong>资源分配的基本单位</strong>（如内存、CPU 时间片、文件句柄等），可理解为 “一个正在运行的程序实例”（例如打开的 Chrome 浏览器、一个 Java 程序），是一个独立的 “资源容器”。</li>\n<li><strong>线程</strong>：操作系统进行<strong>任务调度的基本单位</strong>，是进程内的 “最小执行单元”（例如 Chrome 的一个标签页渲染线程、Java 程序的<code>main</code>线程），必须依赖进程存在，无法独立运行。</li>\n</ul>\n<p>​    从 JVM 的角度看，一个进程可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>，但是每个线程都有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>、<strong>本地方法栈</strong>。线程是进程划分成的更小的运行单元，一个进程在其执行的过程中可以产生多个线程。线程和进程最大的不同在于，进程之间是相互独立的，而线程之间不一定，因为同一个进程中的线程极有可能相互影响。线程执行开销小，但是不利于资源的管理和保护，而进程正相反。</p>\n<h3 id=\"2、进程有哪几种状态\"><a href=\"#2、进程有哪几种状态\" class=\"headerlink\" title=\"2、进程有哪几种状态\"></a>2、进程有哪几种状态</h3><ul>\n<li><strong>创建状态</strong> ：进程正被创建。<ul>\n<li>引起进程创建原因：用户登录、作业调度、提供服务、应用请求 都会引起进程的创建。</li>\n</ul>\n</li>\n<li><strong>就绪状态</strong> ：进程已处于准备运行状态，即 进程获得了除处理器以外的一切所需的资源，一旦得到处理器资源，即可运行。</li>\n<li><strong>运行状态</strong> ：进程正在处理器上运行。</li>\n<li><strong>阻塞状态</strong> ：进程正在等待某一事件而暂停运行，即使处理器处于空闲状态，该进程也不能运行，是进程主动提出<ul>\n<li>原因：向操作系统请求共享资源失败、等待某种操作的完成、新数据尚未、等待IO操作的结束。</li>\n</ul>\n</li>\n<li><strong>终止状态</strong> ：进程终止运行。<ul>\n<li>原因：正常结束、异常结束、外界干预。</li>\n</ul>\n</li>\n</ul>\n<p>补充：</p>\n<ul>\n<li><strong>进程的挂起</strong> ：当系统中出现引起进程挂起的事件时，OS 会利用挂起原语将指定的进程挂起，如果进程时就绪状态，则改为静止就绪状态，如果是阻塞状态，则改为静止阻塞，如果运行状态，则将其转向调度程序重新调度。</li>\n<li><strong>进程的激活</strong> ：当系统中出现激活进程的事件后，OS 会利用原语将指定的进程激活。</li>\n</ul>\n<h3 id=\"3、进程间的通信方式\"><a href=\"#3、进程间的通信方式\" class=\"headerlink\" title=\"3、进程间的通信方式\"></a>3、进程间的通信方式</h3><ul>\n<li><strong>管道通信</strong><ul>\n<li>匿名管道：用于父进程和子进程之间的通信。</li>\n<li>有名管道：用于任意两个进程之间的通信。</li>\n</ul>\n</li>\n<li><strong>信号</strong>：信号是一种比较复杂的通信方式，用于通知接收进程有某种事件发生。</li>\n<li><strong>消息队列</strong>：消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道不同的是消息队列存放在内核中，只有在内核重启或者显示地删除一个消息队列时，该消息才会被真正的删除。消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按照消息的类型读取。<strong>消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</strong></li>\n<li><strong>信号量</strong> ：信号量是一个计数器，常被作为一种<strong>锁机制</strong>，用于多进程对共享数据的访问，信号量主要作为进程间以及同一进程内不同线程间的同步手段。</li>\n<li><strong>共享内存</strong> ：共享内存可以使运行在同一台机器上的进程间的<strong>通信最快</strong>。使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存种数据的更新，这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。</li>\n<li><strong>套接字</strong> ：此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持TCP&#x2F;IP的网络通信的基本操作单元，可以看作是不同主机之间的进程进行双向通信的端点，简单来说就是通信双方的一种约定，用套接字的相关函数来完成通信过程。</li>\n</ul>\n<h3 id=\"4、线程间的同步方式\"><a href=\"#4、线程间的同步方式\" class=\"headerlink\" title=\"4、线程间的同步方式\"></a>4、线程间的同步方式</h3><p>​    线程同步是两个或多个共享资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步方式。</p>\n<ul>\n<li><p><strong>互斥量</strong> ：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。例如：Java 中的synchronized 关键字和各种Lock都是这种机制。</p>\n</li>\n<li><p><strong>信号量</strong> ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</p>\n</li>\n<li><p><strong>事件</strong> ：通过通知操作（挂起和唤醒）的方式来保持多线程同步，还可以方便的实现多线程优先级得比较操作。</p>\n</li>\n</ul>\n<h3 id=\"5、进程的调度\"><a href=\"#5、进程的调度\" class=\"headerlink\" title=\"5、进程的调度\"></a>5、进程的调度</h3><p>​    进程调度的任务主要有三，① 保存CPU现场信息 ② 按照某种算法选取进程 ③ 把 CPU 分配给该进程</p>\n<p>​    进程调度算法一般有四种：</p>\n<ul>\n<li><p><strong>先到先服务</strong> ： 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某种事件而被阻塞放弃占用CPU资源时再重新调度。</p>\n</li>\n<li><p><strong>短作业优先</strong> ：从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某种事件而被阻塞放弃占用CPU资源时再重新调度。</p>\n<ul>\n<li>缺点：必须预先知道作业的运行时间，但是这个时间很难估计准确，如果偏短，系统可能会提前终止进程。</li>\n<li>缺点：对长作业非常不利，周转时间会明显增长。</li>\n<li>缺点：完全没有考虑作业的紧迫程度。</li>\n</ul>\n</li>\n<li><p><strong>时间片轮转</strong> ：时间片轮转调度是一种古老，最简单，最公平且使用最广的调度算法，每个进程被分配一个时间段，称作它的时间片，也就是该进程允许运行的时间。</p>\n</li>\n<li><p><strong>多级反馈队列</strong> ：<strong>短进程优先</strong> 仅照顾了短进程，而忽略了长进程。而多级返回调度算法既能使高优先级的作业得到响应，又能响应短作业进程迅速完成，因此是被公认的最好的调度算法，UNIX 采用的就是这种调度算法。</p>\n<ul>\n<li>机制：① 设置多个就绪队列</li>\n<li>机制：② 每个队列都采用先来先服务调度算法</li>\n<li>机制：③ 按队列优先级调度</li>\n</ul>\n</li>\n<li><p><strong>优先级调度</strong> ：为每个进程分配优先级，首先执行具有高优先级的进程，以此类推，具有相同优先级的进程以先进先出的顺序执行。可以根据内存要求，时间要求或者任何其他资源的要求来确定优先级。</p>\n</li>\n</ul>\n<h3 id=\"6、什么是死锁\"><a href=\"#6、什么是死锁\" class=\"headerlink\" title=\"6、什么是死锁\"></a>6、什么是死锁</h3><p>​    死锁描述的是这样一种情况，多个进程&#x2F;线程同时被阻塞，他们中的一个或全部都在等待某个资源被释放，但他们都会因为不能不能获得自己的资源去继续运行而无法释放自己当下占有的资源，并且一直处于这样的僵持状态，而形成死锁。</p>\n<h3 id=\"7、产生死锁的四个必要条件\"><a href=\"#7、产生死锁的四个必要条件\" class=\"headerlink\" title=\"7、产生死锁的四个必要条件\"></a>7、产生死锁的四个必要条件</h3><ul>\n<li><strong>互斥条件</strong> ：资源必须处于非共享模式，即：一次只有一个进程可以使用。如果另一个进程申请该资源，那么必须等待直到该资源被释放为止。</li>\n<li><strong>请求和保持条件</strong> ：一个进程至少占有了一个资源，并等待另一个资源，而该资源被其它线程所占有。</li>\n<li><strong>不可抢占条件</strong> ： 资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。</li>\n<li><strong>循环等待条件</strong> ：一组进程<code>{P0,P1,...,Pn}</code> <code>P0</code> 等待的资源被 <code>P1</code>占有，<code>P1</code> 等待的资源被<code>P2</code> 占有，最后 <code>Pn</code> 等待的资源被<code>P1</code> 占有，形成循环等待的情况。</li>\n</ul>\n<blockquote>\n<p>这四个条件是产生死锁的 <strong>必要条件</strong> ，也就是说只要系统发生死锁，这些条件必然成立，而只要让上述条件之一不满足，就不会产生死锁。</p>\n</blockquote>\n<h3 id=\"8、解决死锁的方法\"><a href=\"#8、解决死锁的方法\" class=\"headerlink\" title=\"8、解决死锁的方法\"></a>8、解决死锁的方法</h3><h4 id=\"1、死锁的预防\"><a href=\"#1、死锁的预防\" class=\"headerlink\" title=\"1、死锁的预防\"></a>1、死锁的预防</h4><p>​\t\t<strong>预防死锁</strong> ：是采用某种策略，<strong>限制并发进程对资源的请求</strong>，从而使得死锁的必要条件在系统执行的任何时间都不满足。</p>\n<p>​\t\t只要破坏四个必要条件中的一个就能够预防死锁的发生。</p>\n<p>​    \t破坏第一个条件 <strong>互斥条件</strong> ：使得资源可以同时被访问，这种是最简单的方法，磁盘可以用这种方法管理，但是系统中的很多资源 <strong>往往是不能被同时访问的</strong> ，所以这种做法在大多数场合是行不通的。</p>\n<p>​    \t破坏第三个条件 <strong>不可抢占条件</strong> ：也就是说，可以采用 <strong>剥夺式调度算法</strong> ，但是，这种调度算法实现起来比较复杂，并且一个资源在被使用一段时间后被抢占，可能导致进程前一段时间的工作失效，还可能因为反复申请和释放资源导致进程的执行被无限期的推迟，既增加了系统开销，也降低了吞吐量。</p>\n<p>​    \t所以，一般比较实用的预防死锁的方法是，通过破坏第二个条件和第四个条件。</p>\n<ol>\n<li><strong>静态分配策略</strong></li>\n</ol>\n<p>​    静态分配策略就是指一个进程必须在执行前就申请到它所需要的全部资源，否则直到它所要的资源得到满足后才开始运行。进程要么占有所有资源开始运行，要么不占有资源，不会出现一些资源等待一些资源的情况。</p>\n<p>​    静态分配策略逻辑简单，实现也很容易，但这种策略 <strong>严重地降低了资源利用率</strong>，因为在每个进程所占有的资源中，有一些资源是在比较靠后的执行时间里才用的，甚至有些资源是在额外的情况下才使用的，这样就可能造成一个进程占有了一些 <strong>几乎不用的资源而是使用其他需要该资源的进程产生等待</strong> 的情况。</p>\n<ol>\n<li><strong>2、层次分配策略</strong></li>\n</ol>\n<p>​    层次分配策略破坏了产生死锁的第四个条件，在层次分配策略下，所有的资源被分成了多个层次，一个进程得到某一次的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源，这种策略，是不能可能出现循环等待链的，因为那样的话，就出现了已经申请了较高层的资源，反而去申请了较低层的资源，不符合层次分配策略。</p>\n<h4 id=\"2、避免死锁\"><a href=\"#2、避免死锁\" class=\"headerlink\" title=\"2、避免死锁\"></a>2、避免死锁</h4><p>​\t\t<strong>避免死锁</strong> ：是系统在分配资源时，根据资源的使用情况<strong>提前做出预测</strong>，从而<strong>避免死锁的发生</strong></p>\n<p>​\t\t死锁的避免的角度是允许系统中<strong>同时存在四个必要条件</strong>，只要掌握并发进程中与每个进程有关的资源动态申请情况，做出 <strong>明智合理的选择</strong>，仍可以避免死锁，因为四大条件仅仅是产生死锁的必要条件。</p>\n<p>​    可以将系统分为 <strong>安全状态</strong> 和 <strong>不安全状态</strong> ，每当为申请者分配资源前，先检测系统状态，如果把系统资源分配给申请者会产生死锁，则拒绝分配，否则接受申请，并为它分配资源。</p>\n<blockquote>\n<p>安全状态，如果操作系统能够保证所有进程在有限时间内得到需要的全部资源，否则是不安全状态</p>\n</blockquote>\n<p>​    \t避免死锁的算法是，<strong>银行家算法</strong> ，也就是：当一个线程申请使用资源时，<strong>银行家算法</strong> 通过 <strong>试探</strong> 分配给该进程资源，然后通过 <strong>安全性算法</strong> 分析分配后系统是否处于安全状态，若处于不安全状态，则试探分配作废，让该进程继续等待，若能够进入安全状态，则就<strong>真的分配资源给该进程</strong></p>\n<h4 id=\"3、死锁的检测\"><a href=\"#3、死锁的检测\" class=\"headerlink\" title=\"3、死锁的检测\"></a>3、死锁的检测</h4><p>​\t\t<strong>检测死锁</strong> ：是指系统设有<strong>专门的机构</strong>，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。</p>\n<p>​\t\t这种方法对资源的分配不加以限制，也不采取死锁避免的措施，但系统会<strong>定时地运行一个 “死锁检测” 的程序</strong>，判断系统内是否出现死锁，如果检测到系统发生了死锁，再采取措施去解除它。</p>\n<p>​\t\t可以利用 <strong>进程-资源分配图</strong> 是否又环路来检测死锁，但是，有环路不一定死锁。</p>\n<h4 id=\"4、死锁的解除\"><a href=\"#4、死锁的解除\" class=\"headerlink\" title=\"4、死锁的解除\"></a>4、死锁的解除</h4><p>​\t\t<strong>解除死锁</strong> ：是与检测相配套的一种措施，用于<strong>将进程从死锁状态下解脱出来</strong></p>\n<p>​\t\t当死锁检测程序检测到存在死锁发生时，应设法让其解除，让系统从死锁中恢复过来。</p>\n<ul>\n<li><strong>立即结束所有进程的执行，重新启动操作系统</strong>，方法简单，但是之前的工作全部作废，损失很大。</li>\n<li><strong>撤销涉及死锁的所有进程，解除死锁后继续运行</strong>，彻底打破死锁的循环等待条件，付出的代价也较大，例如一个进程计算了很长时间，由于被撤销，部分结果也被消除，重新执行就要再次计算。</li>\n<li><strong>逐个撤销涉及死锁的进程，回收资源直到死锁解除</strong></li>\n<li><strong>抢占资源</strong>，从涉及死锁的一个或几个进程中抢占资源，再把夺到的资源分配出去，知道死锁解除。</li>\n</ul>\n<h2 id=\"三、操作系统内存管理基础\"><a href=\"#三、操作系统内存管理基础\" class=\"headerlink\" title=\"三、操作系统内存管理基础\"></a>三、操作系统内存管理基础</h2><h3 id=\"1、内存管理介绍\"><a href=\"#1、内存管理介绍\" class=\"headerlink\" title=\"1、内存管理介绍\"></a>1、内存管理介绍</h3><p>​\t\t操作系统的内存管理主要负责内存的分配和回收，另外地址转换也就是将逻辑地址转换为相应的物理地址等功能也是操作系统内存管理的事情。</p>\n<h3 id=\"2、内存管理机制与方式\"><a href=\"#2、内存管理机制与方式\" class=\"headerlink\" title=\"2、内存管理机制与方式\"></a>2、内存管理机制与方式</h3><p>​\t\t简单的分为 <strong>连续分配管理方式</strong> 和 <strong>非连续分配管理方式</strong> 这两种。连续分配管理方式是指为一个用户程序分配一段连续的内存空间，常见的如 <strong>块式管理</strong>。同样的，非连续分配管理方式，允许一个程序使用的内存分布在离散或者说不相邻的内存空间中，常见的有 <strong>页式管理</strong> 、 <strong>段式管理</strong>、<strong>段页式管理</strong>。</p>\n<ol>\n<li><p><strong>块式管理</strong>：远古时代的计算机操作系统的内存管理方式。将内存分为几个固定大小的块，每个块只包含一个进程。如果程序需要内存的话，操作系统就分配给它一个块，如果程序运行只需要很小的空间的话，分配的这个块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。</p>\n</li>\n<li><p><strong>页式管理</strong>：把主存分为大小相等且固定的一页一页的形式，页比较小，相比于块式管理，划分粒度更小，提高了内存的利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。</p>\n<p>地址转化：</p>\n<p><code>逻辑地址 = 页号（Page Number） + 页内偏移（Offset）</code></p>\n<p><code>物理地址 = 页框号（Frame Number） + 页内偏移（Offset）</code></p>\n</li>\n<li><p><strong>段式管理</strong>：页式管理虽然提高了内存利用率，但是页式管理中的页并无任何实际的意义。段式管理把主存分为一段一段的，段是有实际的意义的，每个段顶一了一组逻辑信息，例如，有主程序段、子程序段、数据段、栈段等。段式管理通过段表对应的逻辑地址和物理地址。</p>\n<p>地址转换：</p>\n<p><code>逻辑地址 = 段号（Segment Number） + 段内偏移（Offset）</code></p>\n<p><code>物理地址 = 段基址（Base Address） + 段内偏移（Offset）</code></p>\n</li>\n<li><p><strong>段页式管理</strong>：段页式管理机制结合了段式管理和页式管理的优点。简单来说，段页式管理机制就是把主存先分成若干个段，每个段又分成若干个页，也就是说 <strong>段页式管理机制</strong> 中段与段之间以及段的内部之间都是离散的。</p>\n</li>\n</ol>\n<blockquote>\n<p>总的来说：页是物理单位，段是逻辑单位。分页可以有效的提高内存的利用率，分段可以更好的满足用户的需求。</p>\n</blockquote>\n<h3 id=\"3、块表和多级页表\"><a href=\"#3、块表和多级页表\" class=\"headerlink\" title=\"3、块表和多级页表\"></a>3、块表和多级页表</h3><ol>\n<li><p>快表和多级页表，这两个内容解决了页表管理中很重要的两个问题。</p>\n<ol>\n<li>虚拟地址到物理地址的转换要快。</li>\n<li>解决当虚拟地址空间大的时候，页表也会很大的问题。</li>\n</ol>\n</li>\n<li><p><strong>快表</strong></p>\n<p>​    为了提高虚拟机地址到物理地址的转换速度，操作系统在 <strong>页表方案</strong> 基础之上引入了 <strong>快表</strong> 来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器，其中的内容是页表的一部分或者全部内容。作为页表的 cache ，他的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时，CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。</p>\n<p>​    使用快表之后的地址转换流程是这样的：</p>\n<ol>\n<li>根据虚拟地址中的页号查快表。</li>\n<li>如果该页在快表中，直接从快表中读取相应的物理地址。</li>\n<li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中。</li>\n<li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</li>\n</ol>\n</li>\n<li><p><strong>多级页表</strong></p>\n<p>​    引入多级页表的目的主要是为了避免把全部页表一直放在内存中占用过多的空间，特别是那些根本不需要的页表就不要保留在内存中。</p>\n<p>​    多级页表属于时间换空间的经典场景。</p>\n</li>\n</ol>\n<h3 id=\"4、分页机制和分段机制的共同点和区别\"><a href=\"#4、分页机制和分段机制的共同点和区别\" class=\"headerlink\" title=\"4、分页机制和分段机制的共同点和区别\"></a>4、分页机制和分段机制的共同点和区别</h3><ul>\n<li><p><strong>共同点</strong>：</p>\n</li>\n<li><p>分页机制和分段机制都是为了提高内存利用率，减少内存碎片化。</p>\n</li>\n<li><p>页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。</p>\n</li>\n<li><p><strong>区别</strong>：</p>\n<ul>\n<li>页的大小是固定的，由操作系统决定，而段的大小不固定，取决于我们当前运行的程序。</li>\n<li>分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5、逻辑-虚拟-地址和物理地址\"><a href=\"#5、逻辑-虚拟-地址和物理地址\" class=\"headerlink\" title=\"5、逻辑(虚拟)地址和物理地址\"></a>5、逻辑(虚拟)地址和物理地址</h3><ul>\n<li><strong>逻辑(虚拟)地址</strong><ul>\n<li>由 CPU 在执行程序时生成的地址，是<strong>进程 “看到” 的内存地址</strong>，不直接对应物理内存硬件的实际位置。</li>\n<li>进程独立性：每个进程有自己独立的逻辑地址空间，进程 A 的 0x1000 地址和进程 B 的 0x1000 地址毫无关联，避免进程间内存干扰。</li>\n<li>非直接访问：逻辑地址无法直接用于访问物理内存，必须先转换为物理地址。</li>\n</ul>\n</li>\n<li><strong>物理地址</strong><ul>\n<li>计算机物理内存（如内存条）硬件本身的真实地址，是<strong>内存芯片引脚能直接识别的地址</strong>，对应内存单元的实际物理位置。</li>\n<li>硬件唯一性：物理地址由内存硬件决定，整个系统中每个物理地址唯一，直接对应硬件单元。</li>\n<li>直接访问性：只有物理地址能被内存控制器识别，用于读取 &#x2F; 写入内存数据。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6、CPU-寻址\"><a href=\"#6、CPU-寻址\" class=\"headerlink\" title=\"6、CPU 寻址\"></a>6、CPU 寻址</h3><ul>\n<li><strong>CPU 寻址</strong><ul>\n<li>现代处理器使用的是一种称为 <strong>虚拟寻址</strong> 的寻址方式，也就是 CPU 将虚拟地址翻译为物理地址，而完成这个转换工作的是 CPU 中包含的一个被称为 <strong>内存管理单元（MMU）</strong> 的硬件。</li>\n<li>具体过程：<strong>地址拆分</strong>、<strong>页表查询</strong>、<strong>地址拼接</strong>、<strong>内存访问</strong>。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"7、为什么需要虚拟地址空间\"><a href=\"#7、为什么需要虚拟地址空间\" class=\"headerlink\" title=\"7、为什么需要虚拟地址空间\"></a>7、为什么需要虚拟地址空间</h3><p>​\t\t先从没有虚拟地址空间的时候说起，没有虚拟地址空间的时候，<strong>程序直接访问和操作的都是物理内存</strong>。但是这样存在很大的问题。</p>\n<p>​\t\t1、用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易破坏系统，造成操作系统的崩溃。</p>\n<p>​\t\t2、想要同时运行多个程序特别困难，比如想同时运行一个微信和一个QQ音乐，微信运行时，为 1xxx 的地址赋值</p>\n<p>​\t\t\t\t后，QQ音乐也同样给内存 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖之前的值，导致微信程序的崩溃。</p>\n<p>​\t\t通过虚拟地址访问内存有以下优势：</p>\n<ul>\n<li>程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。</li>\n<li>程序可以使用一系列虚拟地址来访问大于可用物理地址内存的内存缓冲区，也就是当物理内存不够使用时，内存管理器会将物理内存页（通常大小 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。</li>\n<li>不同进程使用的虚拟地址彼此之间隔离。一个进程中的代码无法更改正在由另一个进程或操作系统使用的物理内存。</li>\n</ul>\n<h2 id=\"四、虚拟内存\"><a href=\"#四、虚拟内存\" class=\"headerlink\" title=\"四、虚拟内存\"></a>四、虚拟内存</h2><h3 id=\"1、什么是虚拟内存\"><a href=\"#1、什么是虚拟内存\" class=\"headerlink\" title=\"1、什么是虚拟内存\"></a>1、什么是虚拟内存</h3><p>​\t\t在我们平时使用的电脑特别是 Windows 系统十分常见。很多时候，我们使用了很多占内存的软件，这些软件占用的内存可能已将远远超出了我们电脑本身具有的物理内存。这正是因为 <strong>虚拟内存</strong> 的存在，通过虚拟内存可以让程序拥有超过系统物理内存大小的可以用内存空间。另外，<strong>虚拟内存为每个进程提供了一个一致的，私有的地址空间，他让每个进程产生了一种自己在独享主存的错觉</strong>。这样更加有效的管理内存并减少出错。虚拟内存的重要意义在于：<strong>它定义了一个连续的虚拟孔吉纳，并且把内存扩展到硬盘空间。</strong></p>\n<h3 id=\"2、局部性原理\"><a href=\"#2、局部性原理\" class=\"headerlink\" title=\"2、局部性原理\"></a>2、局部性原理</h3><p>​\t\t局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。也就是说，在某个较短的时间段内，程序执行局限于某一小部分，程序访问的存储空间也局限于某个区域。</p>\n<ul>\n<li><strong>时间局部性</strong>：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久之后该数据可能再次被访问。产生时间局部性的经典原因，是由于在程序中存在着大量的循环操作。</li>\n<li><strong>空间局部性</strong>：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量，数组，表等形式簇集储存的。</li>\n</ul>\n<h3 id=\"3、虚拟存储器\"><a href=\"#3、虚拟存储器\" class=\"headerlink\" title=\"3、虚拟存储器\"></a>3、虚拟存储器</h3><p>​    所谓的虚拟存储器，是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩展的一种存储器。</p>\n<p>​    一般具有三大特征：</p>\n<ul>\n<li><strong>多次性</strong>：是指一个作业中的程序和数据无需在作业运行时一次性的调入内存，而是被被允许分成多次调入内存允许。</li>\n<li><strong>对换性</strong>：是指一个作业中的程序和数据无需在作业运行时一直常驻内存，而是允许他们在作业运行时换入和唤出</li>\n<li><strong>虚拟性</strong>：是指能够从逻辑上扩大容量，使用户看到的内存容量远大于实际内存容量。</li>\n</ul>\n<h3 id=\"4、虚拟内存的技术实现\"><a href=\"#4、虚拟内存的技术实现\" class=\"headerlink\" title=\"4、虚拟内存的技术实现\"></a>4、虚拟内存的技术实现</h3><p>​    **虚拟内存技术的实现，需要建立在离散分配内存管理方式的基础上。**虚拟内存的实现有一下三种方式：</p>\n<ul>\n<li><p><strong>请求分页存储管理</strong>：建立在分页系统之上，增加了请求分页功能和页面置换功能所形成的页式虚拟存储系统。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储器系统中，在作业开始运行之前，仅装入当前要执行的部分页面即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入主存，同时操作系统也可以将暂时不使用的页面置换到外存中。</p>\n</li>\n<li><p><strong>请求分段存储器管理</strong>：建立在分段系统之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可；在执行过程中，可以使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已经满了，而又需装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。</p>\n</li>\n<li><p><strong>请求段页式存储管理</strong>：</p>\n<blockquote>\n<p>请求分页和分页存储系统的不同</p>\n<p>请求分页存储管理建立在分页管理之上，根本区别就是是否将程序全部地址空间都装入主存。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"5、页面置换算法\"><a href=\"#5、页面置换算法\" class=\"headerlink\" title=\"5、页面置换算法\"></a>5、页面置换算法</h3><p>​    地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断。</p>\n<p>​    当发生缺页中断时，如果当前内存中没有空闲的页面，操作系统就必须在内存中选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法，我们可以把页面置换算法看成是淘汰页面的规则。</p>\n<ul>\n<li><strong>OPT 页面置换算法（最佳页面置换算法）</strong>：最佳页面置换算法所选择的被淘汰的页面将是以后永不使用的，或者是在很长在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。但是由于人们目前无法预知进程内存下的若干页面中那个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。</li>\n<li><strong>FIFO 页面置换算法（先进先出页面置换算法）</strong>：总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。</li>\n<li><strong>LRU 页面置换算法（最近最久未使用页面置换算法）</strong>：LRU 算法赋予每一个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当淘汰一个页面时，选择现有页面中 T 最大的，即最近最久未使用的页面予以淘汰。</li>\n<li><strong>LFU 页面置换算法 （最少使用页面置换算法）</strong>：该置换算法选择在之前时期使用最少的页面作为淘汰页。</li>\n</ul>\n"},{"title":"String的特性","description":"String 的基本特性以及用法和常考题\n","pinned":0,"lang":"zh","type":"post","wordCount":111,"charCount":2123,"imgCount":0,"vidCount":0,"wsCount":0,"cbCount":0,"readTime":"约47秒","abbrlink":"70e3fcb2","date":"2025-10-27T14:23:41.000Z","_content":"### 1、String 为什么是不可变的？\n\n##### 1）原因：\n\n① **安全性** ：String 类常用于存储敏感信息，如密码，路径等，如果它是可变的，攻击者可能通过修改字符串内容来绕过安全检查。同时Java的类加载器在加载类时会使用String来存储类名和包名，如果String是可变的，攻击者可能加载恶意的类破坏系统。Java String 类的不可变性，确保了这些关键字符串在创建并传递后，其值绝对无法被任何代码（包括自身）所改变，从根本上杜绝了被篡改的风险。是系统安全性的基石。\n\n② **字符串常量池依赖不可变性** ：String 类是程序中最常用的，同时存在大量重复字符串，为了解决大量重复的问题，引入了字符串常量池，当创建字符串时，JVM 会优先从池中找，没有再创建，而这个优化完全依赖String的不可变性，因为常量池中的一个对象可能被多次引用，如果其中的任何一个引用能修改对象的值，那末就会导致所有共享该对象的引用全部出错。\n\n③ 在**多线程**模式下，可以自由传递、共享 String，不需要任何同步机制，简化了开发。\n\n④ 由于 String 的不可变性，因此 String 对象的hash值只用计算一次，后续直接从缓存中读取，提高了集合的性能。\n\n##### 2）实现方法：\n\n​      `String` 类的核心参数为 `value` 数组，在`JDK 9` 之后，使用 `byte[]`  代替 `char[]` 。`value` 值由` final` 关键字修饰，保证数据引用的不变性，用 `private`修饰，保证外部无法直接修改，同时 `String` 类由 `final` 修饰，保证不会被继承，防止子类的修改。在 `JDK 9` 版本时，还引用了`Java` 的内部注解`@Stable`，修饰 `value` ，用于提示 `JVM` ，这是一个稳定的字段，一旦赋值，基本不会改变，是运行时的稳定承诺。当访问一个普通字段时，因可能被其他线程修改，理论上需每次从内存加载（但实际受 CPU 缓存优化影响，可能读取旧值）；但是由`@Stable` 注解修饰后，在高频访问时，可能在读取后，就将值存储到一个寄存器中，后续直接从寄存器中取值即可。同时，在编译时可能直接把这个值当作常量，将其内敛到使用它的地方，也被称为 常量折叠 提升运行速度。注意：仍可以用反射调用修改，但是开发者往往不被允许。\n\n### 2、String、StirngBuffer、StirngBuilder 的区别？\n\n##### 1）不可变性：\n\n​      String 是不可变的，任何操作都会产生新的对象，原字符串不做改变。StringBuilder 和 StringBuffer 都是可变的，都是直接在原对象上修改，避免创建新的对象。具体是StringBuilder 和 StringBuffer 都继承AbstractStringBuilder抽象类，其字符都是存储在 value 中，没有使用 final 修饰，当修改时，若 value 容量不够，则会将 value 数组进行扩容，之后，将新串复制到扩容后的数组中。因此只是替换了value数组，原StringBuilder 和 StringBuffer 对象的引用没有改变。\n\n##### 2）线程安全性：\n\n​      String 由不可变性，天然就是线程安全的。StringBuilder 是线程不安全的，多线程模式下可能会导致数据不一致问题。StringBuffer 是线程安全的，所有的方法都是用 Synchorized 修饰。\n\n##### 3）性能（大致）：\n\n​      String（反复创建对象） < StringBuffer（多线程下的加锁解锁） < StringBuilder （单线程下性能高）\n\n### 3、字符串常量池？\n\n##### 1）存储位置：\n\n​      在 JDK 7 之前，字符串常量池位于方法区的永久代中，在JDK 7 之后，字符串常量池也被移动至堆内。\n\n##### 2）存储内容：\n\n​      在 JDK 7 之前，存储的是字符串本身，在移动到堆后，存储的是字符串在堆内存上的引用。对于没有引用的对象，可被垃圾回收器回收，防止内存泄漏。\n\n##### 3）使用方法：\n\n​      String s1 = “Hello” ，则会自动入池，并通过池中的引用指向堆中的“Hello”，而String s2 = new String(“Hello”) ,则是直接在堆内存中创建了一个新的对象，不会进入字符串常量池中。但是可以使用 s2.intern() 方法，将字符串手动添加到常量池中，并返回引用。\n\n##### 4）数据结构：\n\n​      字符串常量池是通过基于Hash表的StringTable实现，JDK 7 之前，固定大小，之后，可指定大小， JDK 9 时，将char[] 改为 byte[]。\n\n### 4、JDK 9 为什么将Stirng的char[]改为byte[]？\n\n##### 1）内存的优化：\n\n​      用char数组时，一个char 占用 2 个字节，实际中，英文，数字，特殊字符占使用的大多数，且是需要 1 个字节。对于byte数组，字符，英文，数字等，都只占用 1 个字节，中文占用 2 个字。例如，对于 “Hello” ，char 数组存需要 5 * 2 = 10B，对于byte数组只需要 5B，节省了近50%的空间。\n\n##### 2）自适应编码\n\n​      根据不同的字符串使用不同的编码。当仅包含 1 个字节的字符时，String 中的coder标志位为 0 ，表示使用单字节编码字符集，当字符串中存在 2 个字节的字符时，String 中的coder标志位为 1，表示采用双字节编码字符集，同时，当单字节字符串拼接上双字节字符串时，会将coder升级为1，表示采用双字节编码字符集。\n\n### 5、Substring() 的优化？\n\n​      substring：在JDK 6 以及之前，时复用原数组，即使只是用一小部分呢，但是要保留整个字符串，导致原字符串无法被GC，在JDK 7 之后，则是会创建一个新的字符串返回，原字符串可以被GC。\n","source":"_posts/String的特性.md","raw":"---\ntitle: String的特性\ntags:\n  - String\ndescription: |\n  String 的基本特性以及用法和常考题\npinned: 0\nlang: zh\ncategories:\n  - Java 基础篇\ntype: post\nwordCount: 111\ncharCount: 2123\nimgCount: 0\nvidCount: 0\nwsCount: 0\ncbCount: 0\nreadTime: 约47秒\nabbrlink: 70e3fcb2\ndate: 2025-10-27 22:23:41\n---\n### 1、String 为什么是不可变的？\n\n##### 1）原因：\n\n① **安全性** ：String 类常用于存储敏感信息，如密码，路径等，如果它是可变的，攻击者可能通过修改字符串内容来绕过安全检查。同时Java的类加载器在加载类时会使用String来存储类名和包名，如果String是可变的，攻击者可能加载恶意的类破坏系统。Java String 类的不可变性，确保了这些关键字符串在创建并传递后，其值绝对无法被任何代码（包括自身）所改变，从根本上杜绝了被篡改的风险。是系统安全性的基石。\n\n② **字符串常量池依赖不可变性** ：String 类是程序中最常用的，同时存在大量重复字符串，为了解决大量重复的问题，引入了字符串常量池，当创建字符串时，JVM 会优先从池中找，没有再创建，而这个优化完全依赖String的不可变性，因为常量池中的一个对象可能被多次引用，如果其中的任何一个引用能修改对象的值，那末就会导致所有共享该对象的引用全部出错。\n\n③ 在**多线程**模式下，可以自由传递、共享 String，不需要任何同步机制，简化了开发。\n\n④ 由于 String 的不可变性，因此 String 对象的hash值只用计算一次，后续直接从缓存中读取，提高了集合的性能。\n\n##### 2）实现方法：\n\n​      `String` 类的核心参数为 `value` 数组，在`JDK 9` 之后，使用 `byte[]`  代替 `char[]` 。`value` 值由` final` 关键字修饰，保证数据引用的不变性，用 `private`修饰，保证外部无法直接修改，同时 `String` 类由 `final` 修饰，保证不会被继承，防止子类的修改。在 `JDK 9` 版本时，还引用了`Java` 的内部注解`@Stable`，修饰 `value` ，用于提示 `JVM` ，这是一个稳定的字段，一旦赋值，基本不会改变，是运行时的稳定承诺。当访问一个普通字段时，因可能被其他线程修改，理论上需每次从内存加载（但实际受 CPU 缓存优化影响，可能读取旧值）；但是由`@Stable` 注解修饰后，在高频访问时，可能在读取后，就将值存储到一个寄存器中，后续直接从寄存器中取值即可。同时，在编译时可能直接把这个值当作常量，将其内敛到使用它的地方，也被称为 常量折叠 提升运行速度。注意：仍可以用反射调用修改，但是开发者往往不被允许。\n\n### 2、String、StirngBuffer、StirngBuilder 的区别？\n\n##### 1）不可变性：\n\n​      String 是不可变的，任何操作都会产生新的对象，原字符串不做改变。StringBuilder 和 StringBuffer 都是可变的，都是直接在原对象上修改，避免创建新的对象。具体是StringBuilder 和 StringBuffer 都继承AbstractStringBuilder抽象类，其字符都是存储在 value 中，没有使用 final 修饰，当修改时，若 value 容量不够，则会将 value 数组进行扩容，之后，将新串复制到扩容后的数组中。因此只是替换了value数组，原StringBuilder 和 StringBuffer 对象的引用没有改变。\n\n##### 2）线程安全性：\n\n​      String 由不可变性，天然就是线程安全的。StringBuilder 是线程不安全的，多线程模式下可能会导致数据不一致问题。StringBuffer 是线程安全的，所有的方法都是用 Synchorized 修饰。\n\n##### 3）性能（大致）：\n\n​      String（反复创建对象） < StringBuffer（多线程下的加锁解锁） < StringBuilder （单线程下性能高）\n\n### 3、字符串常量池？\n\n##### 1）存储位置：\n\n​      在 JDK 7 之前，字符串常量池位于方法区的永久代中，在JDK 7 之后，字符串常量池也被移动至堆内。\n\n##### 2）存储内容：\n\n​      在 JDK 7 之前，存储的是字符串本身，在移动到堆后，存储的是字符串在堆内存上的引用。对于没有引用的对象，可被垃圾回收器回收，防止内存泄漏。\n\n##### 3）使用方法：\n\n​      String s1 = “Hello” ，则会自动入池，并通过池中的引用指向堆中的“Hello”，而String s2 = new String(“Hello”) ,则是直接在堆内存中创建了一个新的对象，不会进入字符串常量池中。但是可以使用 s2.intern() 方法，将字符串手动添加到常量池中，并返回引用。\n\n##### 4）数据结构：\n\n​      字符串常量池是通过基于Hash表的StringTable实现，JDK 7 之前，固定大小，之后，可指定大小， JDK 9 时，将char[] 改为 byte[]。\n\n### 4、JDK 9 为什么将Stirng的char[]改为byte[]？\n\n##### 1）内存的优化：\n\n​      用char数组时，一个char 占用 2 个字节，实际中，英文，数字，特殊字符占使用的大多数，且是需要 1 个字节。对于byte数组，字符，英文，数字等，都只占用 1 个字节，中文占用 2 个字。例如，对于 “Hello” ，char 数组存需要 5 * 2 = 10B，对于byte数组只需要 5B，节省了近50%的空间。\n\n##### 2）自适应编码\n\n​      根据不同的字符串使用不同的编码。当仅包含 1 个字节的字符时，String 中的coder标志位为 0 ，表示使用单字节编码字符集，当字符串中存在 2 个字节的字符时，String 中的coder标志位为 1，表示采用双字节编码字符集，同时，当单字节字符串拼接上双字节字符串时，会将coder升级为1，表示采用双字节编码字符集。\n\n### 5、Substring() 的优化？\n\n​      substring：在JDK 6 以及之前，时复用原数组，即使只是用一小部分呢，但是要保留整个字符串，导致原字符串无法被GC，在JDK 7 之后，则是会创建一个新的字符串返回，原字符串可以被GC。\n","slug":"String的特性","published":1,"updated":"2025-10-27T14:41:16.298Z","comments":1,"layout":"post","photos":[],"_id":"cuid_lB2IXc8O3QX91JcYpGwa","content":"<h3 id=\"1、String-为什么是不可变的？\"><a href=\"#1、String-为什么是不可变的？\" class=\"headerlink\" title=\"1、String 为什么是不可变的？\"></a>1、String 为什么是不可变的？</h3><h5 id=\"1）原因：\"><a href=\"#1）原因：\" class=\"headerlink\" title=\"1）原因：\"></a>1）原因：</h5><p>① <strong>安全性</strong> ：String 类常用于存储敏感信息，如密码，路径等，如果它是可变的，攻击者可能通过修改字符串内容来绕过安全检查。同时Java的类加载器在加载类时会使用String来存储类名和包名，如果String是可变的，攻击者可能加载恶意的类破坏系统。Java String 类的不可变性，确保了这些关键字符串在创建并传递后，其值绝对无法被任何代码（包括自身）所改变，从根本上杜绝了被篡改的风险。是系统安全性的基石。</p>\n<p>② <strong>字符串常量池依赖不可变性</strong> ：String 类是程序中最常用的，同时存在大量重复字符串，为了解决大量重复的问题，引入了字符串常量池，当创建字符串时，JVM 会优先从池中找，没有再创建，而这个优化完全依赖String的不可变性，因为常量池中的一个对象可能被多次引用，如果其中的任何一个引用能修改对象的值，那末就会导致所有共享该对象的引用全部出错。</p>\n<p>③ 在<strong>多线程</strong>模式下，可以自由传递、共享 String，不需要任何同步机制，简化了开发。</p>\n<p>④ 由于 String 的不可变性，因此 String 对象的hash值只用计算一次，后续直接从缓存中读取，提高了集合的性能。</p>\n<h5 id=\"2）实现方法：\"><a href=\"#2）实现方法：\" class=\"headerlink\" title=\"2）实现方法：\"></a>2）实现方法：</h5><p>​      <code>String</code> 类的核心参数为 <code>value</code> 数组，在<code>JDK 9</code> 之后，使用 <code>byte[]</code>  代替 <code>char[]</code> 。<code>value</code> 值由<code> final</code> 关键字修饰，保证数据引用的不变性，用 <code>private</code>修饰，保证外部无法直接修改，同时 <code>String</code> 类由 <code>final</code> 修饰，保证不会被继承，防止子类的修改。在 <code>JDK 9</code> 版本时，还引用了<code>Java</code> 的内部注解<code>@Stable</code>，修饰 <code>value</code> ，用于提示 <code>JVM</code> ，这是一个稳定的字段，一旦赋值，基本不会改变，是运行时的稳定承诺。当访问一个普通字段时，因可能被其他线程修改，理论上需每次从内存加载（但实际受 CPU 缓存优化影响，可能读取旧值）；但是由<code>@Stable</code> 注解修饰后，在高频访问时，可能在读取后，就将值存储到一个寄存器中，后续直接从寄存器中取值即可。同时，在编译时可能直接把这个值当作常量，将其内敛到使用它的地方，也被称为 常量折叠 提升运行速度。注意：仍可以用反射调用修改，但是开发者往往不被允许。</p>\n<h3 id=\"2、String、StirngBuffer、StirngBuilder-的区别？\"><a href=\"#2、String、StirngBuffer、StirngBuilder-的区别？\" class=\"headerlink\" title=\"2、String、StirngBuffer、StirngBuilder 的区别？\"></a>2、String、StirngBuffer、StirngBuilder 的区别？</h3><h5 id=\"1）不可变性：\"><a href=\"#1）不可变性：\" class=\"headerlink\" title=\"1）不可变性：\"></a>1）不可变性：</h5><p>​      String 是不可变的，任何操作都会产生新的对象，原字符串不做改变。StringBuilder 和 StringBuffer 都是可变的，都是直接在原对象上修改，避免创建新的对象。具体是StringBuilder 和 StringBuffer 都继承AbstractStringBuilder抽象类，其字符都是存储在 value 中，没有使用 final 修饰，当修改时，若 value 容量不够，则会将 value 数组进行扩容，之后，将新串复制到扩容后的数组中。因此只是替换了value数组，原StringBuilder 和 StringBuffer 对象的引用没有改变。</p>\n<h5 id=\"2）线程安全性：\"><a href=\"#2）线程安全性：\" class=\"headerlink\" title=\"2）线程安全性：\"></a>2）线程安全性：</h5><p>​      String 由不可变性，天然就是线程安全的。StringBuilder 是线程不安全的，多线程模式下可能会导致数据不一致问题。StringBuffer 是线程安全的，所有的方法都是用 Synchorized 修饰。</p>\n<h5 id=\"3）性能（大致）：\"><a href=\"#3）性能（大致）：\" class=\"headerlink\" title=\"3）性能（大致）：\"></a>3）性能（大致）：</h5><p>​      String（反复创建对象） &lt; StringBuffer（多线程下的加锁解锁） &lt; StringBuilder （单线程下性能高）</p>\n<h3 id=\"3、字符串常量池？\"><a href=\"#3、字符串常量池？\" class=\"headerlink\" title=\"3、字符串常量池？\"></a>3、字符串常量池？</h3><h5 id=\"1）存储位置：\"><a href=\"#1）存储位置：\" class=\"headerlink\" title=\"1）存储位置：\"></a>1）存储位置：</h5><p>​      在 JDK 7 之前，字符串常量池位于方法区的永久代中，在JDK 7 之后，字符串常量池也被移动至堆内。</p>\n<h5 id=\"2）存储内容：\"><a href=\"#2）存储内容：\" class=\"headerlink\" title=\"2）存储内容：\"></a>2）存储内容：</h5><p>​      在 JDK 7 之前，存储的是字符串本身，在移动到堆后，存储的是字符串在堆内存上的引用。对于没有引用的对象，可被垃圾回收器回收，防止内存泄漏。</p>\n<h5 id=\"3）使用方法：\"><a href=\"#3）使用方法：\" class=\"headerlink\" title=\"3）使用方法：\"></a>3）使用方法：</h5><p>​      String s1 &#x3D; “Hello” ，则会自动入池，并通过池中的引用指向堆中的“Hello”，而String s2 &#x3D; new String(“Hello”) ,则是直接在堆内存中创建了一个新的对象，不会进入字符串常量池中。但是可以使用 s2.intern() 方法，将字符串手动添加到常量池中，并返回引用。</p>\n<h5 id=\"4）数据结构：\"><a href=\"#4）数据结构：\" class=\"headerlink\" title=\"4）数据结构：\"></a>4）数据结构：</h5><p>​      字符串常量池是通过基于Hash表的StringTable实现，JDK 7 之前，固定大小，之后，可指定大小， JDK 9 时，将char[] 改为 byte[]。</p>\n<h3 id=\"4、JDK-9-为什么将Stirng的char-改为byte-？\"><a href=\"#4、JDK-9-为什么将Stirng的char-改为byte-？\" class=\"headerlink\" title=\"4、JDK 9 为什么将Stirng的char[]改为byte[]？\"></a>4、JDK 9 为什么将Stirng的char[]改为byte[]？</h3><h5 id=\"1）内存的优化：\"><a href=\"#1）内存的优化：\" class=\"headerlink\" title=\"1）内存的优化：\"></a>1）内存的优化：</h5><p>​      用char数组时，一个char 占用 2 个字节，实际中，英文，数字，特殊字符占使用的大多数，且是需要 1 个字节。对于byte数组，字符，英文，数字等，都只占用 1 个字节，中文占用 2 个字。例如，对于 “Hello” ，char 数组存需要 5 * 2 &#x3D; 10B，对于byte数组只需要 5B，节省了近50%的空间。</p>\n<h5 id=\"2）自适应编码\"><a href=\"#2）自适应编码\" class=\"headerlink\" title=\"2）自适应编码\"></a>2）自适应编码</h5><p>​      根据不同的字符串使用不同的编码。当仅包含 1 个字节的字符时，String 中的coder标志位为 0 ，表示使用单字节编码字符集，当字符串中存在 2 个字节的字符时，String 中的coder标志位为 1，表示采用双字节编码字符集，同时，当单字节字符串拼接上双字节字符串时，会将coder升级为1，表示采用双字节编码字符集。</p>\n<h3 id=\"5、Substring-的优化？\"><a href=\"#5、Substring-的优化？\" class=\"headerlink\" title=\"5、Substring() 的优化？\"></a>5、Substring() 的优化？</h3><p>​      substring：在JDK 6 以及之前，时复用原数组，即使只是用一小部分呢，但是要保留整个字符串，导致原字符串无法被GC，在JDK 7 之后，则是会创建一个新的字符串返回，原字符串可以被GC。</p>\n","excerpt":"","more":"<h3 id=\"1、String-为什么是不可变的？\"><a href=\"#1、String-为什么是不可变的？\" class=\"headerlink\" title=\"1、String 为什么是不可变的？\"></a>1、String 为什么是不可变的？</h3><h5 id=\"1）原因：\"><a href=\"#1）原因：\" class=\"headerlink\" title=\"1）原因：\"></a>1）原因：</h5><p>① <strong>安全性</strong> ：String 类常用于存储敏感信息，如密码，路径等，如果它是可变的，攻击者可能通过修改字符串内容来绕过安全检查。同时Java的类加载器在加载类时会使用String来存储类名和包名，如果String是可变的，攻击者可能加载恶意的类破坏系统。Java String 类的不可变性，确保了这些关键字符串在创建并传递后，其值绝对无法被任何代码（包括自身）所改变，从根本上杜绝了被篡改的风险。是系统安全性的基石。</p>\n<p>② <strong>字符串常量池依赖不可变性</strong> ：String 类是程序中最常用的，同时存在大量重复字符串，为了解决大量重复的问题，引入了字符串常量池，当创建字符串时，JVM 会优先从池中找，没有再创建，而这个优化完全依赖String的不可变性，因为常量池中的一个对象可能被多次引用，如果其中的任何一个引用能修改对象的值，那末就会导致所有共享该对象的引用全部出错。</p>\n<p>③ 在<strong>多线程</strong>模式下，可以自由传递、共享 String，不需要任何同步机制，简化了开发。</p>\n<p>④ 由于 String 的不可变性，因此 String 对象的hash值只用计算一次，后续直接从缓存中读取，提高了集合的性能。</p>\n<h5 id=\"2）实现方法：\"><a href=\"#2）实现方法：\" class=\"headerlink\" title=\"2）实现方法：\"></a>2）实现方法：</h5><p>​      <code>String</code> 类的核心参数为 <code>value</code> 数组，在<code>JDK 9</code> 之后，使用 <code>byte[]</code>  代替 <code>char[]</code> 。<code>value</code> 值由<code> final</code> 关键字修饰，保证数据引用的不变性，用 <code>private</code>修饰，保证外部无法直接修改，同时 <code>String</code> 类由 <code>final</code> 修饰，保证不会被继承，防止子类的修改。在 <code>JDK 9</code> 版本时，还引用了<code>Java</code> 的内部注解<code>@Stable</code>，修饰 <code>value</code> ，用于提示 <code>JVM</code> ，这是一个稳定的字段，一旦赋值，基本不会改变，是运行时的稳定承诺。当访问一个普通字段时，因可能被其他线程修改，理论上需每次从内存加载（但实际受 CPU 缓存优化影响，可能读取旧值）；但是由<code>@Stable</code> 注解修饰后，在高频访问时，可能在读取后，就将值存储到一个寄存器中，后续直接从寄存器中取值即可。同时，在编译时可能直接把这个值当作常量，将其内敛到使用它的地方，也被称为 常量折叠 提升运行速度。注意：仍可以用反射调用修改，但是开发者往往不被允许。</p>\n<h3 id=\"2、String、StirngBuffer、StirngBuilder-的区别？\"><a href=\"#2、String、StirngBuffer、StirngBuilder-的区别？\" class=\"headerlink\" title=\"2、String、StirngBuffer、StirngBuilder 的区别？\"></a>2、String、StirngBuffer、StirngBuilder 的区别？</h3><h5 id=\"1）不可变性：\"><a href=\"#1）不可变性：\" class=\"headerlink\" title=\"1）不可变性：\"></a>1）不可变性：</h5><p>​      String 是不可变的，任何操作都会产生新的对象，原字符串不做改变。StringBuilder 和 StringBuffer 都是可变的，都是直接在原对象上修改，避免创建新的对象。具体是StringBuilder 和 StringBuffer 都继承AbstractStringBuilder抽象类，其字符都是存储在 value 中，没有使用 final 修饰，当修改时，若 value 容量不够，则会将 value 数组进行扩容，之后，将新串复制到扩容后的数组中。因此只是替换了value数组，原StringBuilder 和 StringBuffer 对象的引用没有改变。</p>\n<h5 id=\"2）线程安全性：\"><a href=\"#2）线程安全性：\" class=\"headerlink\" title=\"2）线程安全性：\"></a>2）线程安全性：</h5><p>​      String 由不可变性，天然就是线程安全的。StringBuilder 是线程不安全的，多线程模式下可能会导致数据不一致问题。StringBuffer 是线程安全的，所有的方法都是用 Synchorized 修饰。</p>\n<h5 id=\"3）性能（大致）：\"><a href=\"#3）性能（大致）：\" class=\"headerlink\" title=\"3）性能（大致）：\"></a>3）性能（大致）：</h5><p>​      String（反复创建对象） &lt; StringBuffer（多线程下的加锁解锁） &lt; StringBuilder （单线程下性能高）</p>\n<h3 id=\"3、字符串常量池？\"><a href=\"#3、字符串常量池？\" class=\"headerlink\" title=\"3、字符串常量池？\"></a>3、字符串常量池？</h3><h5 id=\"1）存储位置：\"><a href=\"#1）存储位置：\" class=\"headerlink\" title=\"1）存储位置：\"></a>1）存储位置：</h5><p>​      在 JDK 7 之前，字符串常量池位于方法区的永久代中，在JDK 7 之后，字符串常量池也被移动至堆内。</p>\n<h5 id=\"2）存储内容：\"><a href=\"#2）存储内容：\" class=\"headerlink\" title=\"2）存储内容：\"></a>2）存储内容：</h5><p>​      在 JDK 7 之前，存储的是字符串本身，在移动到堆后，存储的是字符串在堆内存上的引用。对于没有引用的对象，可被垃圾回收器回收，防止内存泄漏。</p>\n<h5 id=\"3）使用方法：\"><a href=\"#3）使用方法：\" class=\"headerlink\" title=\"3）使用方法：\"></a>3）使用方法：</h5><p>​      String s1 &#x3D; “Hello” ，则会自动入池，并通过池中的引用指向堆中的“Hello”，而String s2 &#x3D; new String(“Hello”) ,则是直接在堆内存中创建了一个新的对象，不会进入字符串常量池中。但是可以使用 s2.intern() 方法，将字符串手动添加到常量池中，并返回引用。</p>\n<h5 id=\"4）数据结构：\"><a href=\"#4）数据结构：\" class=\"headerlink\" title=\"4）数据结构：\"></a>4）数据结构：</h5><p>​      字符串常量池是通过基于Hash表的StringTable实现，JDK 7 之前，固定大小，之后，可指定大小， JDK 9 时，将char[] 改为 byte[]。</p>\n<h3 id=\"4、JDK-9-为什么将Stirng的char-改为byte-？\"><a href=\"#4、JDK-9-为什么将Stirng的char-改为byte-？\" class=\"headerlink\" title=\"4、JDK 9 为什么将Stirng的char[]改为byte[]？\"></a>4、JDK 9 为什么将Stirng的char[]改为byte[]？</h3><h5 id=\"1）内存的优化：\"><a href=\"#1）内存的优化：\" class=\"headerlink\" title=\"1）内存的优化：\"></a>1）内存的优化：</h5><p>​      用char数组时，一个char 占用 2 个字节，实际中，英文，数字，特殊字符占使用的大多数，且是需要 1 个字节。对于byte数组，字符，英文，数字等，都只占用 1 个字节，中文占用 2 个字。例如，对于 “Hello” ，char 数组存需要 5 * 2 &#x3D; 10B，对于byte数组只需要 5B，节省了近50%的空间。</p>\n<h5 id=\"2）自适应编码\"><a href=\"#2）自适应编码\" class=\"headerlink\" title=\"2）自适应编码\"></a>2）自适应编码</h5><p>​      根据不同的字符串使用不同的编码。当仅包含 1 个字节的字符时，String 中的coder标志位为 0 ，表示使用单字节编码字符集，当字符串中存在 2 个字节的字符时，String 中的coder标志位为 1，表示采用双字节编码字符集，同时，当单字节字符串拼接上双字节字符串时，会将coder升级为1，表示采用双字节编码字符集。</p>\n<h3 id=\"5、Substring-的优化？\"><a href=\"#5、Substring-的优化？\" class=\"headerlink\" title=\"5、Substring() 的优化？\"></a>5、Substring() 的优化？</h3><p>​      substring：在JDK 6 以及之前，时复用原数组，即使只是用一小部分呢，但是要保留整个字符串，导致原字符串无法被GC，在JDK 7 之后，则是会创建一个新的字符串返回，原字符串可以被GC。</p>\n"},{"title":"测试文章02","description":"文章缩略，支持 `Markdown` **文档格式**\n","pinned":0,"lang":"zh","type":"post","abbrlink":"cc7c02e8","wordCount":112,"charCount":2135,"imgCount":0,"vidCount":0,"wsCount":0,"cbCount":0,"readTime":"约48秒","date":"2025-10-18T13:48:31.000Z","_content":"## 一、String 的特性\n\n### 1、String 为什么是不可变的？\n\n##### 1）原因：\n\n① **安全性**：String 类常用于存储敏感信息，如密码，路径等，如果它是可变的，攻击者可能通过修改字符串内容来绕过安全检查。同时Java的类加载器在加载类时会使用String来存储类名和包名，如果String是可变的，攻击者可能加载恶意的类破坏系统。Java String 类的不可变性，确保了这些关键字符串在创建并传递后，其值绝对无法被任何代码（包括自身）所改变，从根本上杜绝了被篡改的风险。是系统安全性的基石。\n\n② **字符串常量池依赖不可变性**：String 类是程序中最常用的，同时存在大量重复字符串，为了解决大量重复的问题，引入了字符串常量池，当创建字符串时，JVM 会优先从池中找，没有再创建，而这个优化完全依赖String的不可变性，因为常量池中的一个对象可能被多次引用，如果其中的任何一个引用能修改对象的值，那末就会导致所有共享该对象的引用全部出错。\n\n③ 在**多线程**模式下，可以自由传递、共享 String，不需要任何同步机制，简化了开发。\n\n④ 由于 String 的不可变性，因此 String 对象的hash值只用计算一次，后续直接从缓存中读取，提高了集合的性能。\n\n##### 2）实现方法：\n\n​      `String` 类的核心参数为 `value` 数组，在`JDK 9` 之后，使用 `byte[]`  代替 `char[]` 。`value` 值由` final` 关键字修饰，保证数据引用的不变性，用 `private`修饰，保证外部无法直接修改，同时 `String` 类由 `final` 修饰，保证不会被继承，防止子类的修改。在 `JDK 9` 版本时，还引用了`Java` 的内部注解`@Stable`，修饰 `value` ，用于提示 `JVM` ，这是一个稳定的字段，一旦赋值，基本不会改变，是运行时的稳定承诺。当访问一个普通字段时，因可能被其他线程修改，理论上需每次从内存加载（但实际受 CPU 缓存优化影响，可能读取旧值）；但是由`@Stable` 注解修饰后，在高频访问时，可能在读取后，就将值存储到一个寄存器中，后续直接从寄存器中取值即可。同时，在编译时可能直接把这个值当作常量，将其内敛到使用它的地方，也被称为 常量折叠 提升运行速度。注意：仍可以用反射调用修改，但是开发者往往不被允许。\n\n### 2、String、StirngBuffer、StirngBuilder 的区别？\n\n##### 1）不可变性：\n\n​      String 是不可变的，任何操作都会产生新的对象，原字符串不做改变。StringBuilder 和 StringBuffer 都是可变的，都是直接在原对象上修改，避免创建新的对象。具体是StringBuilder 和 StringBuffer 都继承AbstractStringBuilder抽象类，其字符都是存储在 value 中，没有使用 final 修饰，当修改时，若 value 容量不够，则会将 value 数组进行扩容，之后，将新串复制到扩容后的数组中。因此只是替换了value数组，原StringBuilder 和 StringBuffer 对象的引用没有改变。\n\n##### 2）线程安全性：\n\n​      String 由不可变性，天然就是线程安全的。StringBuilder 是线程不安全的，多线程模式下可能会导致数据不一致问题。StringBuffer 是线程安全的，所有的方法都是用 Synchorized 修饰。\n\n##### 3）性能（大致）：\n\n​      String（反复创建对象） < StringBuffer（多线程下的加锁解锁） < StringBuilder （单线程下性能高）\n\n### 3、字符串常量池？\n\n##### 1）存储位置：\n\n​      在 JDK 7 之前，字符串常量池位于方法区的永久代中，在JDK 7 之后，字符串常量池也被移动至堆内。\n\n##### 2）存储内容：\n\n​      在 JDK 7 之前，存储的是字符串本身，在移动到堆后，存储的是字符串在堆内存上的引用。对于没有引用的对象，可被垃圾回收器回收，防止内存泄漏。\n\n##### 3）使用方法：\n\n​      String s1 = “Hello” ，则会自动入池，并通过池中的引用指向堆中的“Hello”，而String s2 = new String(“Hello”) ,则是直接在堆内存中创建了一个新的对象，不会进入字符串常量池中。但是可以使用 s2.intern() 方法，将字符串手动添加到常量池中，并返回引用。\n\n##### 4）数据结构：\n\n​      字符串常量池是通过基于Hash表的StringTable实现，JDK 7 之前，固定大小，之后，可指定大小， JDK 9 时，将char[] 改为 byte[]。\n\n### 4、JDK 9 为什么将Stirng的char[]改为byte[]？\n\n##### 1）内存的优化：\n\n​      用char数组时，一个char 占用 2 个字节，实际中，英文，数字，特殊字符占使用的大多数，且是需要 1 个字节。对于byte数组，字符，英文，数字等，都只占用 1 个字节，中文占用 2 个字。例如，对于 “Hello” ，char 数组存需要 5 * 2 = 10B，对于byte数组只需要 5B，节省了近50%的空间。\n\n##### 2）自适应编码\n\n​      根据不同的字符串使用不同的编码。当仅包含 1 个字节的字符时，String 中的coder标志位为 0 ，表示使用单字节编码字符集，当字符串中存在 2 个字节的字符时，String 中的coder标志位为 1，表示采用双字节编码字符集，同时，当单字节字符串拼接上双字节字符串时，会将coder升级为1，表示采用双字节编码字符集。\n\n### 5、Substring() 的优化？\n\n​      substring：在JDK 6 以及之前，时复用原数组，即使只是用一小部分呢，但是要保留整个字符串，导致原字符串无法被GC，在JDK 7 之后，则是会创建一个新的字符串返回，原字符串可以被GC。","source":"_posts/测试文章02.md","raw":"---\ntitle: 测试文章02\ndescription: |\n  文章缩略，支持 `Markdown` **文档格式**\ntags: \n  - 测试\npinned: 0\nlang: zh\ncategories:\n  - 测试\ntype: post\nabbrlink: cc7c02e8\nwordCount: 112\ncharCount: 2135\nimgCount: 0\nvidCount: 0\nwsCount: 0\ncbCount: 0\nreadTime: 约48秒\ndate: 2025-10-18 21:48:31\n---\n## 一、String 的特性\n\n### 1、String 为什么是不可变的？\n\n##### 1）原因：\n\n① **安全性**：String 类常用于存储敏感信息，如密码，路径等，如果它是可变的，攻击者可能通过修改字符串内容来绕过安全检查。同时Java的类加载器在加载类时会使用String来存储类名和包名，如果String是可变的，攻击者可能加载恶意的类破坏系统。Java String 类的不可变性，确保了这些关键字符串在创建并传递后，其值绝对无法被任何代码（包括自身）所改变，从根本上杜绝了被篡改的风险。是系统安全性的基石。\n\n② **字符串常量池依赖不可变性**：String 类是程序中最常用的，同时存在大量重复字符串，为了解决大量重复的问题，引入了字符串常量池，当创建字符串时，JVM 会优先从池中找，没有再创建，而这个优化完全依赖String的不可变性，因为常量池中的一个对象可能被多次引用，如果其中的任何一个引用能修改对象的值，那末就会导致所有共享该对象的引用全部出错。\n\n③ 在**多线程**模式下，可以自由传递、共享 String，不需要任何同步机制，简化了开发。\n\n④ 由于 String 的不可变性，因此 String 对象的hash值只用计算一次，后续直接从缓存中读取，提高了集合的性能。\n\n##### 2）实现方法：\n\n​      `String` 类的核心参数为 `value` 数组，在`JDK 9` 之后，使用 `byte[]`  代替 `char[]` 。`value` 值由` final` 关键字修饰，保证数据引用的不变性，用 `private`修饰，保证外部无法直接修改，同时 `String` 类由 `final` 修饰，保证不会被继承，防止子类的修改。在 `JDK 9` 版本时，还引用了`Java` 的内部注解`@Stable`，修饰 `value` ，用于提示 `JVM` ，这是一个稳定的字段，一旦赋值，基本不会改变，是运行时的稳定承诺。当访问一个普通字段时，因可能被其他线程修改，理论上需每次从内存加载（但实际受 CPU 缓存优化影响，可能读取旧值）；但是由`@Stable` 注解修饰后，在高频访问时，可能在读取后，就将值存储到一个寄存器中，后续直接从寄存器中取值即可。同时，在编译时可能直接把这个值当作常量，将其内敛到使用它的地方，也被称为 常量折叠 提升运行速度。注意：仍可以用反射调用修改，但是开发者往往不被允许。\n\n### 2、String、StirngBuffer、StirngBuilder 的区别？\n\n##### 1）不可变性：\n\n​      String 是不可变的，任何操作都会产生新的对象，原字符串不做改变。StringBuilder 和 StringBuffer 都是可变的，都是直接在原对象上修改，避免创建新的对象。具体是StringBuilder 和 StringBuffer 都继承AbstractStringBuilder抽象类，其字符都是存储在 value 中，没有使用 final 修饰，当修改时，若 value 容量不够，则会将 value 数组进行扩容，之后，将新串复制到扩容后的数组中。因此只是替换了value数组，原StringBuilder 和 StringBuffer 对象的引用没有改变。\n\n##### 2）线程安全性：\n\n​      String 由不可变性，天然就是线程安全的。StringBuilder 是线程不安全的，多线程模式下可能会导致数据不一致问题。StringBuffer 是线程安全的，所有的方法都是用 Synchorized 修饰。\n\n##### 3）性能（大致）：\n\n​      String（反复创建对象） < StringBuffer（多线程下的加锁解锁） < StringBuilder （单线程下性能高）\n\n### 3、字符串常量池？\n\n##### 1）存储位置：\n\n​      在 JDK 7 之前，字符串常量池位于方法区的永久代中，在JDK 7 之后，字符串常量池也被移动至堆内。\n\n##### 2）存储内容：\n\n​      在 JDK 7 之前，存储的是字符串本身，在移动到堆后，存储的是字符串在堆内存上的引用。对于没有引用的对象，可被垃圾回收器回收，防止内存泄漏。\n\n##### 3）使用方法：\n\n​      String s1 = “Hello” ，则会自动入池，并通过池中的引用指向堆中的“Hello”，而String s2 = new String(“Hello”) ,则是直接在堆内存中创建了一个新的对象，不会进入字符串常量池中。但是可以使用 s2.intern() 方法，将字符串手动添加到常量池中，并返回引用。\n\n##### 4）数据结构：\n\n​      字符串常量池是通过基于Hash表的StringTable实现，JDK 7 之前，固定大小，之后，可指定大小， JDK 9 时，将char[] 改为 byte[]。\n\n### 4、JDK 9 为什么将Stirng的char[]改为byte[]？\n\n##### 1）内存的优化：\n\n​      用char数组时，一个char 占用 2 个字节，实际中，英文，数字，特殊字符占使用的大多数，且是需要 1 个字节。对于byte数组，字符，英文，数字等，都只占用 1 个字节，中文占用 2 个字。例如，对于 “Hello” ，char 数组存需要 5 * 2 = 10B，对于byte数组只需要 5B，节省了近50%的空间。\n\n##### 2）自适应编码\n\n​      根据不同的字符串使用不同的编码。当仅包含 1 个字节的字符时，String 中的coder标志位为 0 ，表示使用单字节编码字符集，当字符串中存在 2 个字节的字符时，String 中的coder标志位为 1，表示采用双字节编码字符集，同时，当单字节字符串拼接上双字节字符串时，会将coder升级为1，表示采用双字节编码字符集。\n\n### 5、Substring() 的优化？\n\n​      substring：在JDK 6 以及之前，时复用原数组，即使只是用一小部分呢，但是要保留整个字符串，导致原字符串无法被GC，在JDK 7 之后，则是会创建一个新的字符串返回，原字符串可以被GC。","slug":"测试文章02","published":1,"updated":"2025-10-26T01:27:23.980Z","comments":1,"layout":"post","photos":[],"_id":"cuidon-mLtw_M7UV1sKcYHBMw","content":"<h2 id=\"一、String-的特性\"><a href=\"#一、String-的特性\" class=\"headerlink\" title=\"一、String 的特性\"></a>一、String 的特性</h2><h3 id=\"1、String-为什么是不可变的？\"><a href=\"#1、String-为什么是不可变的？\" class=\"headerlink\" title=\"1、String 为什么是不可变的？\"></a>1、String 为什么是不可变的？</h3><h5 id=\"1）原因：\"><a href=\"#1）原因：\" class=\"headerlink\" title=\"1）原因：\"></a>1）原因：</h5><p>① <strong>安全性</strong>：String 类常用于存储敏感信息，如密码，路径等，如果它是可变的，攻击者可能通过修改字符串内容来绕过安全检查。同时Java的类加载器在加载类时会使用String来存储类名和包名，如果String是可变的，攻击者可能加载恶意的类破坏系统。Java String 类的不可变性，确保了这些关键字符串在创建并传递后，其值绝对无法被任何代码（包括自身）所改变，从根本上杜绝了被篡改的风险。是系统安全性的基石。</p>\n<p>② <strong>字符串常量池依赖不可变性</strong>：String 类是程序中最常用的，同时存在大量重复字符串，为了解决大量重复的问题，引入了字符串常量池，当创建字符串时，JVM 会优先从池中找，没有再创建，而这个优化完全依赖String的不可变性，因为常量池中的一个对象可能被多次引用，如果其中的任何一个引用能修改对象的值，那末就会导致所有共享该对象的引用全部出错。</p>\n<p>③ 在<strong>多线程</strong>模式下，可以自由传递、共享 String，不需要任何同步机制，简化了开发。</p>\n<p>④ 由于 String 的不可变性，因此 String 对象的hash值只用计算一次，后续直接从缓存中读取，提高了集合的性能。</p>\n<h5 id=\"2）实现方法：\"><a href=\"#2）实现方法：\" class=\"headerlink\" title=\"2）实现方法：\"></a>2）实现方法：</h5><p>​      <code>String</code> 类的核心参数为 <code>value</code> 数组，在<code>JDK 9</code> 之后，使用 <code>byte[]</code>  代替 <code>char[]</code> 。<code>value</code> 值由<code> final</code> 关键字修饰，保证数据引用的不变性，用 <code>private</code>修饰，保证外部无法直接修改，同时 <code>String</code> 类由 <code>final</code> 修饰，保证不会被继承，防止子类的修改。在 <code>JDK 9</code> 版本时，还引用了<code>Java</code> 的内部注解<code>@Stable</code>，修饰 <code>value</code> ，用于提示 <code>JVM</code> ，这是一个稳定的字段，一旦赋值，基本不会改变，是运行时的稳定承诺。当访问一个普通字段时，因可能被其他线程修改，理论上需每次从内存加载（但实际受 CPU 缓存优化影响，可能读取旧值）；但是由<code>@Stable</code> 注解修饰后，在高频访问时，可能在读取后，就将值存储到一个寄存器中，后续直接从寄存器中取值即可。同时，在编译时可能直接把这个值当作常量，将其内敛到使用它的地方，也被称为 常量折叠 提升运行速度。注意：仍可以用反射调用修改，但是开发者往往不被允许。</p>\n<h3 id=\"2、String、StirngBuffer、StirngBuilder-的区别？\"><a href=\"#2、String、StirngBuffer、StirngBuilder-的区别？\" class=\"headerlink\" title=\"2、String、StirngBuffer、StirngBuilder 的区别？\"></a>2、String、StirngBuffer、StirngBuilder 的区别？</h3><h5 id=\"1）不可变性：\"><a href=\"#1）不可变性：\" class=\"headerlink\" title=\"1）不可变性：\"></a>1）不可变性：</h5><p>​      String 是不可变的，任何操作都会产生新的对象，原字符串不做改变。StringBuilder 和 StringBuffer 都是可变的，都是直接在原对象上修改，避免创建新的对象。具体是StringBuilder 和 StringBuffer 都继承AbstractStringBuilder抽象类，其字符都是存储在 value 中，没有使用 final 修饰，当修改时，若 value 容量不够，则会将 value 数组进行扩容，之后，将新串复制到扩容后的数组中。因此只是替换了value数组，原StringBuilder 和 StringBuffer 对象的引用没有改变。</p>\n<h5 id=\"2）线程安全性：\"><a href=\"#2）线程安全性：\" class=\"headerlink\" title=\"2）线程安全性：\"></a>2）线程安全性：</h5><p>​      String 由不可变性，天然就是线程安全的。StringBuilder 是线程不安全的，多线程模式下可能会导致数据不一致问题。StringBuffer 是线程安全的，所有的方法都是用 Synchorized 修饰。</p>\n<h5 id=\"3）性能（大致）：\"><a href=\"#3）性能（大致）：\" class=\"headerlink\" title=\"3）性能（大致）：\"></a>3）性能（大致）：</h5><p>​      String（反复创建对象） &lt; StringBuffer（多线程下的加锁解锁） &lt; StringBuilder （单线程下性能高）</p>\n<h3 id=\"3、字符串常量池？\"><a href=\"#3、字符串常量池？\" class=\"headerlink\" title=\"3、字符串常量池？\"></a>3、字符串常量池？</h3><h5 id=\"1）存储位置：\"><a href=\"#1）存储位置：\" class=\"headerlink\" title=\"1）存储位置：\"></a>1）存储位置：</h5><p>​      在 JDK 7 之前，字符串常量池位于方法区的永久代中，在JDK 7 之后，字符串常量池也被移动至堆内。</p>\n<h5 id=\"2）存储内容：\"><a href=\"#2）存储内容：\" class=\"headerlink\" title=\"2）存储内容：\"></a>2）存储内容：</h5><p>​      在 JDK 7 之前，存储的是字符串本身，在移动到堆后，存储的是字符串在堆内存上的引用。对于没有引用的对象，可被垃圾回收器回收，防止内存泄漏。</p>\n<h5 id=\"3）使用方法：\"><a href=\"#3）使用方法：\" class=\"headerlink\" title=\"3）使用方法：\"></a>3）使用方法：</h5><p>​      String s1 &#x3D; “Hello” ，则会自动入池，并通过池中的引用指向堆中的“Hello”，而String s2 &#x3D; new String(“Hello”) ,则是直接在堆内存中创建了一个新的对象，不会进入字符串常量池中。但是可以使用 s2.intern() 方法，将字符串手动添加到常量池中，并返回引用。</p>\n<h5 id=\"4）数据结构：\"><a href=\"#4）数据结构：\" class=\"headerlink\" title=\"4）数据结构：\"></a>4）数据结构：</h5><p>​      字符串常量池是通过基于Hash表的StringTable实现，JDK 7 之前，固定大小，之后，可指定大小， JDK 9 时，将char[] 改为 byte[]。</p>\n<h3 id=\"4、JDK-9-为什么将Stirng的char-改为byte-？\"><a href=\"#4、JDK-9-为什么将Stirng的char-改为byte-？\" class=\"headerlink\" title=\"4、JDK 9 为什么将Stirng的char[]改为byte[]？\"></a>4、JDK 9 为什么将Stirng的char[]改为byte[]？</h3><h5 id=\"1）内存的优化：\"><a href=\"#1）内存的优化：\" class=\"headerlink\" title=\"1）内存的优化：\"></a>1）内存的优化：</h5><p>​      用char数组时，一个char 占用 2 个字节，实际中，英文，数字，特殊字符占使用的大多数，且是需要 1 个字节。对于byte数组，字符，英文，数字等，都只占用 1 个字节，中文占用 2 个字。例如，对于 “Hello” ，char 数组存需要 5 * 2 &#x3D; 10B，对于byte数组只需要 5B，节省了近50%的空间。</p>\n<h5 id=\"2）自适应编码\"><a href=\"#2）自适应编码\" class=\"headerlink\" title=\"2）自适应编码\"></a>2）自适应编码</h5><p>​      根据不同的字符串使用不同的编码。当仅包含 1 个字节的字符时，String 中的coder标志位为 0 ，表示使用单字节编码字符集，当字符串中存在 2 个字节的字符时，String 中的coder标志位为 1，表示采用双字节编码字符集，同时，当单字节字符串拼接上双字节字符串时，会将coder升级为1，表示采用双字节编码字符集。</p>\n<h3 id=\"5、Substring-的优化？\"><a href=\"#5、Substring-的优化？\" class=\"headerlink\" title=\"5、Substring() 的优化？\"></a>5、Substring() 的优化？</h3><p>​      substring：在JDK 6 以及之前，时复用原数组，即使只是用一小部分呢，但是要保留整个字符串，导致原字符串无法被GC，在JDK 7 之后，则是会创建一个新的字符串返回，原字符串可以被GC。</p>\n","excerpt":"","more":"<h2 id=\"一、String-的特性\"><a href=\"#一、String-的特性\" class=\"headerlink\" title=\"一、String 的特性\"></a>一、String 的特性</h2><h3 id=\"1、String-为什么是不可变的？\"><a href=\"#1、String-为什么是不可变的？\" class=\"headerlink\" title=\"1、String 为什么是不可变的？\"></a>1、String 为什么是不可变的？</h3><h5 id=\"1）原因：\"><a href=\"#1）原因：\" class=\"headerlink\" title=\"1）原因：\"></a>1）原因：</h5><p>① <strong>安全性</strong>：String 类常用于存储敏感信息，如密码，路径等，如果它是可变的，攻击者可能通过修改字符串内容来绕过安全检查。同时Java的类加载器在加载类时会使用String来存储类名和包名，如果String是可变的，攻击者可能加载恶意的类破坏系统。Java String 类的不可变性，确保了这些关键字符串在创建并传递后，其值绝对无法被任何代码（包括自身）所改变，从根本上杜绝了被篡改的风险。是系统安全性的基石。</p>\n<p>② <strong>字符串常量池依赖不可变性</strong>：String 类是程序中最常用的，同时存在大量重复字符串，为了解决大量重复的问题，引入了字符串常量池，当创建字符串时，JVM 会优先从池中找，没有再创建，而这个优化完全依赖String的不可变性，因为常量池中的一个对象可能被多次引用，如果其中的任何一个引用能修改对象的值，那末就会导致所有共享该对象的引用全部出错。</p>\n<p>③ 在<strong>多线程</strong>模式下，可以自由传递、共享 String，不需要任何同步机制，简化了开发。</p>\n<p>④ 由于 String 的不可变性，因此 String 对象的hash值只用计算一次，后续直接从缓存中读取，提高了集合的性能。</p>\n<h5 id=\"2）实现方法：\"><a href=\"#2）实现方法：\" class=\"headerlink\" title=\"2）实现方法：\"></a>2）实现方法：</h5><p>​      <code>String</code> 类的核心参数为 <code>value</code> 数组，在<code>JDK 9</code> 之后，使用 <code>byte[]</code>  代替 <code>char[]</code> 。<code>value</code> 值由<code> final</code> 关键字修饰，保证数据引用的不变性，用 <code>private</code>修饰，保证外部无法直接修改，同时 <code>String</code> 类由 <code>final</code> 修饰，保证不会被继承，防止子类的修改。在 <code>JDK 9</code> 版本时，还引用了<code>Java</code> 的内部注解<code>@Stable</code>，修饰 <code>value</code> ，用于提示 <code>JVM</code> ，这是一个稳定的字段，一旦赋值，基本不会改变，是运行时的稳定承诺。当访问一个普通字段时，因可能被其他线程修改，理论上需每次从内存加载（但实际受 CPU 缓存优化影响，可能读取旧值）；但是由<code>@Stable</code> 注解修饰后，在高频访问时，可能在读取后，就将值存储到一个寄存器中，后续直接从寄存器中取值即可。同时，在编译时可能直接把这个值当作常量，将其内敛到使用它的地方，也被称为 常量折叠 提升运行速度。注意：仍可以用反射调用修改，但是开发者往往不被允许。</p>\n<h3 id=\"2、String、StirngBuffer、StirngBuilder-的区别？\"><a href=\"#2、String、StirngBuffer、StirngBuilder-的区别？\" class=\"headerlink\" title=\"2、String、StirngBuffer、StirngBuilder 的区别？\"></a>2、String、StirngBuffer、StirngBuilder 的区别？</h3><h5 id=\"1）不可变性：\"><a href=\"#1）不可变性：\" class=\"headerlink\" title=\"1）不可变性：\"></a>1）不可变性：</h5><p>​      String 是不可变的，任何操作都会产生新的对象，原字符串不做改变。StringBuilder 和 StringBuffer 都是可变的，都是直接在原对象上修改，避免创建新的对象。具体是StringBuilder 和 StringBuffer 都继承AbstractStringBuilder抽象类，其字符都是存储在 value 中，没有使用 final 修饰，当修改时，若 value 容量不够，则会将 value 数组进行扩容，之后，将新串复制到扩容后的数组中。因此只是替换了value数组，原StringBuilder 和 StringBuffer 对象的引用没有改变。</p>\n<h5 id=\"2）线程安全性：\"><a href=\"#2）线程安全性：\" class=\"headerlink\" title=\"2）线程安全性：\"></a>2）线程安全性：</h5><p>​      String 由不可变性，天然就是线程安全的。StringBuilder 是线程不安全的，多线程模式下可能会导致数据不一致问题。StringBuffer 是线程安全的，所有的方法都是用 Synchorized 修饰。</p>\n<h5 id=\"3）性能（大致）：\"><a href=\"#3）性能（大致）：\" class=\"headerlink\" title=\"3）性能（大致）：\"></a>3）性能（大致）：</h5><p>​      String（反复创建对象） &lt; StringBuffer（多线程下的加锁解锁） &lt; StringBuilder （单线程下性能高）</p>\n<h3 id=\"3、字符串常量池？\"><a href=\"#3、字符串常量池？\" class=\"headerlink\" title=\"3、字符串常量池？\"></a>3、字符串常量池？</h3><h5 id=\"1）存储位置：\"><a href=\"#1）存储位置：\" class=\"headerlink\" title=\"1）存储位置：\"></a>1）存储位置：</h5><p>​      在 JDK 7 之前，字符串常量池位于方法区的永久代中，在JDK 7 之后，字符串常量池也被移动至堆内。</p>\n<h5 id=\"2）存储内容：\"><a href=\"#2）存储内容：\" class=\"headerlink\" title=\"2）存储内容：\"></a>2）存储内容：</h5><p>​      在 JDK 7 之前，存储的是字符串本身，在移动到堆后，存储的是字符串在堆内存上的引用。对于没有引用的对象，可被垃圾回收器回收，防止内存泄漏。</p>\n<h5 id=\"3）使用方法：\"><a href=\"#3）使用方法：\" class=\"headerlink\" title=\"3）使用方法：\"></a>3）使用方法：</h5><p>​      String s1 &#x3D; “Hello” ，则会自动入池，并通过池中的引用指向堆中的“Hello”，而String s2 &#x3D; new String(“Hello”) ,则是直接在堆内存中创建了一个新的对象，不会进入字符串常量池中。但是可以使用 s2.intern() 方法，将字符串手动添加到常量池中，并返回引用。</p>\n<h5 id=\"4）数据结构：\"><a href=\"#4）数据结构：\" class=\"headerlink\" title=\"4）数据结构：\"></a>4）数据结构：</h5><p>​      字符串常量池是通过基于Hash表的StringTable实现，JDK 7 之前，固定大小，之后，可指定大小， JDK 9 时，将char[] 改为 byte[]。</p>\n<h3 id=\"4、JDK-9-为什么将Stirng的char-改为byte-？\"><a href=\"#4、JDK-9-为什么将Stirng的char-改为byte-？\" class=\"headerlink\" title=\"4、JDK 9 为什么将Stirng的char[]改为byte[]？\"></a>4、JDK 9 为什么将Stirng的char[]改为byte[]？</h3><h5 id=\"1）内存的优化：\"><a href=\"#1）内存的优化：\" class=\"headerlink\" title=\"1）内存的优化：\"></a>1）内存的优化：</h5><p>​      用char数组时，一个char 占用 2 个字节，实际中，英文，数字，特殊字符占使用的大多数，且是需要 1 个字节。对于byte数组，字符，英文，数字等，都只占用 1 个字节，中文占用 2 个字。例如，对于 “Hello” ，char 数组存需要 5 * 2 &#x3D; 10B，对于byte数组只需要 5B，节省了近50%的空间。</p>\n<h5 id=\"2）自适应编码\"><a href=\"#2）自适应编码\" class=\"headerlink\" title=\"2）自适应编码\"></a>2）自适应编码</h5><p>​      根据不同的字符串使用不同的编码。当仅包含 1 个字节的字符时，String 中的coder标志位为 0 ，表示使用单字节编码字符集，当字符串中存在 2 个字节的字符时，String 中的coder标志位为 1，表示采用双字节编码字符集，同时，当单字节字符串拼接上双字节字符串时，会将coder升级为1，表示采用双字节编码字符集。</p>\n<h3 id=\"5、Substring-的优化？\"><a href=\"#5、Substring-的优化？\" class=\"headerlink\" title=\"5、Substring() 的优化？\"></a>5、Substring() 的优化？</h3><p>​      substring：在JDK 6 以及之前，时复用原数组，即使只是用一小部分呢，但是要保留整个字符串，导致原字符串无法被GC，在JDK 7 之后，则是会创建一个新的字符串返回，原字符串可以被GC。</p>\n"},{"title":"测试文章01","description":"文章缩略，支持 `Markdown` **文档格式**\n","pinned":0,"lang":"zh","type":"post","abbrlink":"55755352","wordCount":49,"charCount":497,"imgCount":0,"vidCount":0,"wsCount":1,"cbCount":1,"readTime":"约32秒","date":"2025-10-18T13:05:32.000Z","_content":"\n# 算法\n\n## 一、平方剩余和\n\n> 主要用于快速的判断两个数的乘积是否为完全平方数。\n> 如果平方剩余和相等，则两个数的乘积是完全平方数。\n\n```java\nimport java.util.HashSet;\nclass Solution {\n    // 平方剩余和 的预处理\n    static int[] core = new int[1010];\n    static int limit = 1000;\n    static {\n        // 求 1~1000 的所有数的平方剩余和\n        for(int i = 1;i <= limit;i++) {\n            if(core[i] == 0) {\n                // 说明没有被计算过\n                for(int j = 1;i*j*j <= limit;j++) {\n                    core[i*j*j] = i;\n                }\n            }\n        }\n    }\n\n    // 验证，平方剩余和 时，两个数的乘积为完全平方数\n    public static void main(String[] args) {\n        for(int i = 1;i <= 1000;i++) {\n            for(int j = i + 1;j <= 1000;j++) {\n                if(core[i] == core[j]) {\n                    System.out.println((i * j) + \" == \" + (String.format(\"%.0f\",Math.sqrt(i * j))) + \"^2\");\n                }\n            }\n        }\n    }\n}\n```","source":"_posts/测试文章01.md","raw":"---\ntitle: 测试文章01\ntags: \n  - 测试\ndescription: |\n  文章缩略，支持 `Markdown` **文档格式**\npinned: 0\nlang: zh\ncategories:\n  - 测试\ntype: post\nabbrlink: '55755352'\nwordCount: 49\ncharCount: 497\nimgCount: 0\nvidCount: 0\nwsCount: 1\ncbCount: 1\nreadTime: 约32秒\ndate: 2025-10-18 21:05:32\n---\n\n# 算法\n\n## 一、平方剩余和\n\n> 主要用于快速的判断两个数的乘积是否为完全平方数。\n> 如果平方剩余和相等，则两个数的乘积是完全平方数。\n\n```java\nimport java.util.HashSet;\nclass Solution {\n    // 平方剩余和 的预处理\n    static int[] core = new int[1010];\n    static int limit = 1000;\n    static {\n        // 求 1~1000 的所有数的平方剩余和\n        for(int i = 1;i <= limit;i++) {\n            if(core[i] == 0) {\n                // 说明没有被计算过\n                for(int j = 1;i*j*j <= limit;j++) {\n                    core[i*j*j] = i;\n                }\n            }\n        }\n    }\n\n    // 验证，平方剩余和 时，两个数的乘积为完全平方数\n    public static void main(String[] args) {\n        for(int i = 1;i <= 1000;i++) {\n            for(int j = i + 1;j <= 1000;j++) {\n                if(core[i] == core[j]) {\n                    System.out.println((i * j) + \" == \" + (String.format(\"%.0f\",Math.sqrt(i * j))) + \"^2\");\n                }\n            }\n        }\n    }\n}\n```","slug":"测试文章01","published":1,"updated":"2025-10-27T02:43:43.027Z","comments":1,"layout":"post","photos":[],"_id":"cuidB_BT2zp1egU2VTexqpjsq","content":"<h1 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h1><h2 id=\"一、平方剩余和\"><a href=\"#一、平方剩余和\" class=\"headerlink\" title=\"一、平方剩余和\"></a>一、平方剩余和</h2><blockquote>\n<p>主要用于快速的判断两个数的乘积是否为完全平方数。<br>如果平方剩余和相等，则两个数的乘积是完全平方数。</p>\n</blockquote>\n<pre><code class=\"language-java\">import java.util.HashSet;\nclass Solution {\n    // 平方剩余和 的预处理\n    static int[] core = new int[1010];\n    static int limit = 1000;\n    static {\n        // 求 1~1000 的所有数的平方剩余和\n        for(int i = 1;i &lt;= limit;i++) {\n            if(core[i] == 0) {\n                // 说明没有被计算过\n                for(int j = 1;i*j*j &lt;= limit;j++) {\n                    core[i*j*j] = i;\n                }\n            }\n        }\n    }\n\n    // 验证，平方剩余和 时，两个数的乘积为完全平方数\n    public static void main(String[] args) {\n        for(int i = 1;i &lt;= 1000;i++) {\n            for(int j = i + 1;j &lt;= 1000;j++) {\n                if(core[i] == core[j]) {\n                    System.out.println((i * j) + &quot; == &quot; + (String.format(&quot;%.0f&quot;,Math.sqrt(i * j))) + &quot;^2&quot;);\n                }\n            }\n        }\n    }\n}\n</code></pre>\n","excerpt":"","more":"<h1 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h1><h2 id=\"一、平方剩余和\"><a href=\"#一、平方剩余和\" class=\"headerlink\" title=\"一、平方剩余和\"></a>一、平方剩余和</h2><blockquote>\n<p>主要用于快速的判断两个数的乘积是否为完全平方数。<br>如果平方剩余和相等，则两个数的乘积是完全平方数。</p>\n</blockquote>\n<pre><code class=\"language-java\">import java.util.HashSet;\nclass Solution {\n    // 平方剩余和 的预处理\n    static int[] core = new int[1010];\n    static int limit = 1000;\n    static {\n        // 求 1~1000 的所有数的平方剩余和\n        for(int i = 1;i &lt;= limit;i++) {\n            if(core[i] == 0) {\n                // 说明没有被计算过\n                for(int j = 1;i*j*j &lt;= limit;j++) {\n                    core[i*j*j] = i;\n                }\n            }\n        }\n    }\n\n    // 验证，平方剩余和 时，两个数的乘积为完全平方数\n    public static void main(String[] args) {\n        for(int i = 1;i &lt;= 1000;i++) {\n            for(int j = i + 1;j &lt;= 1000;j++) {\n                if(core[i] == core[j]) {\n                    System.out.println((i * j) + &quot; == &quot; + (String.format(&quot;%.0f&quot;,Math.sqrt(i * j))) + &quot;^2&quot;);\n                }\n            }\n        }\n    }\n}\n</code></pre>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cuidYc6YLA5ukI9gK75TAKYFE","category_id":"cuidpIMMiq2QOdY5KI9vvtMnD","_id":"cuidqX5LyqVgvMSmmUcWt8mNp"},{"post_id":"cuidpWCT9bEovYg5gLfKfrc5-","category_id":"cuidSwlKlNrpVd-Y6rZs9gDGw","_id":"cuidY5hq2Sk6VfdXk29BrgDCm"},{"post_id":"cuidqIvrD7IEOrvgrXxlJhqF8","category_id":"cuidSwlKlNrpVd-Y6rZs9gDGw","_id":"cuidIF0KKbDn9P7o0ZxHIII2d"},{"post_id":"cuidH0iBEePQ64dikmK-KHJeU","category_id":"cuidpIMMiq2QOdY5KI9vvtMnD","_id":"cuidBfAGrEGUZuL-HERR5lP0l"},{"post_id":"cuidDTlMFHJZ88JdTAwnFxwUj","category_id":"cuidSwlKlNrpVd-Y6rZs9gDGw","_id":"cuidppc-OnaMOhtB8MVNsbJuU"},{"post_id":"cuideTUH-6OeOauddoTblxfp2","category_id":"cuidSwlKlNrpVd-Y6rZs9gDGw","_id":"cuidjjJFgGa74-sslMUEHmz1b"},{"post_id":"cuid_lB2IXc8O3QX91JcYpGwa","category_id":"cuidpIMMiq2QOdY5KI9vvtMnD","_id":"cuidp8NYRxUByfyJ6JtEcX2LO"},{"post_id":"cuidXhJRxv5O8qMIj2VNh3y6O","category_id":"cuid_EHLmSU2kdMH7abaloc8T","_id":"cuidNO5m6mKNz9iaQO--90j8X"},{"post_id":"cuidon-mLtw_M7UV1sKcYHBMw","category_id":"cuidHYwoa11LEIMwE6Cw32u6Z","_id":"cuidIi6Zhtl5K5pZeTj2GW1u-"},{"post_id":"cuidB_BT2zp1egU2VTexqpjsq","category_id":"cuidHYwoa11LEIMwE6Cw32u6Z","_id":"cuid6AfatdcE4-wpsj_I4fEM9"}],"PostTag":[{"post_id":"cuidYc6YLA5ukI9gK75TAKYFE","tag_id":"cuidPuta3ASKJlquKXDqXYYeQ","_id":"cuidvW6bpDPIFqS4x2ULjH4gd"},{"post_id":"cuidpWCT9bEovYg5gLfKfrc5-","tag_id":"cuid_fOz4pUA1nY9TjuJAlkJ1","_id":"cuidHFoS8Oo-mGmKDSWhw-dyY"},{"post_id":"cuidqIvrD7IEOrvgrXxlJhqF8","tag_id":"cuidi2_AhcVOoKnl4LQVeC95R","_id":"cuidOSwM1mtYnmSV3wlIMVGQM"},{"post_id":"cuidH0iBEePQ64dikmK-KHJeU","tag_id":"cuidkORtY7_sD6ncn4HM42UJP","_id":"cuidUEGzOAGAGpN26X9Z5Z-em"},{"post_id":"cuidDTlMFHJZ88JdTAwnFxwUj","tag_id":"cuidyu18Lu90C2Z5DkO7aw49q","_id":"cuidKcej3CzLLU-HEfGGI8Ayd"},{"post_id":"cuideTUH-6OeOauddoTblxfp2","tag_id":"cuidSoMx837CiflQWEAsdLfHR","_id":"cuidpKrAKehgqpaO8Rx2kh6zt"},{"post_id":"cuidXhJRxv5O8qMIj2VNh3y6O","tag_id":"cuid5m06zHamDnAUTSdro9wZw","_id":"cuidI9R2GwxC9IaYEbk7H_t-U"},{"post_id":"cuid_lB2IXc8O3QX91JcYpGwa","tag_id":"cuidIH0CHE3d8FNCAMMgLJRSg","_id":"cuid5138jFTHUXeSneHKInfki"},{"post_id":"cuidon-mLtw_M7UV1sKcYHBMw","tag_id":"cuidLJ5BWEX-Nu5idNsE59hni","_id":"cuidFc1S4DK8xzKNy6iFXAFin"},{"post_id":"cuidB_BT2zp1egU2VTexqpjsq","tag_id":"cuidLJ5BWEX-Nu5idNsE59hni","_id":"cuidx3H3yK6WVuNfTiIcKLTep"}],"Tag":[{"name":"ArrayList","_id":"cuidPuta3ASKJlquKXDqXYYeQ"},{"name":"事务","_id":"cuid_fOz4pUA1nY9TjuJAlkJ1"},{"name":"MySQL的MVCC","_id":"cuidi2_AhcVOoKnl4LQVeC95R"},{"name":"HashMap","_id":"cuidkORtY7_sD6ncn4HM42UJP"},{"name":"MySQL索引","_id":"cuidyu18Lu90C2Z5DkO7aw49q"},{"name":"MySQL锁","_id":"cuidSoMx837CiflQWEAsdLfHR"},{"name":"操作系统","_id":"cuid5m06zHamDnAUTSdro9wZw"},{"name":"String","_id":"cuidIH0CHE3d8FNCAMMgLJRSg"},{"name":"测试","_id":"cuidLJ5BWEX-Nu5idNsE59hni"}]}}