{"meta":{"version":1,"warehouse":"6.0.0"},"models":{"Asset":[{"_id":"themes/particlex/source/images/avatar-d.jpg","path":"images/avatar-d.jpg","modified":1,"renderable":1},{"_id":"themes/particlex/source/images/avatar.png","path":"images/avatar.png","modified":1,"renderable":1},{"_id":"themes/particlex/source/images/loading-d.gif","path":"images/loading-d.gif","modified":1,"renderable":1},{"_id":"themes/particlex/source/css/main.css","path":"css/main.css","modified":1,"renderable":1},{"_id":"themes/particlex/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/crypto.js","path":"js/lib/crypto.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/highlight.js","path":"js/lib/highlight.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/math.js","path":"js/lib/math.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/preview.js","path":"js/lib/preview.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/images/background/02.jpeg","path":"images/background/02.jpeg","modified":1,"renderable":1},{"_id":"themes/particlex/source/images/background/01.png","path":"images/background/01.png","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/home.js","path":"js/lib/home.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/js/lib/search.js","path":"js/lib/search.js","modified":1,"renderable":1},{"_id":"themes/particlex/source/images/background/03.png","path":"images/background/03.png","modified":1,"renderable":1},{"_id":"themes/particlex/source/images/background/04.png","path":"images/background/04.png","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/ArrayList集合.md","hash":"bffa74285d0c67db4e8352ff52f1ab5ebe159bb1","modified":1761575291542},{"_id":"source/echarts/index.md","hash":"157245a2e614f4d9b31f210699ca7c2f5c01990a","modified":1761534980979},{"_id":"source/_posts/HashMap集合.md","hash":"cf53cc1f4a4cf0d479f078957504adf10520aaed","modified":1761575291541},{"_id":"source/custom/index.md","hash":"c266b1b06f405f13ee9503593025f684dc3c07c6","modified":1761532847196},{"_id":"source/categories/index.md","hash":"efdb6bb7cfb98f06cf6990f3553c8e26825fdd78","modified":1761526946922},{"_id":"source/tags/index.md","hash":"fac98d1c9e3e94deb390981911b31cc21d7d80db","modified":1761526946940},{"_id":"source/_posts/测试文章01.md","hash":"4b47fef29d668139c390f9bb11d761b74f0c6b21","modified":1761533023027},{"_id":"source/_posts/String的特性.md","hash":"c423b0a1853ee74f951b0a91b97899c6ee707230","modified":1761575291539},{"_id":"source/_posts/测试文章02.md","hash":"a08a5308ef6cf12776b962d7391babfe6b149888","modified":1761442043980},{"_id":"themes/particlex/.npmignore","hash":"5410a1bef9807f666cd92a0d2020f700e67e4096","modified":1761367061811},{"_id":"themes/particlex/LICENSE","hash":"c42335f46096b2ec5509087ab122e5dfd43e2cf4","modified":1761367061811},{"_id":"themes/particlex/README.md","hash":"19b124670bc5c9aa8cff0fc191be1e9a40c841a0","modified":1761367061811},{"_id":"themes/particlex/_config.yml","hash":"1793ec3224f5cf2c5618163475997b85aaefdc45","modified":1761575792410},{"_id":"themes/particlex/package.json","hash":"db00b08d699e394ba9c88edcf280792075e35654","modified":1761367061818},{"_id":"themes/particlex/layout/comment.ejs","hash":"267809e50962af7ab6bc5892855f765d754a62e4","modified":1761367061812},{"_id":"themes/particlex/pnpm-lock.yaml","hash":"4c7a4f39b776af75374d0dc6f6619dcbf0e58b97","modified":1761367061818},{"_id":"themes/particlex/layout/archives.ejs","hash":"d0caf49695e73841e9933374c638c27038547b9b","modified":1761575593097},{"_id":"themes/particlex/layout/card.ejs","hash":"65e0c46a79c02212982c8a9aef1b16bfc3430429","modified":1761367061812},{"_id":"themes/particlex/layout/custom.ejs","hash":"afd6b19ee1d80f734d885a88b9b67f12e5bef1e9","modified":1761533160897},{"_id":"themes/particlex/layout/footer.ejs","hash":"ee3b610c5f388642c93b86827f0c779529d4f809","modified":1761362760692},{"_id":"themes/particlex/layout/current.ejs","hash":"4e75c06c9d0b1336c69c210567581e7efded5621","modified":1761367061812},{"_id":"themes/particlex/layout/categories.ejs","hash":"93dc0ac41cda545aac38a4754103f9050a250360","modified":1761575593086},{"_id":"themes/particlex/layout/import.ejs","hash":"7ac80e3afdcd75b109d471399f74261eda70142a","modified":1761363942816},{"_id":"themes/particlex/layout/echarts.ejs","hash":"72200a68adb8122e129b9754080e281907b5eb0e","modified":1761535448820},{"_id":"themes/particlex/layout/menu.ejs","hash":"1c78bd05cdfb3ae7a47ed572229a1970335fe8b8","modified":1761367061817},{"_id":"themes/particlex/layout/post.ejs","hash":"6c0c40c4e1a1a0da64351006f2582e48b1a8d9ad","modified":1761575593095},{"_id":"themes/particlex/layout/layout.ejs","hash":"b213b0fa952cfca7f8e0874911a44ebf46c4c835","modified":1761533370215},{"_id":"themes/particlex/layout/posts.ejs","hash":"5da096cc669ba1ea7b54edf33697fa7b8ff2b449","modified":1761575593097},{"_id":"themes/particlex/layout/tags.ejs","hash":"3d2e36916f90b1d25d758cec371666aa53db5d07","modified":1761575593092},{"_id":"themes/particlex/source/css/main.css","hash":"72cb9a7f098708f82e03943eea3631ce1e25ce36","modified":1761533855436},{"_id":"themes/particlex/source/images/loading-d.gif","hash":"9c840c5c3e7b97a184deb390df2f6926d6161708","modified":1761367062018},{"_id":"themes/particlex/source/js/main.js","hash":"420d9ab7f2e0cb44bdc5335389344ec1e7253db5","modified":1761367062019},{"_id":"themes/particlex/source/js/lib/crypto.js","hash":"3db8692ac636d9f72dc94127216d21f9793e6602","modified":1761367062019},{"_id":"themes/particlex/source/js/lib/highlight.js","hash":"58fdb5f2d5e409bfc10aac6ccc464c87327806a5","modified":1761367062019},{"_id":"themes/particlex/source/js/lib/math.js","hash":"f7716e83ef236818239fcae91defe730d5bfbc6d","modified":1761367062019},{"_id":"themes/particlex/source/js/lib/home.js","hash":"5ec113e1d72efaab5eb31addc05eb9dcf26ce1af","modified":1761440369181},{"_id":"themes/particlex/source/js/lib/preview.js","hash":"d3050c6ed6d52e451cc1810843c5d595eadb8e5a","modified":1761367062019},{"_id":"themes/particlex/source/js/lib/search.js","hash":"d507facc680300c046f2b967279959541313e1f9","modified":1761367062019},{"_id":"themes/particlex/layout/index.ejs","hash":"7fd8d9eb3c4b1a186a94d6bce3becdecca28534d","modified":1761378399613},{"_id":"themes/particlex/source/images/loading.gif","hash":"1e9f899b335bb6325a36c2580430ce10553439d3","modified":1759829303001},{"_id":"themes/particlex/source/images/avatar-d.jpg","hash":"cd5b921252d1a4f15e17858f4f816ba768a6acf7","modified":1761367061819},{"_id":"themes/particlex/source/images/background/02.jpeg","hash":"fb0379e3d28922d59ca55822765033ed49bbf87c","modified":1761367061944},{"_id":"themes/particlex/source/images/background/04.png","hash":"f228f5ebb89143a7debac551f21289719260ae77","modified":1761367062018},{"_id":"themes/particlex/source/images/background/03.png","hash":"8ed8cd24312f35f231a6626f10ab1fc52cde2079","modified":1761367061983},{"_id":"themes/particlex/source/images/avatar.png","hash":"e724e0a002bc1cc2f7bfdb5a3eed547b6955bcd0","modified":1742697390000},{"_id":"themes/particlex/source/images/background/01.png","hash":"9045362ac3960c29f11c40bda42cf6406ec2cdcc","modified":1761367061941},{"_id":"public/categories/index.html","hash":"0ba72eb7352bc7ffa6ae64978edf9cbe2593ec02","modified":1761575862805},{"_id":"public/echarts/index.html","hash":"3544eff283f3eab253326f0f1e4e6d8e8fe276fc","modified":1761575862805},{"_id":"public/tags/index.html","hash":"25c2f3ec87d9ef8f6e1d4a28aa2ed035eb995645","modified":1761575862805},{"_id":"public/custom/index.html","hash":"e62b4ccd431ad42021e6b044c068d6df62ab2a05","modified":1761575862805},{"_id":"public/posts/43ade6e4.html","hash":"d76299a6d49fc7bef1bf1452db08bc4d0682c507","modified":1761575862805},{"_id":"public/posts/6ff8c531.html","hash":"f06093054a045d07ea9da8525178323c0a787e45","modified":1761575862805},{"_id":"public/posts/70e3fcb2.html","hash":"86ee65121860d94aa0a28980caedb45732dba34a","modified":1761575862805},{"_id":"public/posts/cc7c02e8.html","hash":"ae4a1d55fef2e98d187d6c0cf0aeeae1f9710a66","modified":1761575862805},{"_id":"public/posts/55755352.html","hash":"1d1c0409f5cbd5034d09fdb1c94ddc2bc49ae73e","modified":1761575862805},{"_id":"public/categories/Java-基础篇/index.html","hash":"ce55b6da764dfc7041e25cefb3a7805f2d54f2ea","modified":1761575862805},{"_id":"public/categories/测试/index.html","hash":"215a868de6beac5ca2d1e21e1ddb192fc05ed377","modified":1761575862805},{"_id":"public/archives/index.html","hash":"155a8762c63def67b39030212a804ab7e95402df","modified":1761575862805},{"_id":"public/archives/2025/index.html","hash":"155a8762c63def67b39030212a804ab7e95402df","modified":1761575862805},{"_id":"public/archives/2025/10/index.html","hash":"155a8762c63def67b39030212a804ab7e95402df","modified":1761575862805},{"_id":"public/tags/ArrayList/index.html","hash":"c1b10b6554d48c21e2e5d5832b4fd5b3a7400bba","modified":1761575862805},{"_id":"public/tags/HashMap/index.html","hash":"3da8a247d8b5c5fa583abd7f0baf5571423d777b","modified":1761575862805},{"_id":"public/tags/测试/index.html","hash":"967e7862608635f1d549f0b17f73d8df8de3ebc8","modified":1761575862805},{"_id":"public/tags/String/index.html","hash":"d77ef0875579422a1a7a3657d4a43a3d533e9a62","modified":1761575862805},{"_id":"public/index.html","hash":"62cd86fbe243c29727d3be666dd57e6c3e6807bc","modified":1761575862805},{"_id":"public/images/loading-d.gif","hash":"9c840c5c3e7b97a184deb390df2f6926d6161708","modified":1761575862805},{"_id":"public/css/main.css","hash":"78239bb7251cb0c34f5f35343708066194f54d2d","modified":1761575862805},{"_id":"public/js/lib/highlight.js","hash":"a9ee0fd40904e2e50ab5ecab4c718a49c095836f","modified":1761575862805},{"_id":"public/js/main.js","hash":"a9cb52bac89783c3957c77cbb4ffc8fbb93a92a1","modified":1761575862805},{"_id":"public/js/lib/math.js","hash":"24c182cd3f5dd1c0f0192ca4cc143de71e076d2a","modified":1761575862805},{"_id":"public/js/lib/crypto.js","hash":"bc4a0c41cf5b61faa204a2a820fc042b563142cf","modified":1761575862805},{"_id":"public/js/lib/search.js","hash":"b631b87fa126a9a4a81b60b1a0516f765879963e","modified":1761575862805},{"_id":"public/js/lib/preview.js","hash":"595cfc3aff107b8dd0fdda214995c6f1bb5be39a","modified":1761575862805},{"_id":"public/js/lib/home.js","hash":"c2bf22772fd052cff88a9b5f547a30a6eb97e545","modified":1761575862805},{"_id":"public/images/loading.gif","hash":"1e9f899b335bb6325a36c2580430ce10553439d3","modified":1761575862805},{"_id":"public/images/avatar-d.jpg","hash":"cd5b921252d1a4f15e17858f4f816ba768a6acf7","modified":1761575862805},{"_id":"public/images/background/02.jpeg","hash":"fb0379e3d28922d59ca55822765033ed49bbf87c","modified":1761575862805},{"_id":"public/images/background/04.png","hash":"f228f5ebb89143a7debac551f21289719260ae77","modified":1761575862805},{"_id":"public/images/avatar.png","hash":"e724e0a002bc1cc2f7bfdb5a3eed547b6955bcd0","modified":1761575862805},{"_id":"public/images/background/03.png","hash":"8ed8cd24312f35f231a6626f10ab1fc52cde2079","modified":1761575862805},{"_id":"public/images/background/01.png","hash":"9045362ac3960c29f11c40bda42cf6406ec2cdcc","modified":1761575862805}],"Category":[{"name":"Java 基础篇","_id":"cuidBbpchHrpkd0VH6pRGcmhb"},{"name":"测试","_id":"cuidnT7-Rriacg3ozEOrrMBGD"}],"Data":[],"Page":[{"title":"Tags","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: Tags\n# 用来表示页面的类型，这是tags类型，表示使用layout中的tags模板\ntype: categories\n---","date":"2025-10-27T01:02:26.922Z","updated":"2025-10-27T01:02:26.922Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cuidEHJgIPboKA5YeKSQwNOqS","content":"","excerpt":"","more":""},{"title":"文章总览","type":"echarts","_content":"{% heatmapchart forest 2025 no-footer%} 文章提交热力图 {% endheatmapchart %}\n\n","source":"echarts/index.md","raw":"---\ntitle: 文章总览\ntype: echarts\n---\n{% heatmapchart forest 2025 no-footer%} 文章提交热力图 {% endheatmapchart %}\n\n","date":"2025-10-27T03:16:20.979Z","updated":"2025-10-27T03:16:20.979Z","path":"echarts/index.html","comments":1,"layout":"page","_id":"cuidw8P7LSSS6DWorecdQOPdJ","content":"\n        <script>\n            document.addEventListener('DOMContentLoaded', function() {\n                const heatmapChartDom = document.getElementById('heatmapChart-0');\n                if (heatmapChartDom) {\n                    const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;\n                    const backgroundColor = isDarkMode ? '#333' : 'transparent';\n                    let heatmapChart = echarts.init(heatmapChartDom, isDarkMode ? 'dark' : 'light');\n                    const cellSize = [16, 16];\n\n                    const groupedData = {\"2025\":[[\"2025-10-27\",3],[\"2025-10-18\",2]]};\n                    const years = Object.keys(groupedData).reverse();\n                    const initYear = '2025' || years[0];\n\n                    // Define color themes\n                    const themes = {\n                        oceanic: ['#A6D8E8', '#6FB3D2', '#4A90BF', '#2E6A8E', '#1A4461'],\n                        forest: ['#ACE7AE', '#8FD694', '#69C16D', '#549F57', '#3A7D3E'],\n                        sunset: ['#FFD1A6', '#FFA07A', '#FF6F52', '#D94A3D', '#A62B2B'],\n                        earthy: ['#E3C8A8', '#C4A076', '#A57C52', '#7A5A3A', '#4E3A28'],\n                        pastel: ['#F5D5E6', '#E8B8D0', '#D18FB8', '#A86A8E', '#7A4A61'],\n                        golden: ['#FFEBB5', '#FFD966', '#FFB74D', '#D18F4A', '#A66B2B'],\n                        berry: ['#F4C2D7', '#E88BB3', '#D94A7A', '#A62B5C', '#7A1F3D'],\n                        charcoal: ['#E0E0E0', '#9E9E9E', '#616161', '#424242', '#212121'],\n                    };\n\n                    // Function to get a random theme\n                    function getRandomTheme() {\n                        const themeKeys = Object.keys(themes);\n                        const randomKey = themeKeys[Math.floor(Math.random() * themeKeys.length)];\n                        return themes[randomKey];\n                    }\n\n                    // Use the specified theme or default to 'random'\n                    const colors = themes['forest'.toLowerCase()] || getRandomTheme();\n\n                    const chartOptions = {\n                        backgroundColor: backgroundColor,\n                        tooltip: {\n                            position: 'top',\n                            confine: true,\n                            formatter: params => `${params.value[0]}: ${params.value[1]} Article${params.value[1] !== 1 ? 's' : ''}`,\n                        },\n                        calendar: {\n                            top: '13%',\n                            left: '2%',\n                            right: '8%',\n                            range: initYear,\n                            cellSize: cellSize,\n                            splitLine: { lineStyle: { color: '#E0E0E0', width: 1 } },\n                            itemStyle: { borderWidth: 1, borderColor: '#E0E0E0', color: backgroundColor },\n                            dayLabel: { show: false },\n                            monthLabel: { show: true },\n                            yearLabel: { show: false },\n                        },\n                        visualMap: {\n                            show: true,\n                            right: '8%',\n                            bottom: '5%',\n                            type: 'piecewise',\n                            orient: 'horizontal',\n                            text: ['More', 'Less'],\n                            min: 0,\n                            max: Math.max(...groupedData[initYear].map(item => item[1])),\n                            inRange: { color: colors },\n                        },\n                        legend: {\n                            type: 'scroll',\n                            icon: 'none',\n                            data: years,\n                            orient: 'vertical',\n                            top: '5%',\n                            right: 'right',\n                            itemWidth: 20,\n                            itemHeight: 20,\n                            itemGap: 10,\n                            pageIconSize: 10,\n                            pageTextStyle: { fontSize: 14 },\n                            selectedMode: 'single',\n                        },\n                        series: years.map(year => ({\n                            type: 'heatmap',\n                            coordinateSystem: 'calendar',\n                            data: groupedData[year],\n                            name: year,\n                            emphasis: { disabled: true },\n                            silent: year !== initYear,\n                        })),\n                    };\n\n                    heatmapChart.setOption(chartOptions);\n\n                    heatmapChart.dispatchAction({\n                        type: 'legendSelect',\n                        name: initYear,\n                    });\n\n                    // Function to handle legend selection changes\n                    const handleLegendSelectChanged = function(params) {\n                        const selectedYear = Object.keys(params.selected).find(key => params.selected[key]);\n                        if (selectedYear && groupedData[selectedYear]) {\n                            heatmapChart.setOption({\n                                calendar: { range: selectedYear },\n                                visualMap: {\n                                    max: Math.max(...groupedData[selectedYear].map(item => item[1])),\n                                },\n                                series: years.map(year => ({\n                                    type: 'heatmap',\n                                    coordinateSystem: 'calendar',\n                                    data: groupedData[year],\n                                    name: year,\n                                    emphasis: { disabled: true },\n                                    silent: year !== selectedYear,\n                                })),\n                            });\n                        }\n                    };\n                    \n                    const handleClick = function(params) {\n                        if (params.componentType === 'series') {\n                            const [year, month] = params.value[0].split('-');\n                            window.location.href = '/archives/' + year + '/' + month;\n                        }\n                    };\n\n                    heatmapChart.on('legendselectchanged', handleLegendSelectChanged);\n                    heatmapChart.on('click', handleClick);\n\n                    // Listen for theme changes\n                    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (event) => {\n                        heatmapChart.dispose();\n                        heatmapChart = echarts.init(heatmapChartDom, event.matches ? 'dark' : 'light');\n                        const newBackgroundColor = event.matches ? '#333' : 'transparent';\n                        chartOptions.backgroundColor = newBackgroundColor;\n                        chartOptions.calendar.itemStyle.color = newBackgroundColor;\n                        heatmapChart.setOption(chartOptions);\n                        \n                        // Re-select the initial year\n                        heatmapChart.dispatchAction({\n                            type: 'legendSelect',\n                            name: initYear,\n                        });\n\n                        // Reattach the event listeners\n                        heatmapChart.on('legendselectchanged', handleLegendSelectChanged);\n                        heatmapChart.on('click', handleClick);\n                    });\n                }\n            });\n        </script>\n        <div style=\"width: 100%\">\n            <!-- Title -->\n            \n        <div style=\"text-align: center; font-size: 24px; font-weight: bold; margin-bottom: 10px;\">\n            文章提交热力图 \n        </div>\n    \n            <!-- Heatmap Chart -->\n            <div id=\"heatmapChart-0\" style=\"width: 100%; height: 200px; overflow-x: auto; overflow-y: hidden;\"></div>\n            <!-- Footer -->\n            \n        </div>\n    \n\n","excerpt":"","more":"\n        <script>\n            document.addEventListener('DOMContentLoaded', function() {\n                const heatmapChartDom = document.getElementById('heatmapChart-0');\n                if (heatmapChartDom) {\n                    const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;\n                    const backgroundColor = isDarkMode ? '#333' : 'transparent';\n                    let heatmapChart = echarts.init(heatmapChartDom, isDarkMode ? 'dark' : 'light');\n                    const cellSize = [16, 16];\n\n                    const groupedData = {\"2025\":[[\"2025-10-27\",3],[\"2025-10-18\",2]]};\n                    const years = Object.keys(groupedData).reverse();\n                    const initYear = '2025' || years[0];\n\n                    // Define color themes\n                    const themes = {\n                        oceanic: ['#A6D8E8', '#6FB3D2', '#4A90BF', '#2E6A8E', '#1A4461'],\n                        forest: ['#ACE7AE', '#8FD694', '#69C16D', '#549F57', '#3A7D3E'],\n                        sunset: ['#FFD1A6', '#FFA07A', '#FF6F52', '#D94A3D', '#A62B2B'],\n                        earthy: ['#E3C8A8', '#C4A076', '#A57C52', '#7A5A3A', '#4E3A28'],\n                        pastel: ['#F5D5E6', '#E8B8D0', '#D18FB8', '#A86A8E', '#7A4A61'],\n                        golden: ['#FFEBB5', '#FFD966', '#FFB74D', '#D18F4A', '#A66B2B'],\n                        berry: ['#F4C2D7', '#E88BB3', '#D94A7A', '#A62B5C', '#7A1F3D'],\n                        charcoal: ['#E0E0E0', '#9E9E9E', '#616161', '#424242', '#212121'],\n                    };\n\n                    // Function to get a random theme\n                    function getRandomTheme() {\n                        const themeKeys = Object.keys(themes);\n                        const randomKey = themeKeys[Math.floor(Math.random() * themeKeys.length)];\n                        return themes[randomKey];\n                    }\n\n                    // Use the specified theme or default to 'random'\n                    const colors = themes['forest'.toLowerCase()] || getRandomTheme();\n\n                    const chartOptions = {\n                        backgroundColor: backgroundColor,\n                        tooltip: {\n                            position: 'top',\n                            confine: true,\n                            formatter: params => `${params.value[0]}: ${params.value[1]} Article${params.value[1] !== 1 ? 's' : ''}`,\n                        },\n                        calendar: {\n                            top: '13%',\n                            left: '2%',\n                            right: '8%',\n                            range: initYear,\n                            cellSize: cellSize,\n                            splitLine: { lineStyle: { color: '#E0E0E0', width: 1 } },\n                            itemStyle: { borderWidth: 1, borderColor: '#E0E0E0', color: backgroundColor },\n                            dayLabel: { show: false },\n                            monthLabel: { show: true },\n                            yearLabel: { show: false },\n                        },\n                        visualMap: {\n                            show: true,\n                            right: '8%',\n                            bottom: '5%',\n                            type: 'piecewise',\n                            orient: 'horizontal',\n                            text: ['More', 'Less'],\n                            min: 0,\n                            max: Math.max(...groupedData[initYear].map(item => item[1])),\n                            inRange: { color: colors },\n                        },\n                        legend: {\n                            type: 'scroll',\n                            icon: 'none',\n                            data: years,\n                            orient: 'vertical',\n                            top: '5%',\n                            right: 'right',\n                            itemWidth: 20,\n                            itemHeight: 20,\n                            itemGap: 10,\n                            pageIconSize: 10,\n                            pageTextStyle: { fontSize: 14 },\n                            selectedMode: 'single',\n                        },\n                        series: years.map(year => ({\n                            type: 'heatmap',\n                            coordinateSystem: 'calendar',\n                            data: groupedData[year],\n                            name: year,\n                            emphasis: { disabled: true },\n                            silent: year !== initYear,\n                        })),\n                    };\n\n                    heatmapChart.setOption(chartOptions);\n\n                    heatmapChart.dispatchAction({\n                        type: 'legendSelect',\n                        name: initYear,\n                    });\n\n                    // Function to handle legend selection changes\n                    const handleLegendSelectChanged = function(params) {\n                        const selectedYear = Object.keys(params.selected).find(key => params.selected[key]);\n                        if (selectedYear && groupedData[selectedYear]) {\n                            heatmapChart.setOption({\n                                calendar: { range: selectedYear },\n                                visualMap: {\n                                    max: Math.max(...groupedData[selectedYear].map(item => item[1])),\n                                },\n                                series: years.map(year => ({\n                                    type: 'heatmap',\n                                    coordinateSystem: 'calendar',\n                                    data: groupedData[year],\n                                    name: year,\n                                    emphasis: { disabled: true },\n                                    silent: year !== selectedYear,\n                                })),\n                            });\n                        }\n                    };\n                    \n                    const handleClick = function(params) {\n                        if (params.componentType === 'series') {\n                            const [year, month] = params.value[0].split('-');\n                            window.location.href = '/archives/' + year + '/' + month;\n                        }\n                    };\n\n                    heatmapChart.on('legendselectchanged', handleLegendSelectChanged);\n                    heatmapChart.on('click', handleClick);\n\n                    // Listen for theme changes\n                    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (event) => {\n                        heatmapChart.dispose();\n                        heatmapChart = echarts.init(heatmapChartDom, event.matches ? 'dark' : 'light');\n                        const newBackgroundColor = event.matches ? '#333' : 'transparent';\n                        chartOptions.backgroundColor = newBackgroundColor;\n                        chartOptions.calendar.itemStyle.color = newBackgroundColor;\n                        heatmapChart.setOption(chartOptions);\n                        \n                        // Re-select the initial year\n                        heatmapChart.dispatchAction({\n                            type: 'legendSelect',\n                            name: initYear,\n                        });\n\n                        // Reattach the event listeners\n                        heatmapChart.on('legendselectchanged', handleLegendSelectChanged);\n                        heatmapChart.on('click', handleClick);\n                    });\n                }\n            });\n        </script>\n        <div style=\"width: 100%\">\n            <!-- Title -->\n            \n        <div style=\"text-align: center; font-size: 24px; font-weight: bold; margin-bottom: 10px;\">\n            文章提交热力图 \n        </div>\n    \n            <!-- Heatmap Chart -->\n            <div id=\"heatmapChart-0\" style=\"width: 100%; height: 200px; overflow-x: auto; overflow-y: hidden;\"></div>\n            <!-- Footer -->\n            \n        </div>\n    \n\n"},{"title":"Tags","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: Tags\n# 用来表示页面的类型，这是tags类型，表示使用layout中的tags模板\ntype: tags\n---","date":"2025-10-27T01:02:26.940Z","updated":"2025-10-27T01:02:26.940Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cuidDxKfBr35Kv34ynEuG5MPS","content":"","excerpt":"","more":""},{"title":"自定义页面","type":"custom","_content":"{% heatmapchart %}Blog Heatmap{% endheatmapchart %}","source":"custom/index.md","raw":"---\ntitle: 自定义页面\ntype: custom\n---\n{% heatmapchart %}Blog Heatmap{% endheatmapchart %}","date":"2025-10-27T02:40:47.196Z","updated":"2025-10-27T02:40:47.196Z","path":"custom/index.html","comments":1,"layout":"page","_id":"cuidFJhUo2tIx6273SnqJNyQv","content":"\n        <script>\n            document.addEventListener('DOMContentLoaded', function() {\n                const heatmapChartDom = document.getElementById('heatmapChart-1');\n                if (heatmapChartDom) {\n                    const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;\n                    const backgroundColor = isDarkMode ? '#333' : 'transparent';\n                    let heatmapChart = echarts.init(heatmapChartDom, isDarkMode ? 'dark' : 'light');\n                    const cellSize = [16, 16];\n\n                    const groupedData = {\"2025\":[[\"2025-10-27\",3],[\"2025-10-18\",2]]};\n                    const years = Object.keys(groupedData).reverse();\n                    const initYear = '2025' || years[0];\n\n                    // Define color themes\n                    const themes = {\n                        oceanic: ['#A6D8E8', '#6FB3D2', '#4A90BF', '#2E6A8E', '#1A4461'],\n                        forest: ['#ACE7AE', '#8FD694', '#69C16D', '#549F57', '#3A7D3E'],\n                        sunset: ['#FFD1A6', '#FFA07A', '#FF6F52', '#D94A3D', '#A62B2B'],\n                        earthy: ['#E3C8A8', '#C4A076', '#A57C52', '#7A5A3A', '#4E3A28'],\n                        pastel: ['#F5D5E6', '#E8B8D0', '#D18FB8', '#A86A8E', '#7A4A61'],\n                        golden: ['#FFEBB5', '#FFD966', '#FFB74D', '#D18F4A', '#A66B2B'],\n                        berry: ['#F4C2D7', '#E88BB3', '#D94A7A', '#A62B5C', '#7A1F3D'],\n                        charcoal: ['#E0E0E0', '#9E9E9E', '#616161', '#424242', '#212121'],\n                    };\n\n                    // Function to get a random theme\n                    function getRandomTheme() {\n                        const themeKeys = Object.keys(themes);\n                        const randomKey = themeKeys[Math.floor(Math.random() * themeKeys.length)];\n                        return themes[randomKey];\n                    }\n\n                    // Use the specified theme or default to 'random'\n                    const colors = themes['random'.toLowerCase()] || getRandomTheme();\n\n                    const chartOptions = {\n                        backgroundColor: backgroundColor,\n                        tooltip: {\n                            position: 'top',\n                            confine: true,\n                            formatter: params => `${params.value[0]}: ${params.value[1]} Article${params.value[1] !== 1 ? 's' : ''}`,\n                        },\n                        calendar: {\n                            top: '13%',\n                            left: '2%',\n                            right: '8%',\n                            range: initYear,\n                            cellSize: cellSize,\n                            splitLine: { lineStyle: { color: '#E0E0E0', width: 1 } },\n                            itemStyle: { borderWidth: 1, borderColor: '#E0E0E0', color: backgroundColor },\n                            dayLabel: { show: false },\n                            monthLabel: { show: true },\n                            yearLabel: { show: false },\n                        },\n                        visualMap: {\n                            show: true,\n                            right: '8%',\n                            bottom: '5%',\n                            type: 'piecewise',\n                            orient: 'horizontal',\n                            text: ['More', 'Less'],\n                            min: 0,\n                            max: Math.max(...groupedData[initYear].map(item => item[1])),\n                            inRange: { color: colors },\n                        },\n                        legend: {\n                            type: 'scroll',\n                            icon: 'none',\n                            data: years,\n                            orient: 'vertical',\n                            top: '5%',\n                            right: 'right',\n                            itemWidth: 20,\n                            itemHeight: 20,\n                            itemGap: 10,\n                            pageIconSize: 10,\n                            pageTextStyle: { fontSize: 14 },\n                            selectedMode: 'single',\n                        },\n                        series: years.map(year => ({\n                            type: 'heatmap',\n                            coordinateSystem: 'calendar',\n                            data: groupedData[year],\n                            name: year,\n                            emphasis: { disabled: true },\n                            silent: year !== initYear,\n                        })),\n                    };\n\n                    heatmapChart.setOption(chartOptions);\n\n                    heatmapChart.dispatchAction({\n                        type: 'legendSelect',\n                        name: initYear,\n                    });\n\n                    // Function to handle legend selection changes\n                    const handleLegendSelectChanged = function(params) {\n                        const selectedYear = Object.keys(params.selected).find(key => params.selected[key]);\n                        if (selectedYear && groupedData[selectedYear]) {\n                            heatmapChart.setOption({\n                                calendar: { range: selectedYear },\n                                visualMap: {\n                                    max: Math.max(...groupedData[selectedYear].map(item => item[1])),\n                                },\n                                series: years.map(year => ({\n                                    type: 'heatmap',\n                                    coordinateSystem: 'calendar',\n                                    data: groupedData[year],\n                                    name: year,\n                                    emphasis: { disabled: true },\n                                    silent: year !== selectedYear,\n                                })),\n                            });\n                        }\n                    };\n                    \n                    const handleClick = function(params) {\n                        if (params.componentType === 'series') {\n                            const [year, month] = params.value[0].split('-');\n                            window.location.href = '/archives/' + year + '/' + month;\n                        }\n                    };\n\n                    heatmapChart.on('legendselectchanged', handleLegendSelectChanged);\n                    heatmapChart.on('click', handleClick);\n\n                    // Listen for theme changes\n                    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (event) => {\n                        heatmapChart.dispose();\n                        heatmapChart = echarts.init(heatmapChartDom, event.matches ? 'dark' : 'light');\n                        const newBackgroundColor = event.matches ? '#333' : 'transparent';\n                        chartOptions.backgroundColor = newBackgroundColor;\n                        chartOptions.calendar.itemStyle.color = newBackgroundColor;\n                        heatmapChart.setOption(chartOptions);\n                        \n                        // Re-select the initial year\n                        heatmapChart.dispatchAction({\n                            type: 'legendSelect',\n                            name: initYear,\n                        });\n\n                        // Reattach the event listeners\n                        heatmapChart.on('legendselectchanged', handleLegendSelectChanged);\n                        heatmapChart.on('click', handleClick);\n                    });\n                }\n            });\n        </script>\n        <div style=\"width: 100%\">\n            <!-- Title -->\n            \n        <div style=\"text-align: center; font-size: 24px; font-weight: bold; margin-bottom: 10px;\">\n            Blog Heatmap\n        </div>\n    \n            <!-- Heatmap Chart -->\n            <div id=\"heatmapChart-1\" style=\"width: 100%; height: 200px; overflow-x: auto; overflow-y: hidden;\"></div>\n            <!-- Footer -->\n            \n        <div style=\"text-align: center; font-size: 12px; color: #666; margin-top: 10px; margin-bottom: 20px;\">\n            Powered by <a href=\"https://github.com/erispyu/hexo-stats-echarts\" style=\"color: inherit; text-decoration: none;\" target=\"_blank\">hexo-stats-echarts</a>\n        </div>\n    \n        </div>\n    ","excerpt":"","more":"\n        <script>\n            document.addEventListener('DOMContentLoaded', function() {\n                const heatmapChartDom = document.getElementById('heatmapChart-1');\n                if (heatmapChartDom) {\n                    const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;\n                    const backgroundColor = isDarkMode ? '#333' : 'transparent';\n                    let heatmapChart = echarts.init(heatmapChartDom, isDarkMode ? 'dark' : 'light');\n                    const cellSize = [16, 16];\n\n                    const groupedData = {\"2025\":[[\"2025-10-27\",3],[\"2025-10-18\",2]]};\n                    const years = Object.keys(groupedData).reverse();\n                    const initYear = '2025' || years[0];\n\n                    // Define color themes\n                    const themes = {\n                        oceanic: ['#A6D8E8', '#6FB3D2', '#4A90BF', '#2E6A8E', '#1A4461'],\n                        forest: ['#ACE7AE', '#8FD694', '#69C16D', '#549F57', '#3A7D3E'],\n                        sunset: ['#FFD1A6', '#FFA07A', '#FF6F52', '#D94A3D', '#A62B2B'],\n                        earthy: ['#E3C8A8', '#C4A076', '#A57C52', '#7A5A3A', '#4E3A28'],\n                        pastel: ['#F5D5E6', '#E8B8D0', '#D18FB8', '#A86A8E', '#7A4A61'],\n                        golden: ['#FFEBB5', '#FFD966', '#FFB74D', '#D18F4A', '#A66B2B'],\n                        berry: ['#F4C2D7', '#E88BB3', '#D94A7A', '#A62B5C', '#7A1F3D'],\n                        charcoal: ['#E0E0E0', '#9E9E9E', '#616161', '#424242', '#212121'],\n                    };\n\n                    // Function to get a random theme\n                    function getRandomTheme() {\n                        const themeKeys = Object.keys(themes);\n                        const randomKey = themeKeys[Math.floor(Math.random() * themeKeys.length)];\n                        return themes[randomKey];\n                    }\n\n                    // Use the specified theme or default to 'random'\n                    const colors = themes['random'.toLowerCase()] || getRandomTheme();\n\n                    const chartOptions = {\n                        backgroundColor: backgroundColor,\n                        tooltip: {\n                            position: 'top',\n                            confine: true,\n                            formatter: params => `${params.value[0]}: ${params.value[1]} Article${params.value[1] !== 1 ? 's' : ''}`,\n                        },\n                        calendar: {\n                            top: '13%',\n                            left: '2%',\n                            right: '8%',\n                            range: initYear,\n                            cellSize: cellSize,\n                            splitLine: { lineStyle: { color: '#E0E0E0', width: 1 } },\n                            itemStyle: { borderWidth: 1, borderColor: '#E0E0E0', color: backgroundColor },\n                            dayLabel: { show: false },\n                            monthLabel: { show: true },\n                            yearLabel: { show: false },\n                        },\n                        visualMap: {\n                            show: true,\n                            right: '8%',\n                            bottom: '5%',\n                            type: 'piecewise',\n                            orient: 'horizontal',\n                            text: ['More', 'Less'],\n                            min: 0,\n                            max: Math.max(...groupedData[initYear].map(item => item[1])),\n                            inRange: { color: colors },\n                        },\n                        legend: {\n                            type: 'scroll',\n                            icon: 'none',\n                            data: years,\n                            orient: 'vertical',\n                            top: '5%',\n                            right: 'right',\n                            itemWidth: 20,\n                            itemHeight: 20,\n                            itemGap: 10,\n                            pageIconSize: 10,\n                            pageTextStyle: { fontSize: 14 },\n                            selectedMode: 'single',\n                        },\n                        series: years.map(year => ({\n                            type: 'heatmap',\n                            coordinateSystem: 'calendar',\n                            data: groupedData[year],\n                            name: year,\n                            emphasis: { disabled: true },\n                            silent: year !== initYear,\n                        })),\n                    };\n\n                    heatmapChart.setOption(chartOptions);\n\n                    heatmapChart.dispatchAction({\n                        type: 'legendSelect',\n                        name: initYear,\n                    });\n\n                    // Function to handle legend selection changes\n                    const handleLegendSelectChanged = function(params) {\n                        const selectedYear = Object.keys(params.selected).find(key => params.selected[key]);\n                        if (selectedYear && groupedData[selectedYear]) {\n                            heatmapChart.setOption({\n                                calendar: { range: selectedYear },\n                                visualMap: {\n                                    max: Math.max(...groupedData[selectedYear].map(item => item[1])),\n                                },\n                                series: years.map(year => ({\n                                    type: 'heatmap',\n                                    coordinateSystem: 'calendar',\n                                    data: groupedData[year],\n                                    name: year,\n                                    emphasis: { disabled: true },\n                                    silent: year !== selectedYear,\n                                })),\n                            });\n                        }\n                    };\n                    \n                    const handleClick = function(params) {\n                        if (params.componentType === 'series') {\n                            const [year, month] = params.value[0].split('-');\n                            window.location.href = '/archives/' + year + '/' + month;\n                        }\n                    };\n\n                    heatmapChart.on('legendselectchanged', handleLegendSelectChanged);\n                    heatmapChart.on('click', handleClick);\n\n                    // Listen for theme changes\n                    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (event) => {\n                        heatmapChart.dispose();\n                        heatmapChart = echarts.init(heatmapChartDom, event.matches ? 'dark' : 'light');\n                        const newBackgroundColor = event.matches ? '#333' : 'transparent';\n                        chartOptions.backgroundColor = newBackgroundColor;\n                        chartOptions.calendar.itemStyle.color = newBackgroundColor;\n                        heatmapChart.setOption(chartOptions);\n                        \n                        // Re-select the initial year\n                        heatmapChart.dispatchAction({\n                            type: 'legendSelect',\n                            name: initYear,\n                        });\n\n                        // Reattach the event listeners\n                        heatmapChart.on('legendselectchanged', handleLegendSelectChanged);\n                        heatmapChart.on('click', handleClick);\n                    });\n                }\n            });\n        </script>\n        <div style=\"width: 100%\">\n            <!-- Title -->\n            \n        <div style=\"text-align: center; font-size: 24px; font-weight: bold; margin-bottom: 10px;\">\n            Blog Heatmap\n        </div>\n    \n            <!-- Heatmap Chart -->\n            <div id=\"heatmapChart-1\" style=\"width: 100%; height: 200px; overflow-x: auto; overflow-y: hidden;\"></div>\n            <!-- Footer -->\n            \n        <div style=\"text-align: center; font-size: 12px; color: #666; margin-top: 10px; margin-bottom: 20px;\">\n            Powered by <a href=\"https://github.com/erispyu/hexo-stats-echarts\" style=\"color: inherit; text-decoration: none;\" target=\"_blank\">hexo-stats-echarts</a>\n        </div>\n    \n        </div>\n    "}],"Post":[{"title":"ArrayList集合","description":"文章缩略，支持 `Markdown` **文档格式**\n","pinned":0,"lang":"zh","type":"post","wordCount":49,"charCount":1853,"imgCount":0,"vidCount":0,"wsCount":0,"cbCount":0,"readTime":"约24秒","abbrlink":"6ff8c531","date":"2025-10-27T14:25:43.000Z","_content":"### 1、ArrayList 的底层数据结构是什么？\n\n​      ArrayList 的底层数据结构是 Object 类型的 elementData 数组，该数组具有动态可扩容机制，即动态可扩容数组。该数组由 transient 修饰，标记为不可序列化，用来解决在数组序列化时，会将空元素也序列化的问题。同时实现了 writeObject 和 readObject 方法，来手动实现有效元素的序列化和反序列化。\n\n### 2、ArrayList 如何添加元素？扩容机制是什么？\n\n#####       1）添加元素：\n\n​            通过 add() 方法用来添加元素，而 add() 方法，实际上是调用内部私有的add() 方法，向elementData 数组中添加元素。\n\n#####       2）扩容机制：\n\n- 首先，检查数组当前的有效元素的数量是否等于elementData的总长度。\n    - 如果不相等，说明数组未满，则直接添加，并将size的大小加一。\n    - 如果相等，说明当前的空间已经用完，则进入gow()，并将扩容后的数组赋值给elementData数组，然后继续将元素放入，size的大小加一。\n        - 对于grow()方法，入参为最小扩容量，即扩容后的大小一定大于等于这个入参的值，具体的实现为，先获取到数组的整个长度，然后将数组的长度增加为原来的1.5倍后，与入参，即最小扩容量相比。\n            - 如果大于等于入参，那末直接用1.5倍的值作为新数组长度。\n            - 反之直接用最小扩容量最为新数组的长度。\n            - 最后调用Arrays的copy()方法，将数组进行扩容，而这个方法本质是调用底层的System.arraycopy的本地方法来进行数组的扩容。\n\n### 3、ArrayList 是否线程安全？如何解决？\n\n#####       1）线程安全：\n\n​           是非线程安全的，其根本原因是内部没有同步机制，所有的操作都是共享数组和计数器，关键操作并没有原子性。多线程模式下容易出现ConcurrentModificationException 等异常。\n\n#####       2）解决方案：\n\n​           ① 对于轻度并发场景，使用并发工具包Collections的SynchronizedList() 方法，构造线程安全的集合，原理就是通过包装器为所有的方法都加上Synchronized锁，但是，并发性能低，迭代时必须显示的加上锁，因为并发工具包只是为独立的方法加上了 Synchroized(mutex)，而迭代时的多个操作，涉及hasNext、next操作，这些组合操作本身并不是原子的，因此在迭代时，需要显示的加上锁。\n\n​           ② CopyOnWriteArrayList 适用于读多写少的情况，原理就是，在写操作时，复制整个数组，同时数组的长度加1，在新数组的最后位置加上一个元素，再用新数组替换旧数组。而在添加的过程中，在jdk 9 之前用的都是 ReentrantLook 锁，而在jdk 9 之后，用的就是Synchroized。\n\n​           ③ Vector，是线程安全的，原理就是每个方法都用 Synchroized 锁，但是性能较低，迭代器问题未解决。由于锁的力度比较粗，所有公共方法都被Synchroized 修饰，单线程每次调用都有锁的开销，而在多线程模式下，即使是读操作之间也会互斥，无法并发。并且默认扩容为原来的2倍，容易造成内存泄漏。同时迭代器也没有实现线程安全。\n\n​           ④ 手动同步。\n\n### 4、为什么ArrayList扩容为原来的1.5倍？\n\n​      扩容较大会有OOM以及内存浪费，扩容较小会有多次扩容，浪费性能。而1.5是在扩容频率适中，空间利用率最高的大小。\n\n### 5、如何在迭代过程中删除元素？\n\n​      调用迭代器自身提供的remove()方法，进行删除元素，原理是在调用过程中，会更新modCount的值，不会触发快速失败。\n\n### 6、modCount 字段的作用是什么？\n\n​      modCount 是结构修改哨兵，任何有关修改数组的结构的操作都会导致modCount加1，包括添加元素，删除元素，但是替换元素不会导致modCount加1。当在迭代过程中，会先记录modCount的值，每次迭代调用next()方法都会对比是否相同，不相同直接抛出ConcurrantModificationException。多线程下，防止一个线程迭代，一个线程修改的情况，单线程中以最低的成本实现快速失败，防止数据不一致。\n\n### 7、快速失败 + 安全失败\n\n​    *快速失败*：通过检测集合的并发修改，及时抛出异常来避免潜在的逻辑错误。即：通过修改计数器 modCont 记录修改次数，当出现不一致的情况时，立即抛出 `ConcurrentModificationException` 异常。但它**不解决线程安全问题**，仅用于快速暴露问题。\n\n*安全失败*：例如 `CopyOnWriteArrayList` 在创建迭代器时，会生成当前集合的快照，遍历通过这个快照进行遍历。因此，当迭代过程中进行修改时，修改的结果不会影响快照的内容，导致迭代过程中无法感知集合的实时变化。适合读多写少、对实时性要求不高的场景。","source":"_posts/ArrayList集合.md","raw":"---\ntitle: ArrayList集合\ntags:\n  - ArrayList\ndescription: |\n  文章缩略，支持 `Markdown` **文档格式**\npinned: 0\nlang: zh\ncategories:\n  - Java 基础篇\ntype: post\nwordCount: 49\ncharCount: 1853\nimgCount: 0\nvidCount: 0\nwsCount: 0\ncbCount: 0\nreadTime: 约24秒\nabbrlink: 6ff8c531\ndate: 2025-10-27 22:25:43\n---\n### 1、ArrayList 的底层数据结构是什么？\n\n​      ArrayList 的底层数据结构是 Object 类型的 elementData 数组，该数组具有动态可扩容机制，即动态可扩容数组。该数组由 transient 修饰，标记为不可序列化，用来解决在数组序列化时，会将空元素也序列化的问题。同时实现了 writeObject 和 readObject 方法，来手动实现有效元素的序列化和反序列化。\n\n### 2、ArrayList 如何添加元素？扩容机制是什么？\n\n#####       1）添加元素：\n\n​            通过 add() 方法用来添加元素，而 add() 方法，实际上是调用内部私有的add() 方法，向elementData 数组中添加元素。\n\n#####       2）扩容机制：\n\n- 首先，检查数组当前的有效元素的数量是否等于elementData的总长度。\n    - 如果不相等，说明数组未满，则直接添加，并将size的大小加一。\n    - 如果相等，说明当前的空间已经用完，则进入gow()，并将扩容后的数组赋值给elementData数组，然后继续将元素放入，size的大小加一。\n        - 对于grow()方法，入参为最小扩容量，即扩容后的大小一定大于等于这个入参的值，具体的实现为，先获取到数组的整个长度，然后将数组的长度增加为原来的1.5倍后，与入参，即最小扩容量相比。\n            - 如果大于等于入参，那末直接用1.5倍的值作为新数组长度。\n            - 反之直接用最小扩容量最为新数组的长度。\n            - 最后调用Arrays的copy()方法，将数组进行扩容，而这个方法本质是调用底层的System.arraycopy的本地方法来进行数组的扩容。\n\n### 3、ArrayList 是否线程安全？如何解决？\n\n#####       1）线程安全：\n\n​           是非线程安全的，其根本原因是内部没有同步机制，所有的操作都是共享数组和计数器，关键操作并没有原子性。多线程模式下容易出现ConcurrentModificationException 等异常。\n\n#####       2）解决方案：\n\n​           ① 对于轻度并发场景，使用并发工具包Collections的SynchronizedList() 方法，构造线程安全的集合，原理就是通过包装器为所有的方法都加上Synchronized锁，但是，并发性能低，迭代时必须显示的加上锁，因为并发工具包只是为独立的方法加上了 Synchroized(mutex)，而迭代时的多个操作，涉及hasNext、next操作，这些组合操作本身并不是原子的，因此在迭代时，需要显示的加上锁。\n\n​           ② CopyOnWriteArrayList 适用于读多写少的情况，原理就是，在写操作时，复制整个数组，同时数组的长度加1，在新数组的最后位置加上一个元素，再用新数组替换旧数组。而在添加的过程中，在jdk 9 之前用的都是 ReentrantLook 锁，而在jdk 9 之后，用的就是Synchroized。\n\n​           ③ Vector，是线程安全的，原理就是每个方法都用 Synchroized 锁，但是性能较低，迭代器问题未解决。由于锁的力度比较粗，所有公共方法都被Synchroized 修饰，单线程每次调用都有锁的开销，而在多线程模式下，即使是读操作之间也会互斥，无法并发。并且默认扩容为原来的2倍，容易造成内存泄漏。同时迭代器也没有实现线程安全。\n\n​           ④ 手动同步。\n\n### 4、为什么ArrayList扩容为原来的1.5倍？\n\n​      扩容较大会有OOM以及内存浪费，扩容较小会有多次扩容，浪费性能。而1.5是在扩容频率适中，空间利用率最高的大小。\n\n### 5、如何在迭代过程中删除元素？\n\n​      调用迭代器自身提供的remove()方法，进行删除元素，原理是在调用过程中，会更新modCount的值，不会触发快速失败。\n\n### 6、modCount 字段的作用是什么？\n\n​      modCount 是结构修改哨兵，任何有关修改数组的结构的操作都会导致modCount加1，包括添加元素，删除元素，但是替换元素不会导致modCount加1。当在迭代过程中，会先记录modCount的值，每次迭代调用next()方法都会对比是否相同，不相同直接抛出ConcurrantModificationException。多线程下，防止一个线程迭代，一个线程修改的情况，单线程中以最低的成本实现快速失败，防止数据不一致。\n\n### 7、快速失败 + 安全失败\n\n​    *快速失败*：通过检测集合的并发修改，及时抛出异常来避免潜在的逻辑错误。即：通过修改计数器 modCont 记录修改次数，当出现不一致的情况时，立即抛出 `ConcurrentModificationException` 异常。但它**不解决线程安全问题**，仅用于快速暴露问题。\n\n*安全失败*：例如 `CopyOnWriteArrayList` 在创建迭代器时，会生成当前集合的快照，遍历通过这个快照进行遍历。因此，当迭代过程中进行修改时，修改的结果不会影响快照的内容，导致迭代过程中无法感知集合的实时变化。适合读多写少、对实时性要求不高的场景。","slug":"ArrayList集合","published":1,"updated":"2025-10-27T14:28:11.542Z","comments":1,"layout":"post","photos":[],"_id":"cuidVWHk18bODmiC7IMLz3-Ud","content":"<h3 id=\"1、ArrayList-的底层数据结构是什么？\"><a href=\"#1、ArrayList-的底层数据结构是什么？\" class=\"headerlink\" title=\"1、ArrayList 的底层数据结构是什么？\"></a>1、ArrayList 的底层数据结构是什么？</h3><p>​      ArrayList 的底层数据结构是 Object 类型的 elementData 数组，该数组具有动态可扩容机制，即动态可扩容数组。该数组由 transient 修饰，标记为不可序列化，用来解决在数组序列化时，会将空元素也序列化的问题。同时实现了 writeObject 和 readObject 方法，来手动实现有效元素的序列化和反序列化。</p>\n<h3 id=\"2、ArrayList-如何添加元素？扩容机制是什么？\"><a href=\"#2、ArrayList-如何添加元素？扩容机制是什么？\" class=\"headerlink\" title=\"2、ArrayList 如何添加元素？扩容机制是什么？\"></a>2、ArrayList 如何添加元素？扩容机制是什么？</h3><h5 id=\"1）添加元素：\"><a href=\"#1）添加元素：\" class=\"headerlink\" title=\"1）添加元素：\"></a>1）添加元素：</h5><p>​            通过 add() 方法用来添加元素，而 add() 方法，实际上是调用内部私有的add() 方法，向elementData 数组中添加元素。</p>\n<h5 id=\"2）扩容机制：\"><a href=\"#2）扩容机制：\" class=\"headerlink\" title=\"2）扩容机制：\"></a>2）扩容机制：</h5><ul>\n<li>首先，检查数组当前的有效元素的数量是否等于elementData的总长度。<ul>\n<li>如果不相等，说明数组未满，则直接添加，并将size的大小加一。</li>\n<li>如果相等，说明当前的空间已经用完，则进入gow()，并将扩容后的数组赋值给elementData数组，然后继续将元素放入，size的大小加一。<ul>\n<li>对于grow()方法，入参为最小扩容量，即扩容后的大小一定大于等于这个入参的值，具体的实现为，先获取到数组的整个长度，然后将数组的长度增加为原来的1.5倍后，与入参，即最小扩容量相比。<ul>\n<li>如果大于等于入参，那末直接用1.5倍的值作为新数组长度。</li>\n<li>反之直接用最小扩容量最为新数组的长度。</li>\n<li>最后调用Arrays的copy()方法，将数组进行扩容，而这个方法本质是调用底层的System.arraycopy的本地方法来进行数组的扩容。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3、ArrayList-是否线程安全？如何解决？\"><a href=\"#3、ArrayList-是否线程安全？如何解决？\" class=\"headerlink\" title=\"3、ArrayList 是否线程安全？如何解决？\"></a>3、ArrayList 是否线程安全？如何解决？</h3><h5 id=\"1）线程安全：\"><a href=\"#1）线程安全：\" class=\"headerlink\" title=\"1）线程安全：\"></a>1）线程安全：</h5><p>​           是非线程安全的，其根本原因是内部没有同步机制，所有的操作都是共享数组和计数器，关键操作并没有原子性。多线程模式下容易出现ConcurrentModificationException 等异常。</p>\n<h5 id=\"2）解决方案：\"><a href=\"#2）解决方案：\" class=\"headerlink\" title=\"2）解决方案：\"></a>2）解决方案：</h5><p>​           ① 对于轻度并发场景，使用并发工具包Collections的SynchronizedList() 方法，构造线程安全的集合，原理就是通过包装器为所有的方法都加上Synchronized锁，但是，并发性能低，迭代时必须显示的加上锁，因为并发工具包只是为独立的方法加上了 Synchroized(mutex)，而迭代时的多个操作，涉及hasNext、next操作，这些组合操作本身并不是原子的，因此在迭代时，需要显示的加上锁。</p>\n<p>​           ② CopyOnWriteArrayList 适用于读多写少的情况，原理就是，在写操作时，复制整个数组，同时数组的长度加1，在新数组的最后位置加上一个元素，再用新数组替换旧数组。而在添加的过程中，在jdk 9 之前用的都是 ReentrantLook 锁，而在jdk 9 之后，用的就是Synchroized。</p>\n<p>​           ③ Vector，是线程安全的，原理就是每个方法都用 Synchroized 锁，但是性能较低，迭代器问题未解决。由于锁的力度比较粗，所有公共方法都被Synchroized 修饰，单线程每次调用都有锁的开销，而在多线程模式下，即使是读操作之间也会互斥，无法并发。并且默认扩容为原来的2倍，容易造成内存泄漏。同时迭代器也没有实现线程安全。</p>\n<p>​           ④ 手动同步。</p>\n<h3 id=\"4、为什么ArrayList扩容为原来的1-5倍？\"><a href=\"#4、为什么ArrayList扩容为原来的1-5倍？\" class=\"headerlink\" title=\"4、为什么ArrayList扩容为原来的1.5倍？\"></a>4、为什么ArrayList扩容为原来的1.5倍？</h3><p>​      扩容较大会有OOM以及内存浪费，扩容较小会有多次扩容，浪费性能。而1.5是在扩容频率适中，空间利用率最高的大小。</p>\n<h3 id=\"5、如何在迭代过程中删除元素？\"><a href=\"#5、如何在迭代过程中删除元素？\" class=\"headerlink\" title=\"5、如何在迭代过程中删除元素？\"></a>5、如何在迭代过程中删除元素？</h3><p>​      调用迭代器自身提供的remove()方法，进行删除元素，原理是在调用过程中，会更新modCount的值，不会触发快速失败。</p>\n<h3 id=\"6、modCount-字段的作用是什么？\"><a href=\"#6、modCount-字段的作用是什么？\" class=\"headerlink\" title=\"6、modCount 字段的作用是什么？\"></a>6、modCount 字段的作用是什么？</h3><p>​      modCount 是结构修改哨兵，任何有关修改数组的结构的操作都会导致modCount加1，包括添加元素，删除元素，但是替换元素不会导致modCount加1。当在迭代过程中，会先记录modCount的值，每次迭代调用next()方法都会对比是否相同，不相同直接抛出ConcurrantModificationException。多线程下，防止一个线程迭代，一个线程修改的情况，单线程中以最低的成本实现快速失败，防止数据不一致。</p>\n<h3 id=\"7、快速失败-安全失败\"><a href=\"#7、快速失败-安全失败\" class=\"headerlink\" title=\"7、快速失败 + 安全失败\"></a>7、快速失败 + 安全失败</h3><p>​    <em>快速失败</em>：通过检测集合的并发修改，及时抛出异常来避免潜在的逻辑错误。即：通过修改计数器 modCont 记录修改次数，当出现不一致的情况时，立即抛出 <code>ConcurrentModificationException</code> 异常。但它<strong>不解决线程安全问题</strong>，仅用于快速暴露问题。</p>\n<p><em>安全失败</em>：例如 <code>CopyOnWriteArrayList</code> 在创建迭代器时，会生成当前集合的快照，遍历通过这个快照进行遍历。因此，当迭代过程中进行修改时，修改的结果不会影响快照的内容，导致迭代过程中无法感知集合的实时变化。适合读多写少、对实时性要求不高的场景。</p>\n","excerpt":"","more":"<h3 id=\"1、ArrayList-的底层数据结构是什么？\"><a href=\"#1、ArrayList-的底层数据结构是什么？\" class=\"headerlink\" title=\"1、ArrayList 的底层数据结构是什么？\"></a>1、ArrayList 的底层数据结构是什么？</h3><p>​      ArrayList 的底层数据结构是 Object 类型的 elementData 数组，该数组具有动态可扩容机制，即动态可扩容数组。该数组由 transient 修饰，标记为不可序列化，用来解决在数组序列化时，会将空元素也序列化的问题。同时实现了 writeObject 和 readObject 方法，来手动实现有效元素的序列化和反序列化。</p>\n<h3 id=\"2、ArrayList-如何添加元素？扩容机制是什么？\"><a href=\"#2、ArrayList-如何添加元素？扩容机制是什么？\" class=\"headerlink\" title=\"2、ArrayList 如何添加元素？扩容机制是什么？\"></a>2、ArrayList 如何添加元素？扩容机制是什么？</h3><h5 id=\"1）添加元素：\"><a href=\"#1）添加元素：\" class=\"headerlink\" title=\"1）添加元素：\"></a>1）添加元素：</h5><p>​            通过 add() 方法用来添加元素，而 add() 方法，实际上是调用内部私有的add() 方法，向elementData 数组中添加元素。</p>\n<h5 id=\"2）扩容机制：\"><a href=\"#2）扩容机制：\" class=\"headerlink\" title=\"2）扩容机制：\"></a>2）扩容机制：</h5><ul>\n<li>首先，检查数组当前的有效元素的数量是否等于elementData的总长度。<ul>\n<li>如果不相等，说明数组未满，则直接添加，并将size的大小加一。</li>\n<li>如果相等，说明当前的空间已经用完，则进入gow()，并将扩容后的数组赋值给elementData数组，然后继续将元素放入，size的大小加一。<ul>\n<li>对于grow()方法，入参为最小扩容量，即扩容后的大小一定大于等于这个入参的值，具体的实现为，先获取到数组的整个长度，然后将数组的长度增加为原来的1.5倍后，与入参，即最小扩容量相比。<ul>\n<li>如果大于等于入参，那末直接用1.5倍的值作为新数组长度。</li>\n<li>反之直接用最小扩容量最为新数组的长度。</li>\n<li>最后调用Arrays的copy()方法，将数组进行扩容，而这个方法本质是调用底层的System.arraycopy的本地方法来进行数组的扩容。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3、ArrayList-是否线程安全？如何解决？\"><a href=\"#3、ArrayList-是否线程安全？如何解决？\" class=\"headerlink\" title=\"3、ArrayList 是否线程安全？如何解决？\"></a>3、ArrayList 是否线程安全？如何解决？</h3><h5 id=\"1）线程安全：\"><a href=\"#1）线程安全：\" class=\"headerlink\" title=\"1）线程安全：\"></a>1）线程安全：</h5><p>​           是非线程安全的，其根本原因是内部没有同步机制，所有的操作都是共享数组和计数器，关键操作并没有原子性。多线程模式下容易出现ConcurrentModificationException 等异常。</p>\n<h5 id=\"2）解决方案：\"><a href=\"#2）解决方案：\" class=\"headerlink\" title=\"2）解决方案：\"></a>2）解决方案：</h5><p>​           ① 对于轻度并发场景，使用并发工具包Collections的SynchronizedList() 方法，构造线程安全的集合，原理就是通过包装器为所有的方法都加上Synchronized锁，但是，并发性能低，迭代时必须显示的加上锁，因为并发工具包只是为独立的方法加上了 Synchroized(mutex)，而迭代时的多个操作，涉及hasNext、next操作，这些组合操作本身并不是原子的，因此在迭代时，需要显示的加上锁。</p>\n<p>​           ② CopyOnWriteArrayList 适用于读多写少的情况，原理就是，在写操作时，复制整个数组，同时数组的长度加1，在新数组的最后位置加上一个元素，再用新数组替换旧数组。而在添加的过程中，在jdk 9 之前用的都是 ReentrantLook 锁，而在jdk 9 之后，用的就是Synchroized。</p>\n<p>​           ③ Vector，是线程安全的，原理就是每个方法都用 Synchroized 锁，但是性能较低，迭代器问题未解决。由于锁的力度比较粗，所有公共方法都被Synchroized 修饰，单线程每次调用都有锁的开销，而在多线程模式下，即使是读操作之间也会互斥，无法并发。并且默认扩容为原来的2倍，容易造成内存泄漏。同时迭代器也没有实现线程安全。</p>\n<p>​           ④ 手动同步。</p>\n<h3 id=\"4、为什么ArrayList扩容为原来的1-5倍？\"><a href=\"#4、为什么ArrayList扩容为原来的1-5倍？\" class=\"headerlink\" title=\"4、为什么ArrayList扩容为原来的1.5倍？\"></a>4、为什么ArrayList扩容为原来的1.5倍？</h3><p>​      扩容较大会有OOM以及内存浪费，扩容较小会有多次扩容，浪费性能。而1.5是在扩容频率适中，空间利用率最高的大小。</p>\n<h3 id=\"5、如何在迭代过程中删除元素？\"><a href=\"#5、如何在迭代过程中删除元素？\" class=\"headerlink\" title=\"5、如何在迭代过程中删除元素？\"></a>5、如何在迭代过程中删除元素？</h3><p>​      调用迭代器自身提供的remove()方法，进行删除元素，原理是在调用过程中，会更新modCount的值，不会触发快速失败。</p>\n<h3 id=\"6、modCount-字段的作用是什么？\"><a href=\"#6、modCount-字段的作用是什么？\" class=\"headerlink\" title=\"6、modCount 字段的作用是什么？\"></a>6、modCount 字段的作用是什么？</h3><p>​      modCount 是结构修改哨兵，任何有关修改数组的结构的操作都会导致modCount加1，包括添加元素，删除元素，但是替换元素不会导致modCount加1。当在迭代过程中，会先记录modCount的值，每次迭代调用next()方法都会对比是否相同，不相同直接抛出ConcurrantModificationException。多线程下，防止一个线程迭代，一个线程修改的情况，单线程中以最低的成本实现快速失败，防止数据不一致。</p>\n<h3 id=\"7、快速失败-安全失败\"><a href=\"#7、快速失败-安全失败\" class=\"headerlink\" title=\"7、快速失败 + 安全失败\"></a>7、快速失败 + 安全失败</h3><p>​    <em>快速失败</em>：通过检测集合的并发修改，及时抛出异常来避免潜在的逻辑错误。即：通过修改计数器 modCont 记录修改次数，当出现不一致的情况时，立即抛出 <code>ConcurrentModificationException</code> 异常。但它<strong>不解决线程安全问题</strong>，仅用于快速暴露问题。</p>\n<p><em>安全失败</em>：例如 <code>CopyOnWriteArrayList</code> 在创建迭代器时，会生成当前集合的快照，遍历通过这个快照进行遍历。因此，当迭代过程中进行修改时，修改的结果不会影响快照的内容，导致迭代过程中无法感知集合的实时变化。适合读多写少、对实时性要求不高的场景。</p>\n"},{"title":"HashMap集合","description":"文章缩略，支持 `Markdown` **文档格式**\n","pinned":0,"lang":"zh","type":"post","wordCount":377,"charCount":5024,"imgCount":0,"vidCount":0,"wsCount":0,"cbCount":2,"readTime":"约3分钟","abbrlink":"43ade6e4","date":"2025-10-27T14:26:27.000Z","_content":"### 1、HashMap 的底层数据结构是什么?\n\n​      在JDK 8 之前，主要通过数组 + 链表的方式实现。在JDK 8之后，主要通过数组 + 链表 + 红黑树的方式实现。核心变量为Node 类型的数组 table 变量。由 transient 修饰，并重写了readObject 和 writeObject 方法实现序列化相关操作。\n\n### 2、HashMap 是如何解决哈希冲突的?\n\n​      由于通过键哈希值的运算来确定元素在table中的位置，当出现不同键的哈希值相同时，会产生哈希冲突，主要通过链地址法来解决。也就是在数组对应的位置形成链表，而对于链表结点的插入采用的是尾插法，防止在多线程模式下出现循环链表的问题。\n\n### 3、HashMap 的 put 方法的过程\n\n- **首先**，是计算hash值，即：通过将键的hash值的低16异或上高16位。\n\n- **其次**，计算该元素在哈希桶中的位置，即：将数组的长度 - 1 & 上二次哈希值作为该元素在数组中的下标。\n\n- **然后**：判断下标位置的元素情况，即：\n\n    - 如果当前位置没有元素，则直接创建node对象并存储hash值，防止二次计算，然后将当前元素储存在当前下标的位置；\n\n    - 如果当前位置有元素，就以hash值、key的引用地址，key的equales方法的比较顺序来判断key是否相同；\n\n        - 如果有一个成立，则表示key值相同，即触发替换效果，将原位置的元素的value值替换为当前元素的value 值。\n\n        - 如果判断 key 不相同，（省略：就先判断是否为树结构，如果是）继续按照之前的比较顺序遍历整个链表。\n\n            - 当发现键相同时，也是执行替换操作。\n\n            - 当遍历到最后一个时，回在最后一个结点的尾部创建一个新的Node结点。（省略：并判断当前位置的链表的长度是否大于8，当大于 8 时，则尝试树形化，在树形化的内部，会判断哈希桶的长度是否大于64，如果不是，则直接扩容，否则进行树形化）\n\n- **最后**：都会检查size是否超过扩容阈值，如果超过，则进行扩容。而put方法的返回值是当发成替换时，返回的是旧值，发生插入时，返回的是原位置的值，也就是null。\n\n- 源码展示：\n\n  ```java\n  /*添加元素源码*/\n  final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) {\n          Node<K,V>[] tab; Node<K,V> p; int n, i;\n          if ((tab = table) == null || (n = tab.length) == 0) //判断是否需要扩容\n              n = (tab = resize()).length; //执行扩容\n          if ((p = tab[i = (n - 1) & hash]) == null)  //判断要插入的位置是否存在元素\n              tab[i] = newNode(hash, key, value, null); //如果不存在，直在该数组的该位置上添加\n          else { //该位置上存在元素，判断该元素的键是否与要插入的元素的键相同\n              Node<K,V> e; K k;\n              //1、先比较hash值，如果hash不相同，则键一定不相同\n              //2、再比较键\n              \t//1、先比较键的地址\n              \t//2、最后在比较键的内容\n              //最后得出，键是否相同\n              if (p.hash == hash \n                  && ((k = p.key) == key || (key != null && key.equals(k))))\n                  e = p; //如果键相同\n              else if (p instanceof TreeNode) //如果键不相同、判断是否为树形结构\n                  e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);//是树结构\n              else {  //如果键不相同、不为树形结构\n                  for (int binCount = 0; ; ++binCount) {\n                      if ((e = p.next) == null) { //判断下一个元素是否为空\n                          p.next = newNode(hash, key, value, null); //为空，尾插法\n                          if (binCount >= TREEIFY_THRESHOLD - 1) // 判断是否需要树形化\n                              treeifyBin(tab, hash); //执行树形化\n                          break;\n                      }\n                      //不为空，判断该位置上的链表的键是否相同，相同直接跳出循环做修改操作\n                      if (e.hash == hash &&\n                          ((k = e.key) == key || (key != null && key.equals(k))))\n                          break; \n                      p = e; //给 p 更新，继续比较\n                  }\n              }\n              if (e != null) { // 键相同、执行修改操作,如果是新增操作，e必为null\n                  V oldValue = e.value; //获取到该位置上的值\n                  if (!onlyIfAbsent || oldValue == null)\n                      e.value = value; //将该位置上的值替换为新的值\n                  afterNodeAccess(e);  \n                  return oldValue; //返回旧值\n              }\n          }\n          ++modCount;\n          if (++size > threshold) //元素个数记录+1，判断是否需要扩容\n              resize();  //执行扩容\n          afterNodeInsertion(evict);\n          return null;\n      }\n  ```\n\n\n\n### 4、HashMap的扩容机制？\n\n- 首先，是当哈希桶没有初始化或者哈希桶的长度为 0 时，进行初始化扩容。\n\n    - 即：设置默认的哈希桶的长度为16，扩容阈值是 12 由 数组长度×负载因子，负载因子默认是0.75。然后创建长度为16的node结点对象并赋值给哈希桶即可。\n- 然后，是当哈希桶中的元素个数大于了扩容阈值时会触发扩容机制。\n    - 首先，确定新数组的长度以及扩容阈值：新数组的长度为原来的**2倍**，扩容阈值也变为原来的**2倍**\n    - 然后，循环遍历原数组中所有非空元素\n        - 如果该元素没有形成链表，则直接用元素的hash值 & 上新数组的长度 - 1，作为在新数组中的位置。（这也就是哈希桶的长度为什么是 2 的幂次方，因为计算元素在哈希桶中的位置非常方便）\n        - 如果改元素的 next 指针不为空，则进行结点的迁移。\n            - 1）对于链表来说\n                - 首先定义高位链表和低位链表。\n                - 然后，循环遍历链表上的所有结点。对于链表上的结点按照哈希值与原数组的长度做 & 运算的结果是否为 0 ，分为地位链表和高位链表，进而重新分配地位链表和高位链表在数组中的位置来使元素分布均匀。具体的过程以高位链表为例：先判断高位链表的尾结点是否为空，如果为空则为头节点赋初始值，反之则为尾结点的next指针赋值，最后都要将当前遍历的结点赋值给尾结点。最后将低位链表插入到新哈希桶中与原下标相同的位置，而高位链表则插入到新哈希桶中原下标 + 原数组长度的位置。\n            - 2）对于红黑树，则是调用树分裂的方法，先将树分为两个链表，对于链表中元素个数小于等于 6 的，直接转换为链表，如果大于6，则进行树形化。\n\n- 源码展示：\n\n  ```java\n  /*扩容源码*/\n  final Node<K,V>[] resize() {\n          Node<K,V>[] oldTab = table; //将数组赋值给临时变量\n          int oldCap = (oldTab == null) ? 0 : oldTab.length; //获取数组的长度\n          int oldThr = threshold; //获取扩容的临界点\n          int newCap, newThr = 0; //定义新的长度和扩容的临界点\n          if (oldCap > 0) { //判断数组长度是否大于 0，更新临界点和数组长度\n              if (oldCap >= MAXIMUM_CAPACITY) { //判断是否超出最大容量\n                  threshold = Integer.MAX_VALUE;\n                  return oldTab; //如果超出了，就不扩容，直接返回\n              }\n              else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                       oldCap >= DEFAULT_INITIAL_CAPACITY) //将新的长度为原长度的 2 倍\n                  newThr = oldThr << 1; // 新的临界点为原来临界点的 2 倍\n          }\n          else if (oldThr > 0) // 初始容量置于阈值，用于应对自定义初始值\n              newCap = oldThr;\n          else {               // 零初始阈值表示使用默认值，用于处理默认情况\n              newCap = DEFAULT_INITIAL_CAPACITY; //默认长度为 16\n              newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n              //临界值为默认长度*加载因子\n          }\n          if (newThr == 0) { //用于应对自定义负载因子\n              float ft = (float)newCap * loadFactor;\n              newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                        (int)ft : Integer.MAX_VALUE);\n          }\n          threshold = newThr; //更新临界值\n          @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n          Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap]; //创建新的数组\n          table = newTab; //将原数组指向该新的长度的数组\n          if (oldTab != null) { //用于应对第一次添加的情况\n              //源码赋值hashMap的逻辑\n              for (int j = 0; j < oldCap; ++j) {\n                  Node<K,V> e;  //创建新的节点\n                  if ((e = oldTab[j]) != null) { //判断旧数组上该位置的节点是否为空\n                      oldTab[j] = null;\n                      if (e.next == null) //如果下一个节点为空，即：该位置上就一个元素\n                          newTab[e.hash & (newCap - 1)] = e; //计算在新数组中的位置并放入\n                      else if (e instanceof TreeNode) //如果下一个有元素，判断是否为树形\n                          ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                      else { // 是链表\n                          Node<K,V> loHead = null, loTail = null;\n                          Node<K,V> hiHead = null, hiTail = null;\n                          Node<K,V> next;\n                          do {\n                              next = e.next;\n                              if ((e.hash & oldCap) == 0) { \n                                  //判断是否需要移动，因为在计算位置时，e.hash & (oldCap-1)\n                                  //在增加为容量后，新的容量是2的倍数，因此，之后的位置是原来的二进制\n                                  //加 1，原 1111 先 10000 因此，只需要比较最高位的 1 是否影向\n                                  //而oldCap是2的倍数，因此只有一个1其余是0,16 = 0000 1000\n                                  //因此，如果取与不为0，说名根据hsah值计算的位置与原来的位置不一样\n                                  //需要移动，同样，只要是需要移动的，要移动的位置都一样，因为都是同一\n                                  //个高位二进制为 1\n                                  if (loTail == null)\n                                      loHead = e;\n                                  else\n                                      loTail.next = e;\n                                  loTail = e;\n                              }\n                              else {\n                                  if (hiTail == null)\n                                      hiHead = e;\n                                  else\n                                      hiTail.next = e;\n                                  hiTail = e;\n                              }\n                          } while ((e = next) != null);\n                          if (loTail != null) {  //将不需要移动的节点直接放入该数组下\n                              loTail.next = null;\n                              newTab[j] = loHead;\n                          }\n                          if (hiTail != null) { //将需要移动的链表放入新的数组的空间下\n                              hiTail.next = null;\n                              //由于需要移动，因此高位二进制一定是 1，因此用hash值于新数组计算后\n                              //位置是确定的，增加了oldCap的长度，故，这里不用再次计算为位置，直接用\n                              newTab[j + oldCap] = hiHead;\n                          }\n                      }\n                  }\n              }\n          }\n          return newTab;\n      }\n  ```\n\n\n\n### 5、为什么负载因子是0.75？\n\n​     因为是在时间和空间之间，经过大量计算和实验权衡后的一个最优值。在减少哈希冲突的同时，避免频繁的扩容。\n\n### 6、HashMap 是线程安全的吗？\n\n​      不是，可以用并发工具包的SynchroizedMap包装hashMap，或者直接使用CurrentHashMap。\n\n### 7、HashMapJDK8 和 JDK 7的区别\n\n​      数据结构：从数组 + 链表 ==》数组 + 链表 + 红黑树\n\n​      插入方式：头插法 ==》尾插法\n\n​      迁移原理：重新计算hash ==》按照高低位拆分\n\n### 8、HashMap的内存泄漏？\n\n​      若key对象重写了equels()方法，但是没有重写hashCode()方法，可能无法正确定位元素，造成内存占用不能释放。例如：对于放入两个键相同的对象，此时应表现为修改，但是由于没有重写hashCode()方法，导致hash值不同，而判断是先判断hash值，再判断equals()，因此此时表现为插入元素，而当利用键来删除其中的一个元素时，另一个元素则会被留下（因为哈希值不同），造成内存泄漏。\n\n### 9、key 的值可以为null吗？\n\n​      可以，null 键的hash固定为 0，会被放入列表的第一个位置。","source":"_posts/HashMap集合.md","raw":"---\ntitle: HashMap集合\ntags:\n  - HashMap\ndescription: |\n  文章缩略，支持 `Markdown` **文档格式**\npinned: 0\nlang: zh\ncategories:\n  - Java 基础篇\ntype: post\nwordCount: 377\ncharCount: 5024\nimgCount: 0\nvidCount: 0\nwsCount: 0\ncbCount: 2\nreadTime: 约3分钟\nabbrlink: 43ade6e4\ndate: 2025-10-27 22:26:27\n---\n### 1、HashMap 的底层数据结构是什么?\n\n​      在JDK 8 之前，主要通过数组 + 链表的方式实现。在JDK 8之后，主要通过数组 + 链表 + 红黑树的方式实现。核心变量为Node 类型的数组 table 变量。由 transient 修饰，并重写了readObject 和 writeObject 方法实现序列化相关操作。\n\n### 2、HashMap 是如何解决哈希冲突的?\n\n​      由于通过键哈希值的运算来确定元素在table中的位置，当出现不同键的哈希值相同时，会产生哈希冲突，主要通过链地址法来解决。也就是在数组对应的位置形成链表，而对于链表结点的插入采用的是尾插法，防止在多线程模式下出现循环链表的问题。\n\n### 3、HashMap 的 put 方法的过程\n\n- **首先**，是计算hash值，即：通过将键的hash值的低16异或上高16位。\n\n- **其次**，计算该元素在哈希桶中的位置，即：将数组的长度 - 1 & 上二次哈希值作为该元素在数组中的下标。\n\n- **然后**：判断下标位置的元素情况，即：\n\n    - 如果当前位置没有元素，则直接创建node对象并存储hash值，防止二次计算，然后将当前元素储存在当前下标的位置；\n\n    - 如果当前位置有元素，就以hash值、key的引用地址，key的equales方法的比较顺序来判断key是否相同；\n\n        - 如果有一个成立，则表示key值相同，即触发替换效果，将原位置的元素的value值替换为当前元素的value 值。\n\n        - 如果判断 key 不相同，（省略：就先判断是否为树结构，如果是）继续按照之前的比较顺序遍历整个链表。\n\n            - 当发现键相同时，也是执行替换操作。\n\n            - 当遍历到最后一个时，回在最后一个结点的尾部创建一个新的Node结点。（省略：并判断当前位置的链表的长度是否大于8，当大于 8 时，则尝试树形化，在树形化的内部，会判断哈希桶的长度是否大于64，如果不是，则直接扩容，否则进行树形化）\n\n- **最后**：都会检查size是否超过扩容阈值，如果超过，则进行扩容。而put方法的返回值是当发成替换时，返回的是旧值，发生插入时，返回的是原位置的值，也就是null。\n\n- 源码展示：\n\n  ```java\n  /*添加元素源码*/\n  final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) {\n          Node<K,V>[] tab; Node<K,V> p; int n, i;\n          if ((tab = table) == null || (n = tab.length) == 0) //判断是否需要扩容\n              n = (tab = resize()).length; //执行扩容\n          if ((p = tab[i = (n - 1) & hash]) == null)  //判断要插入的位置是否存在元素\n              tab[i] = newNode(hash, key, value, null); //如果不存在，直在该数组的该位置上添加\n          else { //该位置上存在元素，判断该元素的键是否与要插入的元素的键相同\n              Node<K,V> e; K k;\n              //1、先比较hash值，如果hash不相同，则键一定不相同\n              //2、再比较键\n              \t//1、先比较键的地址\n              \t//2、最后在比较键的内容\n              //最后得出，键是否相同\n              if (p.hash == hash \n                  && ((k = p.key) == key || (key != null && key.equals(k))))\n                  e = p; //如果键相同\n              else if (p instanceof TreeNode) //如果键不相同、判断是否为树形结构\n                  e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);//是树结构\n              else {  //如果键不相同、不为树形结构\n                  for (int binCount = 0; ; ++binCount) {\n                      if ((e = p.next) == null) { //判断下一个元素是否为空\n                          p.next = newNode(hash, key, value, null); //为空，尾插法\n                          if (binCount >= TREEIFY_THRESHOLD - 1) // 判断是否需要树形化\n                              treeifyBin(tab, hash); //执行树形化\n                          break;\n                      }\n                      //不为空，判断该位置上的链表的键是否相同，相同直接跳出循环做修改操作\n                      if (e.hash == hash &&\n                          ((k = e.key) == key || (key != null && key.equals(k))))\n                          break; \n                      p = e; //给 p 更新，继续比较\n                  }\n              }\n              if (e != null) { // 键相同、执行修改操作,如果是新增操作，e必为null\n                  V oldValue = e.value; //获取到该位置上的值\n                  if (!onlyIfAbsent || oldValue == null)\n                      e.value = value; //将该位置上的值替换为新的值\n                  afterNodeAccess(e);  \n                  return oldValue; //返回旧值\n              }\n          }\n          ++modCount;\n          if (++size > threshold) //元素个数记录+1，判断是否需要扩容\n              resize();  //执行扩容\n          afterNodeInsertion(evict);\n          return null;\n      }\n  ```\n\n\n\n### 4、HashMap的扩容机制？\n\n- 首先，是当哈希桶没有初始化或者哈希桶的长度为 0 时，进行初始化扩容。\n\n    - 即：设置默认的哈希桶的长度为16，扩容阈值是 12 由 数组长度×负载因子，负载因子默认是0.75。然后创建长度为16的node结点对象并赋值给哈希桶即可。\n- 然后，是当哈希桶中的元素个数大于了扩容阈值时会触发扩容机制。\n    - 首先，确定新数组的长度以及扩容阈值：新数组的长度为原来的**2倍**，扩容阈值也变为原来的**2倍**\n    - 然后，循环遍历原数组中所有非空元素\n        - 如果该元素没有形成链表，则直接用元素的hash值 & 上新数组的长度 - 1，作为在新数组中的位置。（这也就是哈希桶的长度为什么是 2 的幂次方，因为计算元素在哈希桶中的位置非常方便）\n        - 如果改元素的 next 指针不为空，则进行结点的迁移。\n            - 1）对于链表来说\n                - 首先定义高位链表和低位链表。\n                - 然后，循环遍历链表上的所有结点。对于链表上的结点按照哈希值与原数组的长度做 & 运算的结果是否为 0 ，分为地位链表和高位链表，进而重新分配地位链表和高位链表在数组中的位置来使元素分布均匀。具体的过程以高位链表为例：先判断高位链表的尾结点是否为空，如果为空则为头节点赋初始值，反之则为尾结点的next指针赋值，最后都要将当前遍历的结点赋值给尾结点。最后将低位链表插入到新哈希桶中与原下标相同的位置，而高位链表则插入到新哈希桶中原下标 + 原数组长度的位置。\n            - 2）对于红黑树，则是调用树分裂的方法，先将树分为两个链表，对于链表中元素个数小于等于 6 的，直接转换为链表，如果大于6，则进行树形化。\n\n- 源码展示：\n\n  ```java\n  /*扩容源码*/\n  final Node<K,V>[] resize() {\n          Node<K,V>[] oldTab = table; //将数组赋值给临时变量\n          int oldCap = (oldTab == null) ? 0 : oldTab.length; //获取数组的长度\n          int oldThr = threshold; //获取扩容的临界点\n          int newCap, newThr = 0; //定义新的长度和扩容的临界点\n          if (oldCap > 0) { //判断数组长度是否大于 0，更新临界点和数组长度\n              if (oldCap >= MAXIMUM_CAPACITY) { //判断是否超出最大容量\n                  threshold = Integer.MAX_VALUE;\n                  return oldTab; //如果超出了，就不扩容，直接返回\n              }\n              else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                       oldCap >= DEFAULT_INITIAL_CAPACITY) //将新的长度为原长度的 2 倍\n                  newThr = oldThr << 1; // 新的临界点为原来临界点的 2 倍\n          }\n          else if (oldThr > 0) // 初始容量置于阈值，用于应对自定义初始值\n              newCap = oldThr;\n          else {               // 零初始阈值表示使用默认值，用于处理默认情况\n              newCap = DEFAULT_INITIAL_CAPACITY; //默认长度为 16\n              newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n              //临界值为默认长度*加载因子\n          }\n          if (newThr == 0) { //用于应对自定义负载因子\n              float ft = (float)newCap * loadFactor;\n              newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                        (int)ft : Integer.MAX_VALUE);\n          }\n          threshold = newThr; //更新临界值\n          @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n          Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap]; //创建新的数组\n          table = newTab; //将原数组指向该新的长度的数组\n          if (oldTab != null) { //用于应对第一次添加的情况\n              //源码赋值hashMap的逻辑\n              for (int j = 0; j < oldCap; ++j) {\n                  Node<K,V> e;  //创建新的节点\n                  if ((e = oldTab[j]) != null) { //判断旧数组上该位置的节点是否为空\n                      oldTab[j] = null;\n                      if (e.next == null) //如果下一个节点为空，即：该位置上就一个元素\n                          newTab[e.hash & (newCap - 1)] = e; //计算在新数组中的位置并放入\n                      else if (e instanceof TreeNode) //如果下一个有元素，判断是否为树形\n                          ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                      else { // 是链表\n                          Node<K,V> loHead = null, loTail = null;\n                          Node<K,V> hiHead = null, hiTail = null;\n                          Node<K,V> next;\n                          do {\n                              next = e.next;\n                              if ((e.hash & oldCap) == 0) { \n                                  //判断是否需要移动，因为在计算位置时，e.hash & (oldCap-1)\n                                  //在增加为容量后，新的容量是2的倍数，因此，之后的位置是原来的二进制\n                                  //加 1，原 1111 先 10000 因此，只需要比较最高位的 1 是否影向\n                                  //而oldCap是2的倍数，因此只有一个1其余是0,16 = 0000 1000\n                                  //因此，如果取与不为0，说名根据hsah值计算的位置与原来的位置不一样\n                                  //需要移动，同样，只要是需要移动的，要移动的位置都一样，因为都是同一\n                                  //个高位二进制为 1\n                                  if (loTail == null)\n                                      loHead = e;\n                                  else\n                                      loTail.next = e;\n                                  loTail = e;\n                              }\n                              else {\n                                  if (hiTail == null)\n                                      hiHead = e;\n                                  else\n                                      hiTail.next = e;\n                                  hiTail = e;\n                              }\n                          } while ((e = next) != null);\n                          if (loTail != null) {  //将不需要移动的节点直接放入该数组下\n                              loTail.next = null;\n                              newTab[j] = loHead;\n                          }\n                          if (hiTail != null) { //将需要移动的链表放入新的数组的空间下\n                              hiTail.next = null;\n                              //由于需要移动，因此高位二进制一定是 1，因此用hash值于新数组计算后\n                              //位置是确定的，增加了oldCap的长度，故，这里不用再次计算为位置，直接用\n                              newTab[j + oldCap] = hiHead;\n                          }\n                      }\n                  }\n              }\n          }\n          return newTab;\n      }\n  ```\n\n\n\n### 5、为什么负载因子是0.75？\n\n​     因为是在时间和空间之间，经过大量计算和实验权衡后的一个最优值。在减少哈希冲突的同时，避免频繁的扩容。\n\n### 6、HashMap 是线程安全的吗？\n\n​      不是，可以用并发工具包的SynchroizedMap包装hashMap，或者直接使用CurrentHashMap。\n\n### 7、HashMapJDK8 和 JDK 7的区别\n\n​      数据结构：从数组 + 链表 ==》数组 + 链表 + 红黑树\n\n​      插入方式：头插法 ==》尾插法\n\n​      迁移原理：重新计算hash ==》按照高低位拆分\n\n### 8、HashMap的内存泄漏？\n\n​      若key对象重写了equels()方法，但是没有重写hashCode()方法，可能无法正确定位元素，造成内存占用不能释放。例如：对于放入两个键相同的对象，此时应表现为修改，但是由于没有重写hashCode()方法，导致hash值不同，而判断是先判断hash值，再判断equals()，因此此时表现为插入元素，而当利用键来删除其中的一个元素时，另一个元素则会被留下（因为哈希值不同），造成内存泄漏。\n\n### 9、key 的值可以为null吗？\n\n​      可以，null 键的hash固定为 0，会被放入列表的第一个位置。","slug":"HashMap集合","published":1,"updated":"2025-10-27T14:28:11.541Z","comments":1,"layout":"post","photos":[],"_id":"cuid2aw45v5G25xChVnwAHIiZ","content":"<h3 id=\"1、HashMap-的底层数据结构是什么\"><a href=\"#1、HashMap-的底层数据结构是什么\" class=\"headerlink\" title=\"1、HashMap 的底层数据结构是什么?\"></a>1、HashMap 的底层数据结构是什么?</h3><p>​      在JDK 8 之前，主要通过数组 + 链表的方式实现。在JDK 8之后，主要通过数组 + 链表 + 红黑树的方式实现。核心变量为Node 类型的数组 table 变量。由 transient 修饰，并重写了readObject 和 writeObject 方法实现序列化相关操作。</p>\n<h3 id=\"2、HashMap-是如何解决哈希冲突的\"><a href=\"#2、HashMap-是如何解决哈希冲突的\" class=\"headerlink\" title=\"2、HashMap 是如何解决哈希冲突的?\"></a>2、HashMap 是如何解决哈希冲突的?</h3><p>​      由于通过键哈希值的运算来确定元素在table中的位置，当出现不同键的哈希值相同时，会产生哈希冲突，主要通过链地址法来解决。也就是在数组对应的位置形成链表，而对于链表结点的插入采用的是尾插法，防止在多线程模式下出现循环链表的问题。</p>\n<h3 id=\"3、HashMap-的-put-方法的过程\"><a href=\"#3、HashMap-的-put-方法的过程\" class=\"headerlink\" title=\"3、HashMap 的 put 方法的过程\"></a>3、HashMap 的 put 方法的过程</h3><ul>\n<li><p><strong>首先</strong>，是计算hash值，即：通过将键的hash值的低16异或上高16位。</p>\n</li>\n<li><p><strong>其次</strong>，计算该元素在哈希桶中的位置，即：将数组的长度 - 1 &amp; 上二次哈希值作为该元素在数组中的下标。</p>\n</li>\n<li><p><strong>然后</strong>：判断下标位置的元素情况，即：</p>\n<ul>\n<li><p>如果当前位置没有元素，则直接创建node对象并存储hash值，防止二次计算，然后将当前元素储存在当前下标的位置；</p>\n</li>\n<li><p>如果当前位置有元素，就以hash值、key的引用地址，key的equales方法的比较顺序来判断key是否相同；</p>\n<ul>\n<li><p>如果有一个成立，则表示key值相同，即触发替换效果，将原位置的元素的value值替换为当前元素的value 值。</p>\n</li>\n<li><p>如果判断 key 不相同，（省略：就先判断是否为树结构，如果是）继续按照之前的比较顺序遍历整个链表。</p>\n<ul>\n<li><p>当发现键相同时，也是执行替换操作。</p>\n</li>\n<li><p>当遍历到最后一个时，回在最后一个结点的尾部创建一个新的Node结点。（省略：并判断当前位置的链表的长度是否大于8，当大于 8 时，则尝试树形化，在树形化的内部，会判断哈希桶的长度是否大于64，如果不是，则直接扩容，否则进行树形化）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>最后</strong>：都会检查size是否超过扩容阈值，如果超过，则进行扩容。而put方法的返回值是当发成替换时，返回的是旧值，发生插入时，返回的是原位置的值，也就是null。</p>\n</li>\n<li><p>源码展示：</p>\n<pre><code class=\"language-java\">/*添加元素源码*/\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) {\n        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;\n        if ((tab = table) == null || (n = tab.length) == 0) //判断是否需要扩容\n            n = (tab = resize()).length; //执行扩容\n        if ((p = tab[i = (n - 1) &amp; hash]) == null)  //判断要插入的位置是否存在元素\n            tab[i] = newNode(hash, key, value, null); //如果不存在，直在该数组的该位置上添加\n        else { //该位置上存在元素，判断该元素的键是否与要插入的元素的键相同\n            Node&lt;K,V&gt; e; K k;\n            //1、先比较hash值，如果hash不相同，则键一定不相同\n            //2、再比较键\n                //1、先比较键的地址\n                //2、最后在比较键的内容\n            //最后得出，键是否相同\n            if (p.hash == hash \n                &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))\n                e = p; //如果键相同\n            else if (p instanceof TreeNode) //如果键不相同、判断是否为树形结构\n                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);//是树结构\n            else {  //如果键不相同、不为树形结构\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) { //判断下一个元素是否为空\n                        p.next = newNode(hash, key, value, null); //为空，尾插法\n                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // 判断是否需要树形化\n                            treeifyBin(tab, hash); //执行树形化\n                        break;\n                    }\n                    //不为空，判断该位置上的链表的键是否相同，相同直接跳出循环做修改操作\n                    if (e.hash == hash &amp;&amp;\n                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n                        break; \n                    p = e; //给 p 更新，继续比较\n                }\n            }\n            if (e != null) { // 键相同、执行修改操作,如果是新增操作，e必为null\n                V oldValue = e.value; //获取到该位置上的值\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value; //将该位置上的值替换为新的值\n                afterNodeAccess(e);  \n                return oldValue; //返回旧值\n            }\n        }\n        ++modCount;\n        if (++size &gt; threshold) //元素个数记录+1，判断是否需要扩容\n            resize();  //执行扩容\n        afterNodeInsertion(evict);\n        return null;\n    }\n</code></pre>\n</li>\n</ul>\n<h3 id=\"4、HashMap的扩容机制？\"><a href=\"#4、HashMap的扩容机制？\" class=\"headerlink\" title=\"4、HashMap的扩容机制？\"></a>4、HashMap的扩容机制？</h3><ul>\n<li><p>首先，是当哈希桶没有初始化或者哈希桶的长度为 0 时，进行初始化扩容。</p>\n<ul>\n<li>即：设置默认的哈希桶的长度为16，扩容阈值是 12 由 数组长度×负载因子，负载因子默认是0.75。然后创建长度为16的node结点对象并赋值给哈希桶即可。</li>\n</ul>\n</li>\n<li><p>然后，是当哈希桶中的元素个数大于了扩容阈值时会触发扩容机制。</p>\n<ul>\n<li>首先，确定新数组的长度以及扩容阈值：新数组的长度为原来的<strong>2倍</strong>，扩容阈值也变为原来的<strong>2倍</strong></li>\n<li>然后，循环遍历原数组中所有非空元素<ul>\n<li>如果该元素没有形成链表，则直接用元素的hash值 &amp; 上新数组的长度 - 1，作为在新数组中的位置。（这也就是哈希桶的长度为什么是 2 的幂次方，因为计算元素在哈希桶中的位置非常方便）</li>\n<li>如果改元素的 next 指针不为空，则进行结点的迁移。<ul>\n<li>1）对于链表来说<ul>\n<li>首先定义高位链表和低位链表。</li>\n<li>然后，循环遍历链表上的所有结点。对于链表上的结点按照哈希值与原数组的长度做 &amp; 运算的结果是否为 0 ，分为地位链表和高位链表，进而重新分配地位链表和高位链表在数组中的位置来使元素分布均匀。具体的过程以高位链表为例：先判断高位链表的尾结点是否为空，如果为空则为头节点赋初始值，反之则为尾结点的next指针赋值，最后都要将当前遍历的结点赋值给尾结点。最后将低位链表插入到新哈希桶中与原下标相同的位置，而高位链表则插入到新哈希桶中原下标 + 原数组长度的位置。</li>\n</ul>\n</li>\n<li>2）对于红黑树，则是调用树分裂的方法，先将树分为两个链表，对于链表中元素个数小于等于 6 的，直接转换为链表，如果大于6，则进行树形化。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>源码展示：</p>\n<pre><code class=\"language-java\">/*扩容源码*/\nfinal Node&lt;K,V&gt;[] resize() {\n        Node&lt;K,V&gt;[] oldTab = table; //将数组赋值给临时变量\n        int oldCap = (oldTab == null) ? 0 : oldTab.length; //获取数组的长度\n        int oldThr = threshold; //获取扩容的临界点\n        int newCap, newThr = 0; //定义新的长度和扩容的临界点\n        if (oldCap &gt; 0) { //判断数组长度是否大于 0，更新临界点和数组长度\n            if (oldCap &gt;= MAXIMUM_CAPACITY) { //判断是否超出最大容量\n                threshold = Integer.MAX_VALUE;\n                return oldTab; //如果超出了，就不扩容，直接返回\n            }\n            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;\n                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY) //将新的长度为原长度的 2 倍\n                newThr = oldThr &lt;&lt; 1; // 新的临界点为原来临界点的 2 倍\n        }\n        else if (oldThr &gt; 0) // 初始容量置于阈值，用于应对自定义初始值\n            newCap = oldThr;\n        else {               // 零初始阈值表示使用默认值，用于处理默认情况\n            newCap = DEFAULT_INITIAL_CAPACITY; //默认长度为 16\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n            //临界值为默认长度*加载因子\n        }\n        if (newThr == 0) { //用于应对自定义负载因子\n            float ft = (float)newCap * loadFactor;\n            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE);\n        }\n        threshold = newThr; //更新临界值\n        @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})\n        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; //创建新的数组\n        table = newTab; //将原数组指向该新的长度的数组\n        if (oldTab != null) { //用于应对第一次添加的情况\n            //源码赋值hashMap的逻辑\n            for (int j = 0; j &lt; oldCap; ++j) {\n                Node&lt;K,V&gt; e;  //创建新的节点\n                if ((e = oldTab[j]) != null) { //判断旧数组上该位置的节点是否为空\n                    oldTab[j] = null;\n                    if (e.next == null) //如果下一个节点为空，即：该位置上就一个元素\n                        newTab[e.hash &amp; (newCap - 1)] = e; //计算在新数组中的位置并放入\n                    else if (e instanceof TreeNode) //如果下一个有元素，判断是否为树形\n                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);\n                    else { // 是链表\n                        Node&lt;K,V&gt; loHead = null, loTail = null;\n                        Node&lt;K,V&gt; hiHead = null, hiTail = null;\n                        Node&lt;K,V&gt; next;\n                        do {\n                            next = e.next;\n                            if ((e.hash &amp; oldCap) == 0) { \n                                //判断是否需要移动，因为在计算位置时，e.hash &amp; (oldCap-1)\n                                //在增加为容量后，新的容量是2的倍数，因此，之后的位置是原来的二进制\n                                //加 1，原 1111 先 10000 因此，只需要比较最高位的 1 是否影向\n                                //而oldCap是2的倍数，因此只有一个1其余是0,16 = 0000 1000\n                                //因此，如果取与不为0，说名根据hsah值计算的位置与原来的位置不一样\n                                //需要移动，同样，只要是需要移动的，要移动的位置都一样，因为都是同一\n                                //个高位二进制为 1\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            }\n                            else {\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            }\n                        } while ((e = next) != null);\n                        if (loTail != null) {  //将不需要移动的节点直接放入该数组下\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        }\n                        if (hiTail != null) { //将需要移动的链表放入新的数组的空间下\n                            hiTail.next = null;\n                            //由于需要移动，因此高位二进制一定是 1，因此用hash值于新数组计算后\n                            //位置是确定的，增加了oldCap的长度，故，这里不用再次计算为位置，直接用\n                            newTab[j + oldCap] = hiHead;\n                        }\n                    }\n                }\n            }\n        }\n        return newTab;\n    }\n</code></pre>\n</li>\n</ul>\n<h3 id=\"5、为什么负载因子是0-75？\"><a href=\"#5、为什么负载因子是0-75？\" class=\"headerlink\" title=\"5、为什么负载因子是0.75？\"></a>5、为什么负载因子是0.75？</h3><p>​     因为是在时间和空间之间，经过大量计算和实验权衡后的一个最优值。在减少哈希冲突的同时，避免频繁的扩容。</p>\n<h3 id=\"6、HashMap-是线程安全的吗？\"><a href=\"#6、HashMap-是线程安全的吗？\" class=\"headerlink\" title=\"6、HashMap 是线程安全的吗？\"></a>6、HashMap 是线程安全的吗？</h3><p>​      不是，可以用并发工具包的SynchroizedMap包装hashMap，或者直接使用CurrentHashMap。</p>\n<h3 id=\"7、HashMapJDK8-和-JDK-7的区别\"><a href=\"#7、HashMapJDK8-和-JDK-7的区别\" class=\"headerlink\" title=\"7、HashMapJDK8 和 JDK 7的区别\"></a>7、HashMapJDK8 和 JDK 7的区别</h3><p>​      数据结构：从数组 + 链表 &#x3D;&#x3D;》数组 + 链表 + 红黑树</p>\n<p>​      插入方式：头插法 &#x3D;&#x3D;》尾插法</p>\n<p>​      迁移原理：重新计算hash &#x3D;&#x3D;》按照高低位拆分</p>\n<h3 id=\"8、HashMap的内存泄漏？\"><a href=\"#8、HashMap的内存泄漏？\" class=\"headerlink\" title=\"8、HashMap的内存泄漏？\"></a>8、HashMap的内存泄漏？</h3><p>​      若key对象重写了equels()方法，但是没有重写hashCode()方法，可能无法正确定位元素，造成内存占用不能释放。例如：对于放入两个键相同的对象，此时应表现为修改，但是由于没有重写hashCode()方法，导致hash值不同，而判断是先判断hash值，再判断equals()，因此此时表现为插入元素，而当利用键来删除其中的一个元素时，另一个元素则会被留下（因为哈希值不同），造成内存泄漏。</p>\n<h3 id=\"9、key-的值可以为null吗？\"><a href=\"#9、key-的值可以为null吗？\" class=\"headerlink\" title=\"9、key 的值可以为null吗？\"></a>9、key 的值可以为null吗？</h3><p>​      可以，null 键的hash固定为 0，会被放入列表的第一个位置。</p>\n","excerpt":"","more":"<h3 id=\"1、HashMap-的底层数据结构是什么\"><a href=\"#1、HashMap-的底层数据结构是什么\" class=\"headerlink\" title=\"1、HashMap 的底层数据结构是什么?\"></a>1、HashMap 的底层数据结构是什么?</h3><p>​      在JDK 8 之前，主要通过数组 + 链表的方式实现。在JDK 8之后，主要通过数组 + 链表 + 红黑树的方式实现。核心变量为Node 类型的数组 table 变量。由 transient 修饰，并重写了readObject 和 writeObject 方法实现序列化相关操作。</p>\n<h3 id=\"2、HashMap-是如何解决哈希冲突的\"><a href=\"#2、HashMap-是如何解决哈希冲突的\" class=\"headerlink\" title=\"2、HashMap 是如何解决哈希冲突的?\"></a>2、HashMap 是如何解决哈希冲突的?</h3><p>​      由于通过键哈希值的运算来确定元素在table中的位置，当出现不同键的哈希值相同时，会产生哈希冲突，主要通过链地址法来解决。也就是在数组对应的位置形成链表，而对于链表结点的插入采用的是尾插法，防止在多线程模式下出现循环链表的问题。</p>\n<h3 id=\"3、HashMap-的-put-方法的过程\"><a href=\"#3、HashMap-的-put-方法的过程\" class=\"headerlink\" title=\"3、HashMap 的 put 方法的过程\"></a>3、HashMap 的 put 方法的过程</h3><ul>\n<li><p><strong>首先</strong>，是计算hash值，即：通过将键的hash值的低16异或上高16位。</p>\n</li>\n<li><p><strong>其次</strong>，计算该元素在哈希桶中的位置，即：将数组的长度 - 1 &amp; 上二次哈希值作为该元素在数组中的下标。</p>\n</li>\n<li><p><strong>然后</strong>：判断下标位置的元素情况，即：</p>\n<ul>\n<li><p>如果当前位置没有元素，则直接创建node对象并存储hash值，防止二次计算，然后将当前元素储存在当前下标的位置；</p>\n</li>\n<li><p>如果当前位置有元素，就以hash值、key的引用地址，key的equales方法的比较顺序来判断key是否相同；</p>\n<ul>\n<li><p>如果有一个成立，则表示key值相同，即触发替换效果，将原位置的元素的value值替换为当前元素的value 值。</p>\n</li>\n<li><p>如果判断 key 不相同，（省略：就先判断是否为树结构，如果是）继续按照之前的比较顺序遍历整个链表。</p>\n<ul>\n<li><p>当发现键相同时，也是执行替换操作。</p>\n</li>\n<li><p>当遍历到最后一个时，回在最后一个结点的尾部创建一个新的Node结点。（省略：并判断当前位置的链表的长度是否大于8，当大于 8 时，则尝试树形化，在树形化的内部，会判断哈希桶的长度是否大于64，如果不是，则直接扩容，否则进行树形化）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>最后</strong>：都会检查size是否超过扩容阈值，如果超过，则进行扩容。而put方法的返回值是当发成替换时，返回的是旧值，发生插入时，返回的是原位置的值，也就是null。</p>\n</li>\n<li><p>源码展示：</p>\n<pre><code class=\"language-java\">/*添加元素源码*/\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) {\n        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;\n        if ((tab = table) == null || (n = tab.length) == 0) //判断是否需要扩容\n            n = (tab = resize()).length; //执行扩容\n        if ((p = tab[i = (n - 1) &amp; hash]) == null)  //判断要插入的位置是否存在元素\n            tab[i] = newNode(hash, key, value, null); //如果不存在，直在该数组的该位置上添加\n        else { //该位置上存在元素，判断该元素的键是否与要插入的元素的键相同\n            Node&lt;K,V&gt; e; K k;\n            //1、先比较hash值，如果hash不相同，则键一定不相同\n            //2、再比较键\n                //1、先比较键的地址\n                //2、最后在比较键的内容\n            //最后得出，键是否相同\n            if (p.hash == hash \n                &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))\n                e = p; //如果键相同\n            else if (p instanceof TreeNode) //如果键不相同、判断是否为树形结构\n                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);//是树结构\n            else {  //如果键不相同、不为树形结构\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) { //判断下一个元素是否为空\n                        p.next = newNode(hash, key, value, null); //为空，尾插法\n                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // 判断是否需要树形化\n                            treeifyBin(tab, hash); //执行树形化\n                        break;\n                    }\n                    //不为空，判断该位置上的链表的键是否相同，相同直接跳出循环做修改操作\n                    if (e.hash == hash &amp;&amp;\n                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n                        break; \n                    p = e; //给 p 更新，继续比较\n                }\n            }\n            if (e != null) { // 键相同、执行修改操作,如果是新增操作，e必为null\n                V oldValue = e.value; //获取到该位置上的值\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value; //将该位置上的值替换为新的值\n                afterNodeAccess(e);  \n                return oldValue; //返回旧值\n            }\n        }\n        ++modCount;\n        if (++size &gt; threshold) //元素个数记录+1，判断是否需要扩容\n            resize();  //执行扩容\n        afterNodeInsertion(evict);\n        return null;\n    }\n</code></pre>\n</li>\n</ul>\n<h3 id=\"4、HashMap的扩容机制？\"><a href=\"#4、HashMap的扩容机制？\" class=\"headerlink\" title=\"4、HashMap的扩容机制？\"></a>4、HashMap的扩容机制？</h3><ul>\n<li><p>首先，是当哈希桶没有初始化或者哈希桶的长度为 0 时，进行初始化扩容。</p>\n<ul>\n<li>即：设置默认的哈希桶的长度为16，扩容阈值是 12 由 数组长度×负载因子，负载因子默认是0.75。然后创建长度为16的node结点对象并赋值给哈希桶即可。</li>\n</ul>\n</li>\n<li><p>然后，是当哈希桶中的元素个数大于了扩容阈值时会触发扩容机制。</p>\n<ul>\n<li>首先，确定新数组的长度以及扩容阈值：新数组的长度为原来的<strong>2倍</strong>，扩容阈值也变为原来的<strong>2倍</strong></li>\n<li>然后，循环遍历原数组中所有非空元素<ul>\n<li>如果该元素没有形成链表，则直接用元素的hash值 &amp; 上新数组的长度 - 1，作为在新数组中的位置。（这也就是哈希桶的长度为什么是 2 的幂次方，因为计算元素在哈希桶中的位置非常方便）</li>\n<li>如果改元素的 next 指针不为空，则进行结点的迁移。<ul>\n<li>1）对于链表来说<ul>\n<li>首先定义高位链表和低位链表。</li>\n<li>然后，循环遍历链表上的所有结点。对于链表上的结点按照哈希值与原数组的长度做 &amp; 运算的结果是否为 0 ，分为地位链表和高位链表，进而重新分配地位链表和高位链表在数组中的位置来使元素分布均匀。具体的过程以高位链表为例：先判断高位链表的尾结点是否为空，如果为空则为头节点赋初始值，反之则为尾结点的next指针赋值，最后都要将当前遍历的结点赋值给尾结点。最后将低位链表插入到新哈希桶中与原下标相同的位置，而高位链表则插入到新哈希桶中原下标 + 原数组长度的位置。</li>\n</ul>\n</li>\n<li>2）对于红黑树，则是调用树分裂的方法，先将树分为两个链表，对于链表中元素个数小于等于 6 的，直接转换为链表，如果大于6，则进行树形化。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>源码展示：</p>\n<pre><code class=\"language-java\">/*扩容源码*/\nfinal Node&lt;K,V&gt;[] resize() {\n        Node&lt;K,V&gt;[] oldTab = table; //将数组赋值给临时变量\n        int oldCap = (oldTab == null) ? 0 : oldTab.length; //获取数组的长度\n        int oldThr = threshold; //获取扩容的临界点\n        int newCap, newThr = 0; //定义新的长度和扩容的临界点\n        if (oldCap &gt; 0) { //判断数组长度是否大于 0，更新临界点和数组长度\n            if (oldCap &gt;= MAXIMUM_CAPACITY) { //判断是否超出最大容量\n                threshold = Integer.MAX_VALUE;\n                return oldTab; //如果超出了，就不扩容，直接返回\n            }\n            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;\n                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY) //将新的长度为原长度的 2 倍\n                newThr = oldThr &lt;&lt; 1; // 新的临界点为原来临界点的 2 倍\n        }\n        else if (oldThr &gt; 0) // 初始容量置于阈值，用于应对自定义初始值\n            newCap = oldThr;\n        else {               // 零初始阈值表示使用默认值，用于处理默认情况\n            newCap = DEFAULT_INITIAL_CAPACITY; //默认长度为 16\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n            //临界值为默认长度*加载因子\n        }\n        if (newThr == 0) { //用于应对自定义负载因子\n            float ft = (float)newCap * loadFactor;\n            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE);\n        }\n        threshold = newThr; //更新临界值\n        @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})\n        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; //创建新的数组\n        table = newTab; //将原数组指向该新的长度的数组\n        if (oldTab != null) { //用于应对第一次添加的情况\n            //源码赋值hashMap的逻辑\n            for (int j = 0; j &lt; oldCap; ++j) {\n                Node&lt;K,V&gt; e;  //创建新的节点\n                if ((e = oldTab[j]) != null) { //判断旧数组上该位置的节点是否为空\n                    oldTab[j] = null;\n                    if (e.next == null) //如果下一个节点为空，即：该位置上就一个元素\n                        newTab[e.hash &amp; (newCap - 1)] = e; //计算在新数组中的位置并放入\n                    else if (e instanceof TreeNode) //如果下一个有元素，判断是否为树形\n                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);\n                    else { // 是链表\n                        Node&lt;K,V&gt; loHead = null, loTail = null;\n                        Node&lt;K,V&gt; hiHead = null, hiTail = null;\n                        Node&lt;K,V&gt; next;\n                        do {\n                            next = e.next;\n                            if ((e.hash &amp; oldCap) == 0) { \n                                //判断是否需要移动，因为在计算位置时，e.hash &amp; (oldCap-1)\n                                //在增加为容量后，新的容量是2的倍数，因此，之后的位置是原来的二进制\n                                //加 1，原 1111 先 10000 因此，只需要比较最高位的 1 是否影向\n                                //而oldCap是2的倍数，因此只有一个1其余是0,16 = 0000 1000\n                                //因此，如果取与不为0，说名根据hsah值计算的位置与原来的位置不一样\n                                //需要移动，同样，只要是需要移动的，要移动的位置都一样，因为都是同一\n                                //个高位二进制为 1\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            }\n                            else {\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            }\n                        } while ((e = next) != null);\n                        if (loTail != null) {  //将不需要移动的节点直接放入该数组下\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        }\n                        if (hiTail != null) { //将需要移动的链表放入新的数组的空间下\n                            hiTail.next = null;\n                            //由于需要移动，因此高位二进制一定是 1，因此用hash值于新数组计算后\n                            //位置是确定的，增加了oldCap的长度，故，这里不用再次计算为位置，直接用\n                            newTab[j + oldCap] = hiHead;\n                        }\n                    }\n                }\n            }\n        }\n        return newTab;\n    }\n</code></pre>\n</li>\n</ul>\n<h3 id=\"5、为什么负载因子是0-75？\"><a href=\"#5、为什么负载因子是0-75？\" class=\"headerlink\" title=\"5、为什么负载因子是0.75？\"></a>5、为什么负载因子是0.75？</h3><p>​     因为是在时间和空间之间，经过大量计算和实验权衡后的一个最优值。在减少哈希冲突的同时，避免频繁的扩容。</p>\n<h3 id=\"6、HashMap-是线程安全的吗？\"><a href=\"#6、HashMap-是线程安全的吗？\" class=\"headerlink\" title=\"6、HashMap 是线程安全的吗？\"></a>6、HashMap 是线程安全的吗？</h3><p>​      不是，可以用并发工具包的SynchroizedMap包装hashMap，或者直接使用CurrentHashMap。</p>\n<h3 id=\"7、HashMapJDK8-和-JDK-7的区别\"><a href=\"#7、HashMapJDK8-和-JDK-7的区别\" class=\"headerlink\" title=\"7、HashMapJDK8 和 JDK 7的区别\"></a>7、HashMapJDK8 和 JDK 7的区别</h3><p>​      数据结构：从数组 + 链表 &#x3D;&#x3D;》数组 + 链表 + 红黑树</p>\n<p>​      插入方式：头插法 &#x3D;&#x3D;》尾插法</p>\n<p>​      迁移原理：重新计算hash &#x3D;&#x3D;》按照高低位拆分</p>\n<h3 id=\"8、HashMap的内存泄漏？\"><a href=\"#8、HashMap的内存泄漏？\" class=\"headerlink\" title=\"8、HashMap的内存泄漏？\"></a>8、HashMap的内存泄漏？</h3><p>​      若key对象重写了equels()方法，但是没有重写hashCode()方法，可能无法正确定位元素，造成内存占用不能释放。例如：对于放入两个键相同的对象，此时应表现为修改，但是由于没有重写hashCode()方法，导致hash值不同，而判断是先判断hash值，再判断equals()，因此此时表现为插入元素，而当利用键来删除其中的一个元素时，另一个元素则会被留下（因为哈希值不同），造成内存泄漏。</p>\n<h3 id=\"9、key-的值可以为null吗？\"><a href=\"#9、key-的值可以为null吗？\" class=\"headerlink\" title=\"9、key 的值可以为null吗？\"></a>9、key 的值可以为null吗？</h3><p>​      可以，null 键的hash固定为 0，会被放入列表的第一个位置。</p>\n"},{"title":"测试文章01","description":"文章缩略，支持 `Markdown` **文档格式**\n","pinned":0,"lang":"zh","type":"post","abbrlink":"55755352","wordCount":49,"charCount":497,"imgCount":0,"vidCount":0,"wsCount":1,"cbCount":1,"readTime":"约32秒","date":"2025-10-18T13:05:32.000Z","_content":"\n# 算法\n\n## 一、平方剩余和\n\n> 主要用于快速的判断两个数的乘积是否为完全平方数。\n> 如果平方剩余和相等，则两个数的乘积是完全平方数。\n\n```java\nimport java.util.HashSet;\nclass Solution {\n    // 平方剩余和 的预处理\n    static int[] core = new int[1010];\n    static int limit = 1000;\n    static {\n        // 求 1~1000 的所有数的平方剩余和\n        for(int i = 1;i <= limit;i++) {\n            if(core[i] == 0) {\n                // 说明没有被计算过\n                for(int j = 1;i*j*j <= limit;j++) {\n                    core[i*j*j] = i;\n                }\n            }\n        }\n    }\n\n    // 验证，平方剩余和 时，两个数的乘积为完全平方数\n    public static void main(String[] args) {\n        for(int i = 1;i <= 1000;i++) {\n            for(int j = i + 1;j <= 1000;j++) {\n                if(core[i] == core[j]) {\n                    System.out.println((i * j) + \" == \" + (String.format(\"%.0f\",Math.sqrt(i * j))) + \"^2\");\n                }\n            }\n        }\n    }\n}\n```","source":"_posts/测试文章01.md","raw":"---\ntitle: 测试文章01\ntags: \n  - 测试\ndescription: |\n  文章缩略，支持 `Markdown` **文档格式**\npinned: 0\nlang: zh\ncategories:\n  - 测试\ntype: post\nabbrlink: '55755352'\nwordCount: 49\ncharCount: 497\nimgCount: 0\nvidCount: 0\nwsCount: 1\ncbCount: 1\nreadTime: 约32秒\ndate: 2025-10-18 21:05:32\n---\n\n# 算法\n\n## 一、平方剩余和\n\n> 主要用于快速的判断两个数的乘积是否为完全平方数。\n> 如果平方剩余和相等，则两个数的乘积是完全平方数。\n\n```java\nimport java.util.HashSet;\nclass Solution {\n    // 平方剩余和 的预处理\n    static int[] core = new int[1010];\n    static int limit = 1000;\n    static {\n        // 求 1~1000 的所有数的平方剩余和\n        for(int i = 1;i <= limit;i++) {\n            if(core[i] == 0) {\n                // 说明没有被计算过\n                for(int j = 1;i*j*j <= limit;j++) {\n                    core[i*j*j] = i;\n                }\n            }\n        }\n    }\n\n    // 验证，平方剩余和 时，两个数的乘积为完全平方数\n    public static void main(String[] args) {\n        for(int i = 1;i <= 1000;i++) {\n            for(int j = i + 1;j <= 1000;j++) {\n                if(core[i] == core[j]) {\n                    System.out.println((i * j) + \" == \" + (String.format(\"%.0f\",Math.sqrt(i * j))) + \"^2\");\n                }\n            }\n        }\n    }\n}\n```","slug":"测试文章01","published":1,"updated":"2025-10-27T02:43:43.027Z","comments":1,"layout":"post","photos":[],"_id":"cuidmGKQKXL0y_KNgGCaVpCeE","content":"<h1 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h1><h2 id=\"一、平方剩余和\"><a href=\"#一、平方剩余和\" class=\"headerlink\" title=\"一、平方剩余和\"></a>一、平方剩余和</h2><blockquote>\n<p>主要用于快速的判断两个数的乘积是否为完全平方数。<br>如果平方剩余和相等，则两个数的乘积是完全平方数。</p>\n</blockquote>\n<pre><code class=\"language-java\">import java.util.HashSet;\nclass Solution {\n    // 平方剩余和 的预处理\n    static int[] core = new int[1010];\n    static int limit = 1000;\n    static {\n        // 求 1~1000 的所有数的平方剩余和\n        for(int i = 1;i &lt;= limit;i++) {\n            if(core[i] == 0) {\n                // 说明没有被计算过\n                for(int j = 1;i*j*j &lt;= limit;j++) {\n                    core[i*j*j] = i;\n                }\n            }\n        }\n    }\n\n    // 验证，平方剩余和 时，两个数的乘积为完全平方数\n    public static void main(String[] args) {\n        for(int i = 1;i &lt;= 1000;i++) {\n            for(int j = i + 1;j &lt;= 1000;j++) {\n                if(core[i] == core[j]) {\n                    System.out.println((i * j) + &quot; == &quot; + (String.format(&quot;%.0f&quot;,Math.sqrt(i * j))) + &quot;^2&quot;);\n                }\n            }\n        }\n    }\n}\n</code></pre>\n","excerpt":"","more":"<h1 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h1><h2 id=\"一、平方剩余和\"><a href=\"#一、平方剩余和\" class=\"headerlink\" title=\"一、平方剩余和\"></a>一、平方剩余和</h2><blockquote>\n<p>主要用于快速的判断两个数的乘积是否为完全平方数。<br>如果平方剩余和相等，则两个数的乘积是完全平方数。</p>\n</blockquote>\n<pre><code class=\"language-java\">import java.util.HashSet;\nclass Solution {\n    // 平方剩余和 的预处理\n    static int[] core = new int[1010];\n    static int limit = 1000;\n    static {\n        // 求 1~1000 的所有数的平方剩余和\n        for(int i = 1;i &lt;= limit;i++) {\n            if(core[i] == 0) {\n                // 说明没有被计算过\n                for(int j = 1;i*j*j &lt;= limit;j++) {\n                    core[i*j*j] = i;\n                }\n            }\n        }\n    }\n\n    // 验证，平方剩余和 时，两个数的乘积为完全平方数\n    public static void main(String[] args) {\n        for(int i = 1;i &lt;= 1000;i++) {\n            for(int j = i + 1;j &lt;= 1000;j++) {\n                if(core[i] == core[j]) {\n                    System.out.println((i * j) + &quot; == &quot; + (String.format(&quot;%.0f&quot;,Math.sqrt(i * j))) + &quot;^2&quot;);\n                }\n            }\n        }\n    }\n}\n</code></pre>\n"},{"title":"String的特性","description":"String 的基本特性以及用法和常考题\n","pinned":0,"lang":"zh","type":"post","wordCount":111,"charCount":2123,"imgCount":0,"vidCount":0,"wsCount":0,"cbCount":0,"readTime":"约47秒","abbrlink":"70e3fcb2","date":"2025-10-27T14:23:41.000Z","_content":"### 1、String 为什么是不可变的？\n\n##### 1）原因：\n\n① **安全性：**String 类常用于存储敏感信息，如密码，路径等，如果它是可变的，攻击者可能通过修改字符串内容来绕过安全检查。同时Java的类加载器在加载类时会使用String来存储类名和包名，如果String是可变的，攻击者可能加载恶意的类破坏系统。Java String 类的不可变性，确保了这些关键字符串在创建并传递后，其值绝对无法被任何代码（包括自身）所改变，从根本上杜绝了被篡改的风险。是系统安全性的基石。\n\n② **字符串常量池依赖不可变性：**String 类是程序中最常用的，同时存在大量重复字符串，为了解决大量重复的问题，引入了字符串常量池，当创建字符串时，JVM 会优先从池中找，没有再创建，而这个优化完全依赖String的不可变性，因为常量池中的一个对象可能被多次引用，如果其中的任何一个引用能修改对象的值，那末就会导致所有共享该对象的引用全部出错。\n\n③ 在**多线程**模式下，可以自由传递、共享 String，不需要任何同步机制，简化了开发。\n\n④ 由于 String 的不可变性，因此 String 对象的hash值只用计算一次，后续直接从缓存中读取，提高了集合的性能。\n\n##### 2）实现方法：\n\n​      `String` 类的核心参数为 `value` 数组，在`JDK 9` 之后，使用 `byte[]`  代替 `char[]` 。`value` 值由` final` 关键字修饰，保证数据引用的不变性，用 `private`修饰，保证外部无法直接修改，同时 `String` 类由 `final` 修饰，保证不会被继承，防止子类的修改。在 `JDK 9` 版本时，还引用了`Java` 的内部注解`@Stable`，修饰 `value` ，用于提示 `JVM` ，这是一个稳定的字段，一旦赋值，基本不会改变，是运行时的稳定承诺。当访问一个普通字段时，因可能被其他线程修改，理论上需每次从内存加载（但实际受 CPU 缓存优化影响，可能读取旧值）；但是由`@Stable` 注解修饰后，在高频访问时，可能在读取后，就将值存储到一个寄存器中，后续直接从寄存器中取值即可。同时，在编译时可能直接把这个值当作常量，将其内敛到使用它的地方，也被称为 常量折叠 提升运行速度。注意：仍可以用反射调用修改，但是开发者往往不被允许。\n\n### 2、String、StirngBuffer、StirngBuilder 的区别？\n\n##### 1）不可变性：\n\n​      String 是不可变的，任何操作都会产生新的对象，原字符串不做改变。StringBuilder 和 StringBuffer 都是可变的，都是直接在原对象上修改，避免创建新的对象。具体是StringBuilder 和 StringBuffer 都继承AbstractStringBuilder抽象类，其字符都是存储在 value 中，没有使用 final 修饰，当修改时，若 value 容量不够，则会将 value 数组进行扩容，之后，将新串复制到扩容后的数组中。因此只是替换了value数组，原StringBuilder 和 StringBuffer 对象的引用没有改变。\n\n##### 2）线程安全性：\n\n​      String 由不可变性，天然就是线程安全的。StringBuilder 是线程不安全的，多线程模式下可能会导致数据不一致问题。StringBuffer 是线程安全的，所有的方法都是用 Synchorized 修饰。\n\n##### 3）性能（大致）：\n\n​      String（反复创建对象） < StringBuffer（多线程下的加锁解锁） < StringBuilder （单线程下性能高）\n\n### 3、字符串常量池？\n\n##### 1）存储位置：\n\n​      在 JDK 7 之前，字符串常量池位于方法区的永久代中，在JDK 7 之后，字符串常量池也被移动至堆内。\n\n##### 2）存储内容：\n\n​      在 JDK 7 之前，存储的是字符串本身，在移动到堆后，存储的是字符串在堆内存上的引用。对于没有引用的对象，可被垃圾回收器回收，防止内存泄漏。\n\n##### 3）使用方法：\n\n​      String s1 = “Hello” ，则会自动入池，并通过池中的引用指向堆中的“Hello”，而String s2 = new String(“Hello”) ,则是直接在堆内存中创建了一个新的对象，不会进入字符串常量池中。但是可以使用 s2.intern() 方法，将字符串手动添加到常量池中，并返回引用。\n\n##### 4）数据结构：\n\n​      字符串常量池是通过基于Hash表的StringTable实现，JDK 7 之前，固定大小，之后，可指定大小， JDK 9 时，将char[] 改为 byte[]。\n\n### 4、JDK 9 为什么将Stirng的char[]改为byte[]？\n\n##### 1）内存的优化：\n\n​      用char数组时，一个char 占用 2 个字节，实际中，英文，数字，特殊字符占使用的大多数，且是需要 1 个字节。对于byte数组，字符，英文，数字等，都只占用 1 个字节，中文占用 2 个字。例如，对于 “Hello” ，char 数组存需要 5 * 2 = 10B，对于byte数组只需要 5B，节省了近50%的空间。\n\n##### 2）自适应编码\n\n​      根据不同的字符串使用不同的编码。当仅包含 1 个字节的字符时，String 中的coder标志位为 0 ，表示使用单字节编码字符集，当字符串中存在 2 个字节的字符时，String 中的coder标志位为 1，表示采用双字节编码字符集，同时，当单字节字符串拼接上双字节字符串时，会将coder升级为1，表示采用双字节编码字符集。\n\n### 5、Substring() 的优化？\n\n​      substring：在JDK 6 以及之前，时复用原数组，即使只是用一小部分呢，但是要保留整个字符串，导致原字符串无法被GC，在JDK 7 之后，则是会创建一个新的字符串返回，原字符串可以被GC。\n","source":"_posts/String的特性.md","raw":"---\ntitle: String的特性\ntags:\n  - String\ndescription: |\n  String 的基本特性以及用法和常考题\npinned: 0\nlang: zh\ncategories:\n  - Java 基础篇\ntype: post\nwordCount: 111\ncharCount: 2123\nimgCount: 0\nvidCount: 0\nwsCount: 0\ncbCount: 0\nreadTime: 约47秒\nabbrlink: 70e3fcb2\ndate: 2025-10-27 22:23:41\n---\n### 1、String 为什么是不可变的？\n\n##### 1）原因：\n\n① **安全性：**String 类常用于存储敏感信息，如密码，路径等，如果它是可变的，攻击者可能通过修改字符串内容来绕过安全检查。同时Java的类加载器在加载类时会使用String来存储类名和包名，如果String是可变的，攻击者可能加载恶意的类破坏系统。Java String 类的不可变性，确保了这些关键字符串在创建并传递后，其值绝对无法被任何代码（包括自身）所改变，从根本上杜绝了被篡改的风险。是系统安全性的基石。\n\n② **字符串常量池依赖不可变性：**String 类是程序中最常用的，同时存在大量重复字符串，为了解决大量重复的问题，引入了字符串常量池，当创建字符串时，JVM 会优先从池中找，没有再创建，而这个优化完全依赖String的不可变性，因为常量池中的一个对象可能被多次引用，如果其中的任何一个引用能修改对象的值，那末就会导致所有共享该对象的引用全部出错。\n\n③ 在**多线程**模式下，可以自由传递、共享 String，不需要任何同步机制，简化了开发。\n\n④ 由于 String 的不可变性，因此 String 对象的hash值只用计算一次，后续直接从缓存中读取，提高了集合的性能。\n\n##### 2）实现方法：\n\n​      `String` 类的核心参数为 `value` 数组，在`JDK 9` 之后，使用 `byte[]`  代替 `char[]` 。`value` 值由` final` 关键字修饰，保证数据引用的不变性，用 `private`修饰，保证外部无法直接修改，同时 `String` 类由 `final` 修饰，保证不会被继承，防止子类的修改。在 `JDK 9` 版本时，还引用了`Java` 的内部注解`@Stable`，修饰 `value` ，用于提示 `JVM` ，这是一个稳定的字段，一旦赋值，基本不会改变，是运行时的稳定承诺。当访问一个普通字段时，因可能被其他线程修改，理论上需每次从内存加载（但实际受 CPU 缓存优化影响，可能读取旧值）；但是由`@Stable` 注解修饰后，在高频访问时，可能在读取后，就将值存储到一个寄存器中，后续直接从寄存器中取值即可。同时，在编译时可能直接把这个值当作常量，将其内敛到使用它的地方，也被称为 常量折叠 提升运行速度。注意：仍可以用反射调用修改，但是开发者往往不被允许。\n\n### 2、String、StirngBuffer、StirngBuilder 的区别？\n\n##### 1）不可变性：\n\n​      String 是不可变的，任何操作都会产生新的对象，原字符串不做改变。StringBuilder 和 StringBuffer 都是可变的，都是直接在原对象上修改，避免创建新的对象。具体是StringBuilder 和 StringBuffer 都继承AbstractStringBuilder抽象类，其字符都是存储在 value 中，没有使用 final 修饰，当修改时，若 value 容量不够，则会将 value 数组进行扩容，之后，将新串复制到扩容后的数组中。因此只是替换了value数组，原StringBuilder 和 StringBuffer 对象的引用没有改变。\n\n##### 2）线程安全性：\n\n​      String 由不可变性，天然就是线程安全的。StringBuilder 是线程不安全的，多线程模式下可能会导致数据不一致问题。StringBuffer 是线程安全的，所有的方法都是用 Synchorized 修饰。\n\n##### 3）性能（大致）：\n\n​      String（反复创建对象） < StringBuffer（多线程下的加锁解锁） < StringBuilder （单线程下性能高）\n\n### 3、字符串常量池？\n\n##### 1）存储位置：\n\n​      在 JDK 7 之前，字符串常量池位于方法区的永久代中，在JDK 7 之后，字符串常量池也被移动至堆内。\n\n##### 2）存储内容：\n\n​      在 JDK 7 之前，存储的是字符串本身，在移动到堆后，存储的是字符串在堆内存上的引用。对于没有引用的对象，可被垃圾回收器回收，防止内存泄漏。\n\n##### 3）使用方法：\n\n​      String s1 = “Hello” ，则会自动入池，并通过池中的引用指向堆中的“Hello”，而String s2 = new String(“Hello”) ,则是直接在堆内存中创建了一个新的对象，不会进入字符串常量池中。但是可以使用 s2.intern() 方法，将字符串手动添加到常量池中，并返回引用。\n\n##### 4）数据结构：\n\n​      字符串常量池是通过基于Hash表的StringTable实现，JDK 7 之前，固定大小，之后，可指定大小， JDK 9 时，将char[] 改为 byte[]。\n\n### 4、JDK 9 为什么将Stirng的char[]改为byte[]？\n\n##### 1）内存的优化：\n\n​      用char数组时，一个char 占用 2 个字节，实际中，英文，数字，特殊字符占使用的大多数，且是需要 1 个字节。对于byte数组，字符，英文，数字等，都只占用 1 个字节，中文占用 2 个字。例如，对于 “Hello” ，char 数组存需要 5 * 2 = 10B，对于byte数组只需要 5B，节省了近50%的空间。\n\n##### 2）自适应编码\n\n​      根据不同的字符串使用不同的编码。当仅包含 1 个字节的字符时，String 中的coder标志位为 0 ，表示使用单字节编码字符集，当字符串中存在 2 个字节的字符时，String 中的coder标志位为 1，表示采用双字节编码字符集，同时，当单字节字符串拼接上双字节字符串时，会将coder升级为1，表示采用双字节编码字符集。\n\n### 5、Substring() 的优化？\n\n​      substring：在JDK 6 以及之前，时复用原数组，即使只是用一小部分呢，但是要保留整个字符串，导致原字符串无法被GC，在JDK 7 之后，则是会创建一个新的字符串返回，原字符串可以被GC。\n","slug":"String的特性","published":1,"updated":"2025-10-27T14:28:11.539Z","comments":1,"layout":"post","photos":[],"_id":"cuide-qbUQdRvaOQ-8gEwQkNN","content":"<h3 id=\"1、String-为什么是不可变的？\"><a href=\"#1、String-为什么是不可变的？\" class=\"headerlink\" title=\"1、String 为什么是不可变的？\"></a>1、String 为什么是不可变的？</h3><h5 id=\"1）原因：\"><a href=\"#1）原因：\" class=\"headerlink\" title=\"1）原因：\"></a>1）原因：</h5><p>① **安全性：**String 类常用于存储敏感信息，如密码，路径等，如果它是可变的，攻击者可能通过修改字符串内容来绕过安全检查。同时Java的类加载器在加载类时会使用String来存储类名和包名，如果String是可变的，攻击者可能加载恶意的类破坏系统。Java String 类的不可变性，确保了这些关键字符串在创建并传递后，其值绝对无法被任何代码（包括自身）所改变，从根本上杜绝了被篡改的风险。是系统安全性的基石。</p>\n<p>② **字符串常量池依赖不可变性：**String 类是程序中最常用的，同时存在大量重复字符串，为了解决大量重复的问题，引入了字符串常量池，当创建字符串时，JVM 会优先从池中找，没有再创建，而这个优化完全依赖String的不可变性，因为常量池中的一个对象可能被多次引用，如果其中的任何一个引用能修改对象的值，那末就会导致所有共享该对象的引用全部出错。</p>\n<p>③ 在<strong>多线程</strong>模式下，可以自由传递、共享 String，不需要任何同步机制，简化了开发。</p>\n<p>④ 由于 String 的不可变性，因此 String 对象的hash值只用计算一次，后续直接从缓存中读取，提高了集合的性能。</p>\n<h5 id=\"2）实现方法：\"><a href=\"#2）实现方法：\" class=\"headerlink\" title=\"2）实现方法：\"></a>2）实现方法：</h5><p>​      <code>String</code> 类的核心参数为 <code>value</code> 数组，在<code>JDK 9</code> 之后，使用 <code>byte[]</code>  代替 <code>char[]</code> 。<code>value</code> 值由<code> final</code> 关键字修饰，保证数据引用的不变性，用 <code>private</code>修饰，保证外部无法直接修改，同时 <code>String</code> 类由 <code>final</code> 修饰，保证不会被继承，防止子类的修改。在 <code>JDK 9</code> 版本时，还引用了<code>Java</code> 的内部注解<code>@Stable</code>，修饰 <code>value</code> ，用于提示 <code>JVM</code> ，这是一个稳定的字段，一旦赋值，基本不会改变，是运行时的稳定承诺。当访问一个普通字段时，因可能被其他线程修改，理论上需每次从内存加载（但实际受 CPU 缓存优化影响，可能读取旧值）；但是由<code>@Stable</code> 注解修饰后，在高频访问时，可能在读取后，就将值存储到一个寄存器中，后续直接从寄存器中取值即可。同时，在编译时可能直接把这个值当作常量，将其内敛到使用它的地方，也被称为 常量折叠 提升运行速度。注意：仍可以用反射调用修改，但是开发者往往不被允许。</p>\n<h3 id=\"2、String、StirngBuffer、StirngBuilder-的区别？\"><a href=\"#2、String、StirngBuffer、StirngBuilder-的区别？\" class=\"headerlink\" title=\"2、String、StirngBuffer、StirngBuilder 的区别？\"></a>2、String、StirngBuffer、StirngBuilder 的区别？</h3><h5 id=\"1）不可变性：\"><a href=\"#1）不可变性：\" class=\"headerlink\" title=\"1）不可变性：\"></a>1）不可变性：</h5><p>​      String 是不可变的，任何操作都会产生新的对象，原字符串不做改变。StringBuilder 和 StringBuffer 都是可变的，都是直接在原对象上修改，避免创建新的对象。具体是StringBuilder 和 StringBuffer 都继承AbstractStringBuilder抽象类，其字符都是存储在 value 中，没有使用 final 修饰，当修改时，若 value 容量不够，则会将 value 数组进行扩容，之后，将新串复制到扩容后的数组中。因此只是替换了value数组，原StringBuilder 和 StringBuffer 对象的引用没有改变。</p>\n<h5 id=\"2）线程安全性：\"><a href=\"#2）线程安全性：\" class=\"headerlink\" title=\"2）线程安全性：\"></a>2）线程安全性：</h5><p>​      String 由不可变性，天然就是线程安全的。StringBuilder 是线程不安全的，多线程模式下可能会导致数据不一致问题。StringBuffer 是线程安全的，所有的方法都是用 Synchorized 修饰。</p>\n<h5 id=\"3）性能（大致）：\"><a href=\"#3）性能（大致）：\" class=\"headerlink\" title=\"3）性能（大致）：\"></a>3）性能（大致）：</h5><p>​      String（反复创建对象） &lt; StringBuffer（多线程下的加锁解锁） &lt; StringBuilder （单线程下性能高）</p>\n<h3 id=\"3、字符串常量池？\"><a href=\"#3、字符串常量池？\" class=\"headerlink\" title=\"3、字符串常量池？\"></a>3、字符串常量池？</h3><h5 id=\"1）存储位置：\"><a href=\"#1）存储位置：\" class=\"headerlink\" title=\"1）存储位置：\"></a>1）存储位置：</h5><p>​      在 JDK 7 之前，字符串常量池位于方法区的永久代中，在JDK 7 之后，字符串常量池也被移动至堆内。</p>\n<h5 id=\"2）存储内容：\"><a href=\"#2）存储内容：\" class=\"headerlink\" title=\"2）存储内容：\"></a>2）存储内容：</h5><p>​      在 JDK 7 之前，存储的是字符串本身，在移动到堆后，存储的是字符串在堆内存上的引用。对于没有引用的对象，可被垃圾回收器回收，防止内存泄漏。</p>\n<h5 id=\"3）使用方法：\"><a href=\"#3）使用方法：\" class=\"headerlink\" title=\"3）使用方法：\"></a>3）使用方法：</h5><p>​      String s1 &#x3D; “Hello” ，则会自动入池，并通过池中的引用指向堆中的“Hello”，而String s2 &#x3D; new String(“Hello”) ,则是直接在堆内存中创建了一个新的对象，不会进入字符串常量池中。但是可以使用 s2.intern() 方法，将字符串手动添加到常量池中，并返回引用。</p>\n<h5 id=\"4）数据结构：\"><a href=\"#4）数据结构：\" class=\"headerlink\" title=\"4）数据结构：\"></a>4）数据结构：</h5><p>​      字符串常量池是通过基于Hash表的StringTable实现，JDK 7 之前，固定大小，之后，可指定大小， JDK 9 时，将char[] 改为 byte[]。</p>\n<h3 id=\"4、JDK-9-为什么将Stirng的char-改为byte-？\"><a href=\"#4、JDK-9-为什么将Stirng的char-改为byte-？\" class=\"headerlink\" title=\"4、JDK 9 为什么将Stirng的char[]改为byte[]？\"></a>4、JDK 9 为什么将Stirng的char[]改为byte[]？</h3><h5 id=\"1）内存的优化：\"><a href=\"#1）内存的优化：\" class=\"headerlink\" title=\"1）内存的优化：\"></a>1）内存的优化：</h5><p>​      用char数组时，一个char 占用 2 个字节，实际中，英文，数字，特殊字符占使用的大多数，且是需要 1 个字节。对于byte数组，字符，英文，数字等，都只占用 1 个字节，中文占用 2 个字。例如，对于 “Hello” ，char 数组存需要 5 * 2 &#x3D; 10B，对于byte数组只需要 5B，节省了近50%的空间。</p>\n<h5 id=\"2）自适应编码\"><a href=\"#2）自适应编码\" class=\"headerlink\" title=\"2）自适应编码\"></a>2）自适应编码</h5><p>​      根据不同的字符串使用不同的编码。当仅包含 1 个字节的字符时，String 中的coder标志位为 0 ，表示使用单字节编码字符集，当字符串中存在 2 个字节的字符时，String 中的coder标志位为 1，表示采用双字节编码字符集，同时，当单字节字符串拼接上双字节字符串时，会将coder升级为1，表示采用双字节编码字符集。</p>\n<h3 id=\"5、Substring-的优化？\"><a href=\"#5、Substring-的优化？\" class=\"headerlink\" title=\"5、Substring() 的优化？\"></a>5、Substring() 的优化？</h3><p>​      substring：在JDK 6 以及之前，时复用原数组，即使只是用一小部分呢，但是要保留整个字符串，导致原字符串无法被GC，在JDK 7 之后，则是会创建一个新的字符串返回，原字符串可以被GC。</p>\n","excerpt":"","more":"<h3 id=\"1、String-为什么是不可变的？\"><a href=\"#1、String-为什么是不可变的？\" class=\"headerlink\" title=\"1、String 为什么是不可变的？\"></a>1、String 为什么是不可变的？</h3><h5 id=\"1）原因：\"><a href=\"#1）原因：\" class=\"headerlink\" title=\"1）原因：\"></a>1）原因：</h5><p>① **安全性：**String 类常用于存储敏感信息，如密码，路径等，如果它是可变的，攻击者可能通过修改字符串内容来绕过安全检查。同时Java的类加载器在加载类时会使用String来存储类名和包名，如果String是可变的，攻击者可能加载恶意的类破坏系统。Java String 类的不可变性，确保了这些关键字符串在创建并传递后，其值绝对无法被任何代码（包括自身）所改变，从根本上杜绝了被篡改的风险。是系统安全性的基石。</p>\n<p>② **字符串常量池依赖不可变性：**String 类是程序中最常用的，同时存在大量重复字符串，为了解决大量重复的问题，引入了字符串常量池，当创建字符串时，JVM 会优先从池中找，没有再创建，而这个优化完全依赖String的不可变性，因为常量池中的一个对象可能被多次引用，如果其中的任何一个引用能修改对象的值，那末就会导致所有共享该对象的引用全部出错。</p>\n<p>③ 在<strong>多线程</strong>模式下，可以自由传递、共享 String，不需要任何同步机制，简化了开发。</p>\n<p>④ 由于 String 的不可变性，因此 String 对象的hash值只用计算一次，后续直接从缓存中读取，提高了集合的性能。</p>\n<h5 id=\"2）实现方法：\"><a href=\"#2）实现方法：\" class=\"headerlink\" title=\"2）实现方法：\"></a>2）实现方法：</h5><p>​      <code>String</code> 类的核心参数为 <code>value</code> 数组，在<code>JDK 9</code> 之后，使用 <code>byte[]</code>  代替 <code>char[]</code> 。<code>value</code> 值由<code> final</code> 关键字修饰，保证数据引用的不变性，用 <code>private</code>修饰，保证外部无法直接修改，同时 <code>String</code> 类由 <code>final</code> 修饰，保证不会被继承，防止子类的修改。在 <code>JDK 9</code> 版本时，还引用了<code>Java</code> 的内部注解<code>@Stable</code>，修饰 <code>value</code> ，用于提示 <code>JVM</code> ，这是一个稳定的字段，一旦赋值，基本不会改变，是运行时的稳定承诺。当访问一个普通字段时，因可能被其他线程修改，理论上需每次从内存加载（但实际受 CPU 缓存优化影响，可能读取旧值）；但是由<code>@Stable</code> 注解修饰后，在高频访问时，可能在读取后，就将值存储到一个寄存器中，后续直接从寄存器中取值即可。同时，在编译时可能直接把这个值当作常量，将其内敛到使用它的地方，也被称为 常量折叠 提升运行速度。注意：仍可以用反射调用修改，但是开发者往往不被允许。</p>\n<h3 id=\"2、String、StirngBuffer、StirngBuilder-的区别？\"><a href=\"#2、String、StirngBuffer、StirngBuilder-的区别？\" class=\"headerlink\" title=\"2、String、StirngBuffer、StirngBuilder 的区别？\"></a>2、String、StirngBuffer、StirngBuilder 的区别？</h3><h5 id=\"1）不可变性：\"><a href=\"#1）不可变性：\" class=\"headerlink\" title=\"1）不可变性：\"></a>1）不可变性：</h5><p>​      String 是不可变的，任何操作都会产生新的对象，原字符串不做改变。StringBuilder 和 StringBuffer 都是可变的，都是直接在原对象上修改，避免创建新的对象。具体是StringBuilder 和 StringBuffer 都继承AbstractStringBuilder抽象类，其字符都是存储在 value 中，没有使用 final 修饰，当修改时，若 value 容量不够，则会将 value 数组进行扩容，之后，将新串复制到扩容后的数组中。因此只是替换了value数组，原StringBuilder 和 StringBuffer 对象的引用没有改变。</p>\n<h5 id=\"2）线程安全性：\"><a href=\"#2）线程安全性：\" class=\"headerlink\" title=\"2）线程安全性：\"></a>2）线程安全性：</h5><p>​      String 由不可变性，天然就是线程安全的。StringBuilder 是线程不安全的，多线程模式下可能会导致数据不一致问题。StringBuffer 是线程安全的，所有的方法都是用 Synchorized 修饰。</p>\n<h5 id=\"3）性能（大致）：\"><a href=\"#3）性能（大致）：\" class=\"headerlink\" title=\"3）性能（大致）：\"></a>3）性能（大致）：</h5><p>​      String（反复创建对象） &lt; StringBuffer（多线程下的加锁解锁） &lt; StringBuilder （单线程下性能高）</p>\n<h3 id=\"3、字符串常量池？\"><a href=\"#3、字符串常量池？\" class=\"headerlink\" title=\"3、字符串常量池？\"></a>3、字符串常量池？</h3><h5 id=\"1）存储位置：\"><a href=\"#1）存储位置：\" class=\"headerlink\" title=\"1）存储位置：\"></a>1）存储位置：</h5><p>​      在 JDK 7 之前，字符串常量池位于方法区的永久代中，在JDK 7 之后，字符串常量池也被移动至堆内。</p>\n<h5 id=\"2）存储内容：\"><a href=\"#2）存储内容：\" class=\"headerlink\" title=\"2）存储内容：\"></a>2）存储内容：</h5><p>​      在 JDK 7 之前，存储的是字符串本身，在移动到堆后，存储的是字符串在堆内存上的引用。对于没有引用的对象，可被垃圾回收器回收，防止内存泄漏。</p>\n<h5 id=\"3）使用方法：\"><a href=\"#3）使用方法：\" class=\"headerlink\" title=\"3）使用方法：\"></a>3）使用方法：</h5><p>​      String s1 &#x3D; “Hello” ，则会自动入池，并通过池中的引用指向堆中的“Hello”，而String s2 &#x3D; new String(“Hello”) ,则是直接在堆内存中创建了一个新的对象，不会进入字符串常量池中。但是可以使用 s2.intern() 方法，将字符串手动添加到常量池中，并返回引用。</p>\n<h5 id=\"4）数据结构：\"><a href=\"#4）数据结构：\" class=\"headerlink\" title=\"4）数据结构：\"></a>4）数据结构：</h5><p>​      字符串常量池是通过基于Hash表的StringTable实现，JDK 7 之前，固定大小，之后，可指定大小， JDK 9 时，将char[] 改为 byte[]。</p>\n<h3 id=\"4、JDK-9-为什么将Stirng的char-改为byte-？\"><a href=\"#4、JDK-9-为什么将Stirng的char-改为byte-？\" class=\"headerlink\" title=\"4、JDK 9 为什么将Stirng的char[]改为byte[]？\"></a>4、JDK 9 为什么将Stirng的char[]改为byte[]？</h3><h5 id=\"1）内存的优化：\"><a href=\"#1）内存的优化：\" class=\"headerlink\" title=\"1）内存的优化：\"></a>1）内存的优化：</h5><p>​      用char数组时，一个char 占用 2 个字节，实际中，英文，数字，特殊字符占使用的大多数，且是需要 1 个字节。对于byte数组，字符，英文，数字等，都只占用 1 个字节，中文占用 2 个字。例如，对于 “Hello” ，char 数组存需要 5 * 2 &#x3D; 10B，对于byte数组只需要 5B，节省了近50%的空间。</p>\n<h5 id=\"2）自适应编码\"><a href=\"#2）自适应编码\" class=\"headerlink\" title=\"2）自适应编码\"></a>2）自适应编码</h5><p>​      根据不同的字符串使用不同的编码。当仅包含 1 个字节的字符时，String 中的coder标志位为 0 ，表示使用单字节编码字符集，当字符串中存在 2 个字节的字符时，String 中的coder标志位为 1，表示采用双字节编码字符集，同时，当单字节字符串拼接上双字节字符串时，会将coder升级为1，表示采用双字节编码字符集。</p>\n<h3 id=\"5、Substring-的优化？\"><a href=\"#5、Substring-的优化？\" class=\"headerlink\" title=\"5、Substring() 的优化？\"></a>5、Substring() 的优化？</h3><p>​      substring：在JDK 6 以及之前，时复用原数组，即使只是用一小部分呢，但是要保留整个字符串，导致原字符串无法被GC，在JDK 7 之后，则是会创建一个新的字符串返回，原字符串可以被GC。</p>\n"},{"title":"测试文章02","description":"文章缩略，支持 `Markdown` **文档格式**\n","pinned":0,"lang":"zh","type":"post","abbrlink":"cc7c02e8","wordCount":112,"charCount":2135,"imgCount":0,"vidCount":0,"wsCount":0,"cbCount":0,"readTime":"约48秒","date":"2025-10-18T13:48:31.000Z","_content":"## 一、String 的特性\n\n### 1、String 为什么是不可变的？\n\n##### 1）原因：\n\n① **安全性**：String 类常用于存储敏感信息，如密码，路径等，如果它是可变的，攻击者可能通过修改字符串内容来绕过安全检查。同时Java的类加载器在加载类时会使用String来存储类名和包名，如果String是可变的，攻击者可能加载恶意的类破坏系统。Java String 类的不可变性，确保了这些关键字符串在创建并传递后，其值绝对无法被任何代码（包括自身）所改变，从根本上杜绝了被篡改的风险。是系统安全性的基石。\n\n② **字符串常量池依赖不可变性**：String 类是程序中最常用的，同时存在大量重复字符串，为了解决大量重复的问题，引入了字符串常量池，当创建字符串时，JVM 会优先从池中找，没有再创建，而这个优化完全依赖String的不可变性，因为常量池中的一个对象可能被多次引用，如果其中的任何一个引用能修改对象的值，那末就会导致所有共享该对象的引用全部出错。\n\n③ 在**多线程**模式下，可以自由传递、共享 String，不需要任何同步机制，简化了开发。\n\n④ 由于 String 的不可变性，因此 String 对象的hash值只用计算一次，后续直接从缓存中读取，提高了集合的性能。\n\n##### 2）实现方法：\n\n​      `String` 类的核心参数为 `value` 数组，在`JDK 9` 之后，使用 `byte[]`  代替 `char[]` 。`value` 值由` final` 关键字修饰，保证数据引用的不变性，用 `private`修饰，保证外部无法直接修改，同时 `String` 类由 `final` 修饰，保证不会被继承，防止子类的修改。在 `JDK 9` 版本时，还引用了`Java` 的内部注解`@Stable`，修饰 `value` ，用于提示 `JVM` ，这是一个稳定的字段，一旦赋值，基本不会改变，是运行时的稳定承诺。当访问一个普通字段时，因可能被其他线程修改，理论上需每次从内存加载（但实际受 CPU 缓存优化影响，可能读取旧值）；但是由`@Stable` 注解修饰后，在高频访问时，可能在读取后，就将值存储到一个寄存器中，后续直接从寄存器中取值即可。同时，在编译时可能直接把这个值当作常量，将其内敛到使用它的地方，也被称为 常量折叠 提升运行速度。注意：仍可以用反射调用修改，但是开发者往往不被允许。\n\n### 2、String、StirngBuffer、StirngBuilder 的区别？\n\n##### 1）不可变性：\n\n​      String 是不可变的，任何操作都会产生新的对象，原字符串不做改变。StringBuilder 和 StringBuffer 都是可变的，都是直接在原对象上修改，避免创建新的对象。具体是StringBuilder 和 StringBuffer 都继承AbstractStringBuilder抽象类，其字符都是存储在 value 中，没有使用 final 修饰，当修改时，若 value 容量不够，则会将 value 数组进行扩容，之后，将新串复制到扩容后的数组中。因此只是替换了value数组，原StringBuilder 和 StringBuffer 对象的引用没有改变。\n\n##### 2）线程安全性：\n\n​      String 由不可变性，天然就是线程安全的。StringBuilder 是线程不安全的，多线程模式下可能会导致数据不一致问题。StringBuffer 是线程安全的，所有的方法都是用 Synchorized 修饰。\n\n##### 3）性能（大致）：\n\n​      String（反复创建对象） < StringBuffer（多线程下的加锁解锁） < StringBuilder （单线程下性能高）\n\n### 3、字符串常量池？\n\n##### 1）存储位置：\n\n​      在 JDK 7 之前，字符串常量池位于方法区的永久代中，在JDK 7 之后，字符串常量池也被移动至堆内。\n\n##### 2）存储内容：\n\n​      在 JDK 7 之前，存储的是字符串本身，在移动到堆后，存储的是字符串在堆内存上的引用。对于没有引用的对象，可被垃圾回收器回收，防止内存泄漏。\n\n##### 3）使用方法：\n\n​      String s1 = “Hello” ，则会自动入池，并通过池中的引用指向堆中的“Hello”，而String s2 = new String(“Hello”) ,则是直接在堆内存中创建了一个新的对象，不会进入字符串常量池中。但是可以使用 s2.intern() 方法，将字符串手动添加到常量池中，并返回引用。\n\n##### 4）数据结构：\n\n​      字符串常量池是通过基于Hash表的StringTable实现，JDK 7 之前，固定大小，之后，可指定大小， JDK 9 时，将char[] 改为 byte[]。\n\n### 4、JDK 9 为什么将Stirng的char[]改为byte[]？\n\n##### 1）内存的优化：\n\n​      用char数组时，一个char 占用 2 个字节，实际中，英文，数字，特殊字符占使用的大多数，且是需要 1 个字节。对于byte数组，字符，英文，数字等，都只占用 1 个字节，中文占用 2 个字。例如，对于 “Hello” ，char 数组存需要 5 * 2 = 10B，对于byte数组只需要 5B，节省了近50%的空间。\n\n##### 2）自适应编码\n\n​      根据不同的字符串使用不同的编码。当仅包含 1 个字节的字符时，String 中的coder标志位为 0 ，表示使用单字节编码字符集，当字符串中存在 2 个字节的字符时，String 中的coder标志位为 1，表示采用双字节编码字符集，同时，当单字节字符串拼接上双字节字符串时，会将coder升级为1，表示采用双字节编码字符集。\n\n### 5、Substring() 的优化？\n\n​      substring：在JDK 6 以及之前，时复用原数组，即使只是用一小部分呢，但是要保留整个字符串，导致原字符串无法被GC，在JDK 7 之后，则是会创建一个新的字符串返回，原字符串可以被GC。","source":"_posts/测试文章02.md","raw":"---\ntitle: 测试文章02\ndescription: |\n  文章缩略，支持 `Markdown` **文档格式**\ntags: \n  - 测试\npinned: 0\nlang: zh\ncategories:\n  - 测试\ntype: post\nabbrlink: cc7c02e8\nwordCount: 112\ncharCount: 2135\nimgCount: 0\nvidCount: 0\nwsCount: 0\ncbCount: 0\nreadTime: 约48秒\ndate: 2025-10-18 21:48:31\n---\n## 一、String 的特性\n\n### 1、String 为什么是不可变的？\n\n##### 1）原因：\n\n① **安全性**：String 类常用于存储敏感信息，如密码，路径等，如果它是可变的，攻击者可能通过修改字符串内容来绕过安全检查。同时Java的类加载器在加载类时会使用String来存储类名和包名，如果String是可变的，攻击者可能加载恶意的类破坏系统。Java String 类的不可变性，确保了这些关键字符串在创建并传递后，其值绝对无法被任何代码（包括自身）所改变，从根本上杜绝了被篡改的风险。是系统安全性的基石。\n\n② **字符串常量池依赖不可变性**：String 类是程序中最常用的，同时存在大量重复字符串，为了解决大量重复的问题，引入了字符串常量池，当创建字符串时，JVM 会优先从池中找，没有再创建，而这个优化完全依赖String的不可变性，因为常量池中的一个对象可能被多次引用，如果其中的任何一个引用能修改对象的值，那末就会导致所有共享该对象的引用全部出错。\n\n③ 在**多线程**模式下，可以自由传递、共享 String，不需要任何同步机制，简化了开发。\n\n④ 由于 String 的不可变性，因此 String 对象的hash值只用计算一次，后续直接从缓存中读取，提高了集合的性能。\n\n##### 2）实现方法：\n\n​      `String` 类的核心参数为 `value` 数组，在`JDK 9` 之后，使用 `byte[]`  代替 `char[]` 。`value` 值由` final` 关键字修饰，保证数据引用的不变性，用 `private`修饰，保证外部无法直接修改，同时 `String` 类由 `final` 修饰，保证不会被继承，防止子类的修改。在 `JDK 9` 版本时，还引用了`Java` 的内部注解`@Stable`，修饰 `value` ，用于提示 `JVM` ，这是一个稳定的字段，一旦赋值，基本不会改变，是运行时的稳定承诺。当访问一个普通字段时，因可能被其他线程修改，理论上需每次从内存加载（但实际受 CPU 缓存优化影响，可能读取旧值）；但是由`@Stable` 注解修饰后，在高频访问时，可能在读取后，就将值存储到一个寄存器中，后续直接从寄存器中取值即可。同时，在编译时可能直接把这个值当作常量，将其内敛到使用它的地方，也被称为 常量折叠 提升运行速度。注意：仍可以用反射调用修改，但是开发者往往不被允许。\n\n### 2、String、StirngBuffer、StirngBuilder 的区别？\n\n##### 1）不可变性：\n\n​      String 是不可变的，任何操作都会产生新的对象，原字符串不做改变。StringBuilder 和 StringBuffer 都是可变的，都是直接在原对象上修改，避免创建新的对象。具体是StringBuilder 和 StringBuffer 都继承AbstractStringBuilder抽象类，其字符都是存储在 value 中，没有使用 final 修饰，当修改时，若 value 容量不够，则会将 value 数组进行扩容，之后，将新串复制到扩容后的数组中。因此只是替换了value数组，原StringBuilder 和 StringBuffer 对象的引用没有改变。\n\n##### 2）线程安全性：\n\n​      String 由不可变性，天然就是线程安全的。StringBuilder 是线程不安全的，多线程模式下可能会导致数据不一致问题。StringBuffer 是线程安全的，所有的方法都是用 Synchorized 修饰。\n\n##### 3）性能（大致）：\n\n​      String（反复创建对象） < StringBuffer（多线程下的加锁解锁） < StringBuilder （单线程下性能高）\n\n### 3、字符串常量池？\n\n##### 1）存储位置：\n\n​      在 JDK 7 之前，字符串常量池位于方法区的永久代中，在JDK 7 之后，字符串常量池也被移动至堆内。\n\n##### 2）存储内容：\n\n​      在 JDK 7 之前，存储的是字符串本身，在移动到堆后，存储的是字符串在堆内存上的引用。对于没有引用的对象，可被垃圾回收器回收，防止内存泄漏。\n\n##### 3）使用方法：\n\n​      String s1 = “Hello” ，则会自动入池，并通过池中的引用指向堆中的“Hello”，而String s2 = new String(“Hello”) ,则是直接在堆内存中创建了一个新的对象，不会进入字符串常量池中。但是可以使用 s2.intern() 方法，将字符串手动添加到常量池中，并返回引用。\n\n##### 4）数据结构：\n\n​      字符串常量池是通过基于Hash表的StringTable实现，JDK 7 之前，固定大小，之后，可指定大小， JDK 9 时，将char[] 改为 byte[]。\n\n### 4、JDK 9 为什么将Stirng的char[]改为byte[]？\n\n##### 1）内存的优化：\n\n​      用char数组时，一个char 占用 2 个字节，实际中，英文，数字，特殊字符占使用的大多数，且是需要 1 个字节。对于byte数组，字符，英文，数字等，都只占用 1 个字节，中文占用 2 个字。例如，对于 “Hello” ，char 数组存需要 5 * 2 = 10B，对于byte数组只需要 5B，节省了近50%的空间。\n\n##### 2）自适应编码\n\n​      根据不同的字符串使用不同的编码。当仅包含 1 个字节的字符时，String 中的coder标志位为 0 ，表示使用单字节编码字符集，当字符串中存在 2 个字节的字符时，String 中的coder标志位为 1，表示采用双字节编码字符集，同时，当单字节字符串拼接上双字节字符串时，会将coder升级为1，表示采用双字节编码字符集。\n\n### 5、Substring() 的优化？\n\n​      substring：在JDK 6 以及之前，时复用原数组，即使只是用一小部分呢，但是要保留整个字符串，导致原字符串无法被GC，在JDK 7 之后，则是会创建一个新的字符串返回，原字符串可以被GC。","slug":"测试文章02","published":1,"updated":"2025-10-26T01:27:23.980Z","comments":1,"layout":"post","photos":[],"_id":"cuidVGruA96eAaiNIK55RB7P4","content":"<h2 id=\"一、String-的特性\"><a href=\"#一、String-的特性\" class=\"headerlink\" title=\"一、String 的特性\"></a>一、String 的特性</h2><h3 id=\"1、String-为什么是不可变的？\"><a href=\"#1、String-为什么是不可变的？\" class=\"headerlink\" title=\"1、String 为什么是不可变的？\"></a>1、String 为什么是不可变的？</h3><h5 id=\"1）原因：\"><a href=\"#1）原因：\" class=\"headerlink\" title=\"1）原因：\"></a>1）原因：</h5><p>① <strong>安全性</strong>：String 类常用于存储敏感信息，如密码，路径等，如果它是可变的，攻击者可能通过修改字符串内容来绕过安全检查。同时Java的类加载器在加载类时会使用String来存储类名和包名，如果String是可变的，攻击者可能加载恶意的类破坏系统。Java String 类的不可变性，确保了这些关键字符串在创建并传递后，其值绝对无法被任何代码（包括自身）所改变，从根本上杜绝了被篡改的风险。是系统安全性的基石。</p>\n<p>② <strong>字符串常量池依赖不可变性</strong>：String 类是程序中最常用的，同时存在大量重复字符串，为了解决大量重复的问题，引入了字符串常量池，当创建字符串时，JVM 会优先从池中找，没有再创建，而这个优化完全依赖String的不可变性，因为常量池中的一个对象可能被多次引用，如果其中的任何一个引用能修改对象的值，那末就会导致所有共享该对象的引用全部出错。</p>\n<p>③ 在<strong>多线程</strong>模式下，可以自由传递、共享 String，不需要任何同步机制，简化了开发。</p>\n<p>④ 由于 String 的不可变性，因此 String 对象的hash值只用计算一次，后续直接从缓存中读取，提高了集合的性能。</p>\n<h5 id=\"2）实现方法：\"><a href=\"#2）实现方法：\" class=\"headerlink\" title=\"2）实现方法：\"></a>2）实现方法：</h5><p>​      <code>String</code> 类的核心参数为 <code>value</code> 数组，在<code>JDK 9</code> 之后，使用 <code>byte[]</code>  代替 <code>char[]</code> 。<code>value</code> 值由<code> final</code> 关键字修饰，保证数据引用的不变性，用 <code>private</code>修饰，保证外部无法直接修改，同时 <code>String</code> 类由 <code>final</code> 修饰，保证不会被继承，防止子类的修改。在 <code>JDK 9</code> 版本时，还引用了<code>Java</code> 的内部注解<code>@Stable</code>，修饰 <code>value</code> ，用于提示 <code>JVM</code> ，这是一个稳定的字段，一旦赋值，基本不会改变，是运行时的稳定承诺。当访问一个普通字段时，因可能被其他线程修改，理论上需每次从内存加载（但实际受 CPU 缓存优化影响，可能读取旧值）；但是由<code>@Stable</code> 注解修饰后，在高频访问时，可能在读取后，就将值存储到一个寄存器中，后续直接从寄存器中取值即可。同时，在编译时可能直接把这个值当作常量，将其内敛到使用它的地方，也被称为 常量折叠 提升运行速度。注意：仍可以用反射调用修改，但是开发者往往不被允许。</p>\n<h3 id=\"2、String、StirngBuffer、StirngBuilder-的区别？\"><a href=\"#2、String、StirngBuffer、StirngBuilder-的区别？\" class=\"headerlink\" title=\"2、String、StirngBuffer、StirngBuilder 的区别？\"></a>2、String、StirngBuffer、StirngBuilder 的区别？</h3><h5 id=\"1）不可变性：\"><a href=\"#1）不可变性：\" class=\"headerlink\" title=\"1）不可变性：\"></a>1）不可变性：</h5><p>​      String 是不可变的，任何操作都会产生新的对象，原字符串不做改变。StringBuilder 和 StringBuffer 都是可变的，都是直接在原对象上修改，避免创建新的对象。具体是StringBuilder 和 StringBuffer 都继承AbstractStringBuilder抽象类，其字符都是存储在 value 中，没有使用 final 修饰，当修改时，若 value 容量不够，则会将 value 数组进行扩容，之后，将新串复制到扩容后的数组中。因此只是替换了value数组，原StringBuilder 和 StringBuffer 对象的引用没有改变。</p>\n<h5 id=\"2）线程安全性：\"><a href=\"#2）线程安全性：\" class=\"headerlink\" title=\"2）线程安全性：\"></a>2）线程安全性：</h5><p>​      String 由不可变性，天然就是线程安全的。StringBuilder 是线程不安全的，多线程模式下可能会导致数据不一致问题。StringBuffer 是线程安全的，所有的方法都是用 Synchorized 修饰。</p>\n<h5 id=\"3）性能（大致）：\"><a href=\"#3）性能（大致）：\" class=\"headerlink\" title=\"3）性能（大致）：\"></a>3）性能（大致）：</h5><p>​      String（反复创建对象） &lt; StringBuffer（多线程下的加锁解锁） &lt; StringBuilder （单线程下性能高）</p>\n<h3 id=\"3、字符串常量池？\"><a href=\"#3、字符串常量池？\" class=\"headerlink\" title=\"3、字符串常量池？\"></a>3、字符串常量池？</h3><h5 id=\"1）存储位置：\"><a href=\"#1）存储位置：\" class=\"headerlink\" title=\"1）存储位置：\"></a>1）存储位置：</h5><p>​      在 JDK 7 之前，字符串常量池位于方法区的永久代中，在JDK 7 之后，字符串常量池也被移动至堆内。</p>\n<h5 id=\"2）存储内容：\"><a href=\"#2）存储内容：\" class=\"headerlink\" title=\"2）存储内容：\"></a>2）存储内容：</h5><p>​      在 JDK 7 之前，存储的是字符串本身，在移动到堆后，存储的是字符串在堆内存上的引用。对于没有引用的对象，可被垃圾回收器回收，防止内存泄漏。</p>\n<h5 id=\"3）使用方法：\"><a href=\"#3）使用方法：\" class=\"headerlink\" title=\"3）使用方法：\"></a>3）使用方法：</h5><p>​      String s1 &#x3D; “Hello” ，则会自动入池，并通过池中的引用指向堆中的“Hello”，而String s2 &#x3D; new String(“Hello”) ,则是直接在堆内存中创建了一个新的对象，不会进入字符串常量池中。但是可以使用 s2.intern() 方法，将字符串手动添加到常量池中，并返回引用。</p>\n<h5 id=\"4）数据结构：\"><a href=\"#4）数据结构：\" class=\"headerlink\" title=\"4）数据结构：\"></a>4）数据结构：</h5><p>​      字符串常量池是通过基于Hash表的StringTable实现，JDK 7 之前，固定大小，之后，可指定大小， JDK 9 时，将char[] 改为 byte[]。</p>\n<h3 id=\"4、JDK-9-为什么将Stirng的char-改为byte-？\"><a href=\"#4、JDK-9-为什么将Stirng的char-改为byte-？\" class=\"headerlink\" title=\"4、JDK 9 为什么将Stirng的char[]改为byte[]？\"></a>4、JDK 9 为什么将Stirng的char[]改为byte[]？</h3><h5 id=\"1）内存的优化：\"><a href=\"#1）内存的优化：\" class=\"headerlink\" title=\"1）内存的优化：\"></a>1）内存的优化：</h5><p>​      用char数组时，一个char 占用 2 个字节，实际中，英文，数字，特殊字符占使用的大多数，且是需要 1 个字节。对于byte数组，字符，英文，数字等，都只占用 1 个字节，中文占用 2 个字。例如，对于 “Hello” ，char 数组存需要 5 * 2 &#x3D; 10B，对于byte数组只需要 5B，节省了近50%的空间。</p>\n<h5 id=\"2）自适应编码\"><a href=\"#2）自适应编码\" class=\"headerlink\" title=\"2）自适应编码\"></a>2）自适应编码</h5><p>​      根据不同的字符串使用不同的编码。当仅包含 1 个字节的字符时，String 中的coder标志位为 0 ，表示使用单字节编码字符集，当字符串中存在 2 个字节的字符时，String 中的coder标志位为 1，表示采用双字节编码字符集，同时，当单字节字符串拼接上双字节字符串时，会将coder升级为1，表示采用双字节编码字符集。</p>\n<h3 id=\"5、Substring-的优化？\"><a href=\"#5、Substring-的优化？\" class=\"headerlink\" title=\"5、Substring() 的优化？\"></a>5、Substring() 的优化？</h3><p>​      substring：在JDK 6 以及之前，时复用原数组，即使只是用一小部分呢，但是要保留整个字符串，导致原字符串无法被GC，在JDK 7 之后，则是会创建一个新的字符串返回，原字符串可以被GC。</p>\n","excerpt":"","more":"<h2 id=\"一、String-的特性\"><a href=\"#一、String-的特性\" class=\"headerlink\" title=\"一、String 的特性\"></a>一、String 的特性</h2><h3 id=\"1、String-为什么是不可变的？\"><a href=\"#1、String-为什么是不可变的？\" class=\"headerlink\" title=\"1、String 为什么是不可变的？\"></a>1、String 为什么是不可变的？</h3><h5 id=\"1）原因：\"><a href=\"#1）原因：\" class=\"headerlink\" title=\"1）原因：\"></a>1）原因：</h5><p>① <strong>安全性</strong>：String 类常用于存储敏感信息，如密码，路径等，如果它是可变的，攻击者可能通过修改字符串内容来绕过安全检查。同时Java的类加载器在加载类时会使用String来存储类名和包名，如果String是可变的，攻击者可能加载恶意的类破坏系统。Java String 类的不可变性，确保了这些关键字符串在创建并传递后，其值绝对无法被任何代码（包括自身）所改变，从根本上杜绝了被篡改的风险。是系统安全性的基石。</p>\n<p>② <strong>字符串常量池依赖不可变性</strong>：String 类是程序中最常用的，同时存在大量重复字符串，为了解决大量重复的问题，引入了字符串常量池，当创建字符串时，JVM 会优先从池中找，没有再创建，而这个优化完全依赖String的不可变性，因为常量池中的一个对象可能被多次引用，如果其中的任何一个引用能修改对象的值，那末就会导致所有共享该对象的引用全部出错。</p>\n<p>③ 在<strong>多线程</strong>模式下，可以自由传递、共享 String，不需要任何同步机制，简化了开发。</p>\n<p>④ 由于 String 的不可变性，因此 String 对象的hash值只用计算一次，后续直接从缓存中读取，提高了集合的性能。</p>\n<h5 id=\"2）实现方法：\"><a href=\"#2）实现方法：\" class=\"headerlink\" title=\"2）实现方法：\"></a>2）实现方法：</h5><p>​      <code>String</code> 类的核心参数为 <code>value</code> 数组，在<code>JDK 9</code> 之后，使用 <code>byte[]</code>  代替 <code>char[]</code> 。<code>value</code> 值由<code> final</code> 关键字修饰，保证数据引用的不变性，用 <code>private</code>修饰，保证外部无法直接修改，同时 <code>String</code> 类由 <code>final</code> 修饰，保证不会被继承，防止子类的修改。在 <code>JDK 9</code> 版本时，还引用了<code>Java</code> 的内部注解<code>@Stable</code>，修饰 <code>value</code> ，用于提示 <code>JVM</code> ，这是一个稳定的字段，一旦赋值，基本不会改变，是运行时的稳定承诺。当访问一个普通字段时，因可能被其他线程修改，理论上需每次从内存加载（但实际受 CPU 缓存优化影响，可能读取旧值）；但是由<code>@Stable</code> 注解修饰后，在高频访问时，可能在读取后，就将值存储到一个寄存器中，后续直接从寄存器中取值即可。同时，在编译时可能直接把这个值当作常量，将其内敛到使用它的地方，也被称为 常量折叠 提升运行速度。注意：仍可以用反射调用修改，但是开发者往往不被允许。</p>\n<h3 id=\"2、String、StirngBuffer、StirngBuilder-的区别？\"><a href=\"#2、String、StirngBuffer、StirngBuilder-的区别？\" class=\"headerlink\" title=\"2、String、StirngBuffer、StirngBuilder 的区别？\"></a>2、String、StirngBuffer、StirngBuilder 的区别？</h3><h5 id=\"1）不可变性：\"><a href=\"#1）不可变性：\" class=\"headerlink\" title=\"1）不可变性：\"></a>1）不可变性：</h5><p>​      String 是不可变的，任何操作都会产生新的对象，原字符串不做改变。StringBuilder 和 StringBuffer 都是可变的，都是直接在原对象上修改，避免创建新的对象。具体是StringBuilder 和 StringBuffer 都继承AbstractStringBuilder抽象类，其字符都是存储在 value 中，没有使用 final 修饰，当修改时，若 value 容量不够，则会将 value 数组进行扩容，之后，将新串复制到扩容后的数组中。因此只是替换了value数组，原StringBuilder 和 StringBuffer 对象的引用没有改变。</p>\n<h5 id=\"2）线程安全性：\"><a href=\"#2）线程安全性：\" class=\"headerlink\" title=\"2）线程安全性：\"></a>2）线程安全性：</h5><p>​      String 由不可变性，天然就是线程安全的。StringBuilder 是线程不安全的，多线程模式下可能会导致数据不一致问题。StringBuffer 是线程安全的，所有的方法都是用 Synchorized 修饰。</p>\n<h5 id=\"3）性能（大致）：\"><a href=\"#3）性能（大致）：\" class=\"headerlink\" title=\"3）性能（大致）：\"></a>3）性能（大致）：</h5><p>​      String（反复创建对象） &lt; StringBuffer（多线程下的加锁解锁） &lt; StringBuilder （单线程下性能高）</p>\n<h3 id=\"3、字符串常量池？\"><a href=\"#3、字符串常量池？\" class=\"headerlink\" title=\"3、字符串常量池？\"></a>3、字符串常量池？</h3><h5 id=\"1）存储位置：\"><a href=\"#1）存储位置：\" class=\"headerlink\" title=\"1）存储位置：\"></a>1）存储位置：</h5><p>​      在 JDK 7 之前，字符串常量池位于方法区的永久代中，在JDK 7 之后，字符串常量池也被移动至堆内。</p>\n<h5 id=\"2）存储内容：\"><a href=\"#2）存储内容：\" class=\"headerlink\" title=\"2）存储内容：\"></a>2）存储内容：</h5><p>​      在 JDK 7 之前，存储的是字符串本身，在移动到堆后，存储的是字符串在堆内存上的引用。对于没有引用的对象，可被垃圾回收器回收，防止内存泄漏。</p>\n<h5 id=\"3）使用方法：\"><a href=\"#3）使用方法：\" class=\"headerlink\" title=\"3）使用方法：\"></a>3）使用方法：</h5><p>​      String s1 &#x3D; “Hello” ，则会自动入池，并通过池中的引用指向堆中的“Hello”，而String s2 &#x3D; new String(“Hello”) ,则是直接在堆内存中创建了一个新的对象，不会进入字符串常量池中。但是可以使用 s2.intern() 方法，将字符串手动添加到常量池中，并返回引用。</p>\n<h5 id=\"4）数据结构：\"><a href=\"#4）数据结构：\" class=\"headerlink\" title=\"4）数据结构：\"></a>4）数据结构：</h5><p>​      字符串常量池是通过基于Hash表的StringTable实现，JDK 7 之前，固定大小，之后，可指定大小， JDK 9 时，将char[] 改为 byte[]。</p>\n<h3 id=\"4、JDK-9-为什么将Stirng的char-改为byte-？\"><a href=\"#4、JDK-9-为什么将Stirng的char-改为byte-？\" class=\"headerlink\" title=\"4、JDK 9 为什么将Stirng的char[]改为byte[]？\"></a>4、JDK 9 为什么将Stirng的char[]改为byte[]？</h3><h5 id=\"1）内存的优化：\"><a href=\"#1）内存的优化：\" class=\"headerlink\" title=\"1）内存的优化：\"></a>1）内存的优化：</h5><p>​      用char数组时，一个char 占用 2 个字节，实际中，英文，数字，特殊字符占使用的大多数，且是需要 1 个字节。对于byte数组，字符，英文，数字等，都只占用 1 个字节，中文占用 2 个字。例如，对于 “Hello” ，char 数组存需要 5 * 2 &#x3D; 10B，对于byte数组只需要 5B，节省了近50%的空间。</p>\n<h5 id=\"2）自适应编码\"><a href=\"#2）自适应编码\" class=\"headerlink\" title=\"2）自适应编码\"></a>2）自适应编码</h5><p>​      根据不同的字符串使用不同的编码。当仅包含 1 个字节的字符时，String 中的coder标志位为 0 ，表示使用单字节编码字符集，当字符串中存在 2 个字节的字符时，String 中的coder标志位为 1，表示采用双字节编码字符集，同时，当单字节字符串拼接上双字节字符串时，会将coder升级为1，表示采用双字节编码字符集。</p>\n<h3 id=\"5、Substring-的优化？\"><a href=\"#5、Substring-的优化？\" class=\"headerlink\" title=\"5、Substring() 的优化？\"></a>5、Substring() 的优化？</h3><p>​      substring：在JDK 6 以及之前，时复用原数组，即使只是用一小部分呢，但是要保留整个字符串，导致原字符串无法被GC，在JDK 7 之后，则是会创建一个新的字符串返回，原字符串可以被GC。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cuidVWHk18bODmiC7IMLz3-Ud","category_id":"cuidBbpchHrpkd0VH6pRGcmhb","_id":"cuidtQ9KFBrVR4aujZsJ9RN3K"},{"post_id":"cuid2aw45v5G25xChVnwAHIiZ","category_id":"cuidBbpchHrpkd0VH6pRGcmhb","_id":"cuidZvltYZ587Bo6XyKzcqYvS"},{"post_id":"cuidmGKQKXL0y_KNgGCaVpCeE","category_id":"cuidnT7-Rriacg3ozEOrrMBGD","_id":"cuidCPtggtYI8i9tblo2QioFI"},{"post_id":"cuide-qbUQdRvaOQ-8gEwQkNN","category_id":"cuidBbpchHrpkd0VH6pRGcmhb","_id":"cuidZq1YCK1UhMwrDW7d2XEEU"},{"post_id":"cuidVGruA96eAaiNIK55RB7P4","category_id":"cuidnT7-Rriacg3ozEOrrMBGD","_id":"cuidFe3zXNhi0tMk7NxPHLTZu"}],"PostTag":[{"post_id":"cuidVWHk18bODmiC7IMLz3-Ud","tag_id":"cuidsfqlaf25zONAFFiDlKiLO","_id":"cuidmb-sguP9DrbOdS8fU1Sxh"},{"post_id":"cuid2aw45v5G25xChVnwAHIiZ","tag_id":"cuidpBwVlga5Hz_UxrasddR7l","_id":"cuidIjqtcD_b0z1SjCKvZ1taC"},{"post_id":"cuidmGKQKXL0y_KNgGCaVpCeE","tag_id":"cuidEl6lsaZpOSBWsgylttn4Z","_id":"cuidVFbgBIZ7fN7lKyY8Z2iTI"},{"post_id":"cuidVGruA96eAaiNIK55RB7P4","tag_id":"cuidEl6lsaZpOSBWsgylttn4Z","_id":"cuiddnxWsBouzAmBG0VqHUi4u"},{"post_id":"cuide-qbUQdRvaOQ-8gEwQkNN","tag_id":"cuidAQP2J-ksPNTVupEv0Lfwh","_id":"cuidAHRVl2Y1i2gDKjhmS14A6"}],"Tag":[{"name":"ArrayList","_id":"cuidsfqlaf25zONAFFiDlKiLO"},{"name":"HashMap","_id":"cuidpBwVlga5Hz_UxrasddR7l"},{"name":"测试","_id":"cuidEl6lsaZpOSBWsgylttn4Z"},{"name":"String","_id":"cuidAQP2J-ksPNTVupEv0Lfwh"}]}}